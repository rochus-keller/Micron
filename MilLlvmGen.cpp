/*
* Copyright 2025 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the Micron language project.
*
* The following is the license that applies to this copy of the
* file. For a license to use the file under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "MilLlvmGen.h"
#include "MilValidator.h"
#include "MilProject.h"
#include <QDateTime>
#include <QCoreApplication>
#include <QtDebug>
using namespace Mil;

// Generate LLVM 4.0.1 textual IR

// TODO: interfaces not yet implemented; debugging pending

static inline QByteArray ws(int level)
{
    return QByteArray((level+1)*2,' ');
}

LlvmGen::LlvmGen(AstModel* mdl):mdl(mdl),tempCount(0),labelCount(0),structTypeCount(0)
{
    Q_ASSERT(mdl);
}

QString LlvmGen::genDedication()
{
    return "; this file was generated by " + QCoreApplication::applicationName() + " "
                                    + QCoreApplication::applicationVersion() + " on " + QDateTime::currentDateTime().toString();
}

bool LlvmGen::generate(Declaration* module, QIODevice* device)
{
    Q_ASSERT( module && device );
    curMod = module;
    out.setDevice(device);
    
    out << "; " << module->name << ".ll" << endl;
    out << genDedication() << endl << endl;
    
    out << "target datalayout = \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\"" << endl;
    out << "target triple = \"x86_64-unknown-linux-gnu\"" << endl << endl;
    
    visitModule();
    
    return true;
}

QByteArray LlvmGen::qualident(Declaration* d)
{
    if( d->outer )
        return qualident(d->outer) + "$" + d->forwardToProc()->name;
    else
        return d->name;
}

QByteArray LlvmGen::mangle(const QByteArray& name)
{
    return "@" + name;
}

void LlvmGen::declareBuiltins()
{
    out << "; Runtime functions" << endl;
    out << "declare i8* @calloc(i64, i64)" << endl;
    out << "declare void @free(i8*)" << endl;
    out << "declare void @llvm.memset.p0i8.i64(i8*, i8, i64, i32, i1)" << endl;
    out << "declare void @llvm.memcpy.p0i8.p0i8.i64(i8*, i8*, i64, i32, i1)" << endl;
    out << "declare double @llvm.fabs.f64(double)" << endl;
    out << "declare float @llvm.fabs.f32(float)" << endl << endl;
}

void LlvmGen::visitModule()
{
    collectStructTypes(curMod);
    declareBuiltins();
    
    // Forward declare all procedures first
    Declaration* sub = curMod->subs;
    while( sub )
    {
        if( sub->kind == Declaration::Procedure && !sub->extern_ && !sub->foreign_ )
        {
            out << "declare ";
            procHeader(sub);
            out << endl;
        }
        sub = sub->next;
    }
    out << endl;
    
    // Declare global variables
    sub = curMod->subs;
    while( sub )
    {
        if( sub->kind == Declaration::VarDecl )
        {
            out << mangle(qualident(sub)) << " = global " << getLlvmType(sub->getType());
            out << " " << getConstant(sub->getType()) << endl;
        }
        sub = sub->next;
    }
    out << endl;
    
    // Constants
    sub = curMod->subs;
    while( sub )
    {
        if( sub->kind == Declaration::ConstDecl )
            constDecl(sub);
        sub = sub->next;
    }
    
    // Type declarations and methods
    sub = curMod->subs;
    while( sub )
    {
        if( sub->kind == Declaration::TypeDecl )
        {
            Type* t = deref(sub->getType());
            if( t && t->kind == Type::Object )
            {
                visitMetaDecl(sub);
                foreach( Declaration* p, t->subs )
                {
                    if( p->kind == Declaration::Procedure )
                        visitProcedure(p);
                }
                if( t->objectInit )
                    emitInitializer(t);
            }
        }
        sub = sub->next;
    }
    
    // Regular procedures
    bool initFound = false;
    sub = curMod->subs;
    while( sub )
    {
        if( sub->kind == Declaration::Procedure )
        {
            visitProcedure(sub);
            if( sub->entryPoint )
                initFound = true;
        }
        sub = sub->next;
    }
    
    // Generate module initializer if needed
    if( !initFound )
    {
        Declaration proc;
        proc.kind = Declaration::Procedure;
        proc.entryPoint = true;
        proc.outer = curMod;
        proc.name = "begin$";
        visitProcedure(&proc);
    }
}

void LlvmGen::collectStructTypes(Declaration* module)
{
    Declaration* sub = module->subs;
    while( sub )
    {
        if( sub->kind == Declaration::TypeDecl )
        {
            Type* t = deref(sub->getType());
            if( t && t->isSUO() )
                declareStructType(t);
        }
        sub = sub->next;
    }
}

void LlvmGen::declareStructType(Type* t)
{
    if( !t || !t->isSUO() )
        return;
        
    QByteArray name;
    if( t->decl )
    {
        name = "%" + qualident(t->decl);
        if( structTypes.contains(t->decl) )
            return;
        structTypes[t->decl] = name;
    }
    else
    {
        if( anonStructTypes.contains(t) )
            return;
        name = "%struct.anon." + QByteArray::number(structTypeCount++);
        anonStructTypes[t] = name;
    }
    
    out << name << " = type { ";
    
    if( t->kind == Type::Object )
    {
        // vtable pointer first
        out << name << ".vtbl*";
        QList<Declaration*> fields = t->getFieldList(true);
        if( !fields.isEmpty() )
            out << ", ";
        for( int i = 0; i < fields.size(); i++ )
        {
            if( i > 0 )
                out << ", ";
            out << getLlvmType(fields[i]->getType());
        }
    }
    else
    {
        // Struct or Union
        bool first = true;
        foreach( Declaration* field, t->subs )
        {
            if( field->kind == Declaration::Field )
            {
                if( !first )
                    out << ", ";
                out << getLlvmType(field->getType());
                first = false;
            }
        }
    }
    
    out << " }" << endl;
    
    // For objects, also declare vtable type
    if( t->kind == Type::Object && t->decl )
    {
        out << name << ".vtbl = type { ";
        
        Type* base = t->getType();
        if( base )
            out << "%" << qualident(base->decl) << ".vtbl*";
        else
            out << "i8*";
            
        DeclList methods = t->getMethodTable();
        if( !methods.isEmpty() && base )
            out << ", ";
            
        for( int i = 0; i < methods.size(); i++ )
        {
            if( i > 0 || base )
                out << ", ";
            out << getLlvmType(methods[i]->getType()) << "*";
        }
        out << " }" << endl;
    }
}

QByteArray LlvmGen::getLlvmType(Type* t)
{
    if( t == 0 )
        return "void";
        
    t = deref(t);
    
    switch(t->kind)
    {
    case Type::Any:
        return "void";
    case Type::StringLit:
        return "i8*";
    case Type::ByteArrayLit:
        return "i8*";
    case Type::NIL:
        return "i8*";
    case Type::BOOL:
        return "i1";
    case Type::CHAR:
        return "i8";
    case Type::INT8:
        return "i8";
    case Type::INT16:
        return "i16";
    case Type::INT32:
        return "i32";
    case Type::INT64:
        return "i64";
    case Type::UINT8:
        return "i8";
    case Type::UINT16:
        return "i16";
    case Type::UINT32:
        return "i32";
    case Type::UINT64:
        return "i64";
    case Type::FLOAT32:
        return "float";
    case Type::FLOAT64:
        return "double";
    case Type::INTPTR:
        return "i8*";
    case Type::DBLINTPTR:
        return "i128";
    }

    if( t->kind == Type::Pointer )
    {
        Type* tt = deref(t->getType());
        if( tt->kind == Type::Array )
            return getLlvmType(tt->getType()) + "*";
        else
            return getLlvmType(tt) + "*";
    }
    else if( t->kind == Type::Array )
    {
        return "[" + QByteArray::number(t->len ? t->len : 0) + " x " + 
               getLlvmType(t->getType()) + "]";
    }
    else if( t->kind == Type::Proc )
    {
        QByteArray res = getLlvmType(t->getType()) + " (";
        DeclList params = t->subs;
        for( int i = 0; i < params.size(); i++ )
        {
            if( i != 0 )
                res += ", ";
            res += getLlvmType(params[i]->getType());
        }
        res += ")*";
        return res;
    }
    else if( t->decl )
    {
        if( structTypes.contains(t->decl) )
            return structTypes[t->decl];
        else if( t->isSUO() )
            return "%" + qualident(t->decl);
        else
            return getLlvmType(deref(t->decl->getType()));
    }
    else if( anonStructTypes.contains(t) )
        return anonStructTypes[t];
    
    return "i8";
}

QByteArray LlvmGen::getLlvmIntType(Type* t)
{
    t = deref(t);
    if( t->isInteger() || t->kind == Type::BOOL || t->kind == Type::CHAR )
        return getLlvmType(t);
    return "i32";
}

QByteArray LlvmGen::getLlvmFloatType(Type* t)
{
    t = deref(t);
    if( t->isFloat() )
        return getLlvmType(t);
    return "double";
}

QByteArray LlvmGen::getConstant(Type* t, qint64 val)
{
    t = deref(t);
    switch(t->kind)
    {
    case Type::BOOL:
        return val ? "true" : "false";
    case Type::INTPTR:
    case Type::NIL:
        return "null";
    case Type::FLOAT32:
    case Type::FLOAT64:
        return "0.0";
    default:
        if( t->isInteger() || t->kind == Type::CHAR )
            return QByteArray::number(val);
        else if( t->isSUOA() )
            return "zeroinitializer";
    }
    return "zeroinitializer";
}

void LlvmGen::resetCounters()
{
    tempCount = 0;
    labelCount = 0;
    locals.clear();
    params.clear();
}

QByteArray LlvmGen::nextTemp()
{
    return "%t" + QByteArray::number(tempCount++);
}

QByteArray LlvmGen::nextLabel()
{
    return "L" + QByteArray::number(labelCount++);
}

void LlvmGen::procHeader(Declaration* proc)
{
    out << getLlvmType(proc->getType()) << " " << mangle(qualident(proc->forwardToProc()));
    out << "(";
    DeclList params = proc->getParams();
    for( int i = 0; i < params.size(); i++ )
    {
        if( i != 0 )
            out << ", ";
        parameter(params[i], i == 0);
    }
    out << ")";
}

void LlvmGen::parameter(Declaration* param, bool first)
{
    out << getLlvmType(param->getType());
    if( first && curProc )
        out << " %self";
    else
        out << " %" << param->name;
}

void LlvmGen::visitProcedure(Declaration* proc)
{
    if( proc->forward || proc->extern_ || proc->foreign_ )
        return;
        
    curProc = proc;
    resetCounters();
    
    out << endl << "define ";
    procHeader(proc);
    out << " {" << endl;
    
    out << "entry:" << endl;
    
    // Allocate space for parameters
    DeclList procParams = proc->getParams();
    for( int i = 0; i < procParams.size(); i++ )
    {
        QByteArray pname = "%" + procParams[i]->name;
        QByteArray aname = allocaVar(procParams[i]->getType(), procParams[i]->name + ".addr");
        params[procParams[i]] = aname;
        emitStore(pname, aname);
    }
    
    // Module initialization for entry point
    if( proc->entryPoint && !curMod->nobody )
    {
        QByteArray doneFlag = allocaVar(mdl->getBasicType(Type::INT32), "done$");
        out << ws(0) << "store i32 0, i32* " << doneFlag << endl;
        QByteArray val = nextTemp();
        out << ws(0) << val << " = load i32, i32* " << doneFlag << endl;
        QByteArray cond = nextTemp();
        out << ws(0) << cond << " = icmp eq i32 " << val << ", 0" << endl;
        
        QByteArray initLabel = nextLabel();
        QByteArray endLabel = nextLabel();
        out << ws(0) << "br i1 " << cond << ", label %" << initLabel << ", label %" << endLabel << endl;
        
        out << initLabel << ":" << endl;
        out << ws(0) << "store i32 1, i32* " << doneFlag << endl;
        
        Declaration* sub = curMod->subs;
        while( sub )
        {
            if( sub->kind == Declaration::Import && !sub->imported->nobody )
            {
                out << ws(0) << "call void " << mangle(sub->imported->name) << "$begin$()" << endl;
            }
            else if( sub->kind == Declaration::VarDecl )
            {
                emitSoapInit(mangle(qualident(sub)), sub->getType(), 0);
            }
            sub = sub->next;
        }
        
        out << ws(0) << "br label %" << endLabel << endl;
        out << endLabel << ":" << endl;
    }
    
    // Allocate locals
    Declaration* sub = proc->subs;
    while(sub)
    {
        if( sub->kind == Declaration::LocalDecl )
        {
            QByteArray name = allocaVar(sub->getType(), sub->name);
            locals[sub] = name;
            emitSoapInit(name, sub->getType(), 0);
        }
        sub = sub->next;
    }
    
    // Generate body
    statementSeq(proc->body);
    
    // Default return if needed
    Type* retType = proc->getType();
    if( !retType || retType->kind == Type::Any )
        out << ws(0) << "ret void" << endl;
    else
        out << ws(0) << "ret " << getLlvmType(retType) << " " << getConstant(retType) << endl;
        
    out << "}" << endl;
    
    curProc = 0;
}

void LlvmGen::visitMetaDecl(Declaration* d)
{
    const QByteArray className = qualident(d);
    Type* t = deref(d->getType());
    
    out << endl << "; VTable for " << className << endl;
    out << mangle(className) << "$vtbl = global %" << className << ".vtbl { ";
    
    if( t->getType() )
        out << "%" << qualident(t->getType()->decl) << ".vtbl* " << mangle(qualident(t->getType()->decl)) << "$vtbl";
    else
        out << "i8* null";
        
    DeclList methods = t->getMethodTable();
    if( !methods.isEmpty() && t->getType() )
        out << ", ";
        
    for( int i = 0; i < methods.size(); i++ )
    {
        if( i > 0 || t->getType() )
            out << ", ";
        out << getLlvmType(methods[i]->getType()) << "* " << mangle(qualident(methods[i]));
    }
    
    out << " }" << endl;
}

void LlvmGen::emitInitializer(Type* t)
{
    t = deref(t);
    QByteArray typeName = qualident(t->decl);
    
    out << endl << "define void " << mangle(typeName) << "$init(%" << typeName << "* %obj, i32 %n) {" << endl;
    out << "entry:" << endl;
    
    QByteArray counter = allocaVar(mdl->getBasicType(Type::INT32), "i");
    out << ws(0) << "store i32 0, i32* " << counter << endl;
    
    QByteArray loopLabel = nextLabel();
    QByteArray bodyLabel = nextLabel();
    QByteArray endLabel = nextLabel();
    
    out << ws(0) << "br label %" << loopLabel << endl;
    out << loopLabel << ":" << endl;
    
    QByteArray i = nextTemp();
    out << ws(0) << i << " = load i32, i32* " << counter << endl;
    QByteArray cond = nextTemp();
    out << ws(0) << cond << " = icmp slt i32 " << i << ", %n" << endl;
    out << ws(0) << "br i1 " << cond << ", label %" << bodyLabel << ", label %" << endLabel << endl;
    
    out << bodyLabel << ":" << endl;
    
    if( t->kind == Type::Object )
    {
        // Set vtable pointer
        QByteArray vtblPtr = nextTemp();
        out << ws(0) << vtblPtr << " = getelementptr %" << typeName << ", %" << typeName 
            << "* %obj, i32 " << i << ", i32 0" << endl;
        out << ws(0) << "store %" << typeName << ".vtbl* " << mangle(typeName) << "$vtbl, %"
            << typeName << ".vtbl** " << vtblPtr << endl;
    }
    
    // Initialize fields
    QList<Declaration*> fields = t->kind == Type::Object ? t->getFieldList(true) : t->subs;
    int fieldIdx = t->kind == Type::Object ? 1 : 0;
    foreach( Declaration* field, fields )
    {
        if( field->kind != Declaration::Field )
            continue;
        Type* ft = deref(field->getType());
        if( ft->objectInit && ft->isSO() )
        {
            QByteArray fieldPtr = nextTemp();
            out << ws(0) << fieldPtr << " = getelementptr %" << typeName << ", %" << typeName 
                << "* %obj, i32 " << i << ", i32 " << fieldIdx << endl;
            out << ws(0) << "call void " << mangle(qualident(ft->decl)) << "$init(%" 
                << qualident(ft->decl) << "* " << fieldPtr << ", i32 1)" << endl;
        }
        fieldIdx++;
    }
    
    // Increment and loop
    QByteArray nextI = nextTemp();
    out << ws(0) << nextI << " = add i32 " << i << ", 1" << endl;
    out << ws(0) << "store i32 " << nextI << ", i32* " << counter << endl;
    out << ws(0) << "br label %" << loopLabel << endl;
    
    out << endLabel << ":" << endl;
    out << ws(0) << "ret void" << endl;
    out << "}" << endl;
}

Type* LlvmGen::deref(Type* t)
{
    if( t && t->kind == Type::NameRef )
        return deref(t->getType());
    else if( t )
        return t;
    else
        return mdl->getBasicType(Type::Undefined);
}

void LlvmGen::constDecl(Declaration* decl)
{
    // LLVM doesn't have preprocessor constants like C
    // We'll handle constants inline when referenced
}

void LlvmGen::constValue(Constant* c, Type* t)
{
    if( c == 0 )
    {
        out << "0";
        return;
    }
    
    switch( c->kind )
    {
    case Constant::D:
        out << QByteArray::number(c->d, 'e', 16);
        break;
    case Constant::I:
        out << c->i;
        break;
    case Constant::S:
        {
            // Need to create a global string constant
            QByteArray name = nextTemp() + ".str";
            QByteArray str(c->s);
            int len = str.length() + 1;
            out << "getelementptr ([" << len << " x i8], [" << len << " x i8]* ";
            out << "@.str." << tempCount << ", i32 0, i32 0)";
            // Note: In real implementation, would need to declare global string constants
        }
        break;
    case Constant::B:
        out << "[ ";
        for( int i = 0; i < c->b->len; i++ )
        {
            if( i > 0 )
                out << ", ";
            out << "i8 " << (int)c->b->b[i];
        }
        out << " ]";
        break;
    case Constant::R:
        constValue(c->r->c, t);
        break;
    case Constant::C:
        out << "{ ";
        for( int i = 0; i < c->c->c.size(); i++ )
        {
            if( i != 0 )
                out << ", ";
            // Need type info for components
            constValue(c->c->c[i].c);
        }
        out << " }";
        break;
    }
}

QByteArray LlvmGen::allocaVar(Type* t, const QByteArray& name)
{
    QByteArray varName = "%" + name;
    out << ws(0) << varName << " = alloca " << getLlvmType(t) << endl;
    return varName;
}

QByteArray LlvmGen::emitLoad(Type* t, const QByteArray& ptr)
{
    QByteArray temp = nextTemp();
    out << ws(0) << temp << " = load " << getLlvmType(t) << ", " 
        << getLlvmType(t) << "* " << ptr << endl;
    return temp;
}

void LlvmGen::emitSoapInit(const QByteArray& name, Type* t, int level)
{
    t = deref(t);
    if( t->kind == Type::Pointer && t->pointerInit )
    {
        out << ws(level) << "store " << getLlvmType(t) << " null, " 
            << getLlvmType(t) << "* " << name << endl;
    }
    else if( t->isSUOA() && t->pointerInit )
    {
        // Zero initialize struct
        QByteArray temp = nextTemp();
        out << ws(level) << temp << " = bitcast " << getLlvmType(t) << "* " << name 
            << " to i8*" << endl;
        out << ws(level) << "call void @llvm.memset.p0i8.i64(i8* " << temp 
            << ", i8 0, i64 " << t->getByteSize(8) << ", i32 1, i1 false)" << endl;
    }
    
    // Handle objects with init functions
    if( t->objectInit && t->isSO() )
    {
        out << ws(level) << "call void " << mangle(qualident(t->decl)) 
            << "$init(" << getLlvmType(t) << "* " << name << ", i32 1)" << endl;
    }
}

void LlvmGen::statementSeq(Statement* s, int level)
{
    while(s)
    {
        switch( s->kind )
        {
        case Statement::ExprStat:
            if( s->args )
            {
                expression(s->args, level);
            }
            break;

        case IL_if:
            {
                QByteArray cond = expression(s->args, level+1);
                QByteArray thenLabel = nextLabel();
                QByteArray elseLabel = nextLabel();
                QByteArray endLabel = nextLabel();
                
                bool hasElse = (s->next && s->next->kind == IL_else);
                
                out << ws(level) << "br i1 " << cond << ", label %" << thenLabel 
                    << ", label %" << (hasElse ? elseLabel : endLabel) << endl;
                
                out << thenLabel << ":" << endl;
                statementSeq(s->body, level+1);
                out << ws(level) << "br label %" << endLabel << endl;
                
                if( hasElse )
                {
                    s = s->next;
                    out << elseLabel << ":" << endl;
                    statementSeq(s->body, level+1);
                    out << ws(level) << "br label %" << endLabel << endl;
                }
                
                out << endLabel << ":" << endl;
            }
            break;

        case IL_loop:
            {
                QByteArray loopLabel = nextLabel();
                out << ws(level) << "br label %" << loopLabel << endl;
                out << loopLabel << ":" << endl;
                statementSeq(s->body, level+1);
                out << ws(level) << "br label %" << loopLabel << endl;
            }
            break;

        case IL_while:
            {
                QByteArray condLabel = nextLabel();
                QByteArray bodyLabel = nextLabel();
                QByteArray endLabel = nextLabel();
                
                out << ws(level) << "br label %" << condLabel << endl;
                out << condLabel << ":" << endl;
                
                QByteArray cond = expression(s->args, level+1);
                out << ws(level) << "br i1 " << cond << ", label %" << bodyLabel 
                    << ", label %" << endLabel << endl;
                
                out << bodyLabel << ":" << endl;
                statementSeq(s->body, level+1);
                out << ws(level) << "br label %" << condLabel << endl;
                
                out << endLabel << ":" << endl;
            }
            break;

        case IL_repeat:
            {
                QByteArray bodyLabel = nextLabel();
                QByteArray condLabel = nextLabel();
                QByteArray endLabel = nextLabel();
                
                out << ws(level) << "br label %" << bodyLabel << endl;
                out << bodyLabel << ":" << endl;
                statementSeq(s->body, level+1);
                
                out << ws(level) << "br label %" << condLabel << endl;
                out << condLabel << ":" << endl;
                QByteArray cond = expression(s->args, level+1);
                QByteArray notCond = nextTemp();
                out << ws(level) << notCond << " = xor i1 " << cond << ", true" << endl;
                out << ws(level) << "br i1 " << notCond << ", label %" << bodyLabel 
                    << ", label %" << endLabel << endl;
                
                out << endLabel << ":" << endl;
            }
            break;

        case IL_switch:
            {
                QByteArray val = expression(s->args, level+1);
                QByteArray defaultLabel = nextLabel();
                QByteArray endLabel = nextLabel();
                
                // Count cases
                int numCases = 0;
                Statement* cs = s->next;
                while( cs && cs->kind == IL_case )
                {
                    Expression* e = cs->e;
                    while(e) { numCases++; e = e->next; }
                    cs = cs->next;
                }
                
                out << ws(level) << "switch " << getLlvmIntType(s->args->getType()) 
                    << " " << val << ", label %" << defaultLabel << " [" << endl;
                
                cs = s->next;
                while( cs && cs->kind == IL_case )
                {
                    QByteArray caseLabel = nextLabel();
                    Expression* e = cs->e;
                    while(e)
                    {
                        out << ws(level+1) << getLlvmIntType(e->getType()) << " ";
                        expression(e, level+2);
                        out << ", label %" << caseLabel << endl;
                        e = e->next;
                    }
                    cs = cs->next;
                }
                out << ws(level) << "]" << endl;
                
                // Generate case bodies
                cs = s->next;
                int caseNum = 0;
                while( cs && cs->kind == IL_case )
                {
                    out << "L" << (labelCount - numCases + caseNum) << ":" << endl;
                    statementSeq(cs->body, level+1);
                    out << ws(level) << "br label %" << endLabel << endl;
                    cs = cs->next;
                    caseNum++;
                }
                
                // Default case
                out << defaultLabel << ":" << endl;
                if( s->next && s->next->kind == IL_else )
                {
                    s = s->next;
                    statementSeq(s->body, level+1);
                }
                out << ws(level) << "br label %" << endLabel << endl;
                
                out << endLabel << ":" << endl;
            }
            break;

        case IL_exit:
            // Need context of which loop to break from
            out << ws(level) << "; TODO: break" << endl;
            break;

        case IL_stloc:
        case IL_stloc_s:
        case IL_stloc_0:
        case IL_stloc_1:
        case IL_stloc_2:
        case IL_stloc_3:
            {
                DeclList localList = curProc->getLocals();
                Q_ASSERT(s->id < localList.size());
                QByteArray val = expression(s->args, level + 1);
                out << ws(level) << "store " << getLlvmType(localList[s->id]->getType()) 
                    << " " << val << ", " << getLlvmType(localList[s->id]->getType()) 
                    << "* " << locals[localList[s->id]] << endl;
            }
            break;

        case IL_starg:
            {
                DeclList paramList = curProc->getParams();
                Q_ASSERT(s->id < paramList.size());
                QByteArray val = expression(s->args, level + 1);
                out << ws(level) << "store " << getLlvmType(paramList[s->id]->getType()) 
                    << " " << val << ", " << getLlvmType(paramList[s->id]->getType()) 
                    << "* " << params[paramList[s->id]] << endl;
            }
            break;

        case IL_stind:
        case IL_stind_i1:
        case IL_stind_i4:
        case IL_stind_i8:
        case IL_stind_r4:
        case IL_stind_r8:
        case IL_stind_ip:
        case IL_stind_ipp:
            {
                Q_ASSERT( s->args && s->args->kind == Expression::Argument );
                QByteArray ptr = expression(s->args->lhs, level+1);
                QByteArray val = expression(s->args->rhs, level+1);
                Type* t = s->args->lhs->getType();
                if( t && t->kind == Type::Pointer )
                    t = t->getType();
                out << ws(level) << "store " << getLlvmType(t) << " " << val 
                    << ", " << getLlvmType(t) << "* " << ptr << endl;
            }
            break;

        case IL_stelem:
        case IL_stelem_i1:
        case IL_stelem_i2:
        case IL_stelem_i4:
        case IL_stelem_i8:
        case IL_stelem_r4:
        case IL_stelem_r8:
        case IL_stelem_ip:
            {
                Q_ASSERT( s->args && s->args->kind == Expression::Argument &&
                          s->args->lhs && s->args->rhs &&
                          s->args->next && s->args->next->kind == Expression::Argument &&
                          s->args->next->rhs && s->args->next->lhs == 0);
                QByteArray arr = expression(s->args->next->rhs, level+1);
                QByteArray idx = expression(s->args->lhs, level+1);
                QByteArray val = expression(s->args->rhs, level+1);
                
                Type* arrType = s->args->next->rhs->getType();
                Type* elemType = 0;
                if( arrType && arrType->kind == Type::Pointer )
                    elemType = arrType->getType();
                else if( arrType && arrType->kind == Type::Array )
                    elemType = arrType->getType();
                    
                QByteArray ptr = nextTemp();
                out << ws(level) << ptr << " = getelementptr " << getLlvmType(elemType) 
                    << ", " << getLlvmType(elemType) << "* " << arr << ", " 
                    << getLlvmIntType(s->args->lhs->getType()) << " " << idx << endl;
                out << ws(level) << "store " << getLlvmType(elemType) << " " << val 
                    << ", " << getLlvmType(elemType) << "* " << ptr << endl;
            }
            break;

        case IL_stfld:
            {
                Q_ASSERT( s->args && s->args->kind == Expression::Argument );
                QByteArray obj = expression(s->args->lhs, level+1);
                QByteArray val = expression(s->args->rhs, level+1);
                
                Type* objType = s->args->lhs->getType();
                if( objType && objType->kind == Type::Pointer )
                    objType = objType->getType();
                    
                // Find field index
                int fieldIdx = 0;
                if( objType && objType->kind == Type::Object )
                {
                    fieldIdx = 1; // Skip vtable pointer
                    QList<Declaration*> fields = objType->getFieldList(true);
                    for( int i = 0; i < fields.size(); i++ )
                    {
                        if( fields[i] == s->d )
                            break;
                        fieldIdx++;
                    }
                }
                else if( objType )
                {
                    foreach( Declaration* field, objType->subs )
                    {
                        if( field->kind == Declaration::Field )
                        {
                            if( field == s->d )
                                break;
                            fieldIdx++;
                        }
                    }
                }
                
                QByteArray ptr = nextTemp();
                out << ws(level) << ptr << " = getelementptr " << getLlvmType(objType) 
                    << ", " << getLlvmType(objType) << "* " << obj << ", i32 0, i32 " 
                    << fieldIdx << endl;
                out << ws(level) << "store " << getLlvmType(s->d->getType()) << " " << val 
                    << ", " << getLlvmType(s->d->getType()) << "* " << ptr << endl;
            }
            break;

        case IL_stvar:
            {
                QByteArray val = expression(s->args, level+1);
                out << ws(level) << "store " << getLlvmType(s->d->getType()) << " " << val 
                    << ", " << getLlvmType(s->d->getType()) << "* " 
                    << mangle(qualident(s->d)) << endl;
            }
            break;

        case IL_ret:
            if( s->args )
            {
                QByteArray val = expression(s->args, level+1);
                out << ws(level) << "ret " << getLlvmType(s->args->getType()) 
                    << " " << val << endl;
            }
            else
                out << ws(level) << "ret void" << endl;
            break;

        case IL_pop:
            expression(s->args, level+1);
            break;

        case IL_free:
            {
                QByteArray ptr = expression(s->args, level+1);
                QByteArray cast = nextTemp();
                out << ws(level) << cast << " = bitcast " << getLlvmType(s->args->getType()) 
                    << " " << ptr << " to i8*" << endl;
                out << ws(level) << "call void @free(i8* " << cast << ")" << endl;
            }
            break;

        case IL_label:
            out << s->name << ":" << endl;
            break;

        case IL_goto:
            out << ws(level) << "br label %" << s->name << endl;
            break;

        case IL_line:
            // Metadata for debugging
            break;

        default:
            Q_ASSERT(false);
        }

        s = s->next;
    }
}

void LlvmGen::emitStore(const QByteArray& val, const QByteArray& ptr)
{
    // Type needs to be inferred from context
    out << ws(0) << "store " << val << ", " << ptr << endl;
}

QByteArray LlvmGen::emitGetElementPtr(Type* baseType, const QByteArray& ptr, const QByteArray& idx)
{
    QByteArray temp = nextTemp();
    out << ws(0) << temp << " = getelementptr " << getLlvmType(baseType) 
        << ", " << getLlvmType(baseType) << "* " << ptr << ", i32 " << idx << endl;
    return temp;
}

QByteArray LlvmGen::emitCast(const QByteArray& val, Type* from, Type* to)
{
    from = deref(from);
    to = deref(to);
    
    if( from == to )
        return val;
        
    QByteArray temp = nextTemp();
    
    // Determine cast operation
    bool fromInt = from->isInteger() || from->kind == Type::BOOL || from->kind == Type::CHAR;
    bool toInt = to->isInteger() || to->kind == Type::BOOL || to->kind == Type::CHAR;
    bool fromFloat = from->isFloat();
    bool toFloat = to->isFloat();
    bool fromPtr = from->isPointer();
    bool toPtr = to->isPointer();
    
    if( fromInt && toInt )
    {
        // Integer to integer
        int fromBits = from->getByteSize(8) * 8;
        int toBits = to->getByteSize(8) * 8;
        
        if( fromBits < toBits )
        {
            // Sign or zero extend
            if( from->kind >= Type::INT8 && from->kind <= Type::INT64 )
                out << ws(0) << temp << " = sext " << getLlvmType(from) << " " << val 
                    << " to " << getLlvmType(to) << endl;
            else
                out << ws(0) << temp << " = zext " << getLlvmType(from) << " " << val 
                    << " to " << getLlvmType(to) << endl;
        }
        else if( fromBits > toBits )
        {
            // Truncate
            out << ws(0) << temp << " = trunc " << getLlvmType(from) << " " << val 
                << " to " << getLlvmType(to) << endl;
        }
        else
            return val;
    }
    else if( fromInt && toFloat )
    {
        // Integer to float
        if( from->kind >= Type::INT8 && from->kind <= Type::INT64 )
            out << ws(0) << temp << " = sitofp " << getLlvmType(from) << " " << val 
                << " to " << getLlvmType(to) << endl;
        else
            out << ws(0) << temp << " = uitofp " << getLlvmType(from) << " " << val 
                << " to " << getLlvmType(to) << endl;
    }
    else if( fromFloat && toInt )
    {
        // Float to integer
        if( to->kind >= Type::INT8 && to->kind <= Type::INT64 )
            out << ws(0) << temp << " = fptosi " << getLlvmType(from) << " " << val 
                << " to " << getLlvmType(to) << endl;
        else
            out << ws(0) << temp << " = fptoui " << getLlvmType(from) << " " << val 
                << " to " << getLlvmType(to) << endl;
    }
    else if( fromFloat && toFloat )
    {
        // Float to float
        if( from->kind == Type::FLOAT32 && to->kind == Type::FLOAT64 )
            out << ws(0) << temp << " = fpext float " << val << " to double" << endl;
        else
            out << ws(0) << temp << " = fptrunc double " << val << " to float" << endl;
    }
    else if( fromPtr && toPtr )
    {
        // Pointer to pointer
        out << ws(0) << temp << " = bitcast " << getLlvmType(from) << " " << val 
            << " to " << getLlvmType(to) << endl;
    }
    else if( fromInt && toPtr )
    {
        // Integer to pointer
        out << ws(0) << temp << " = inttoptr " << getLlvmType(from) << " " << val 
            << " to " << getLlvmType(to) << endl;
    }
    else if( fromPtr && toInt )
    {
        // Pointer to integer
        out << ws(0) << temp << " = ptrtoint " << getLlvmType(from) << " " << val 
            << " to " << getLlvmType(to) << endl;
    }
    else
        return val;
        
    return temp;
}

QByteArray LlvmGen::expression(Expression* e, int level)
{
    QByteArray result;
    
    switch(e->kind)
    {
    case IL_add:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            Type* t = e->getType();
            if( deref(t)->isFloat() )
                out << ws(level) << result << " = fadd " << getLlvmFloatType(t) << " " << lhs << ", " << rhs << endl;
            else
                out << ws(level) << result << " = add " << getLlvmIntType(t) << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_sub:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            Type* t = e->getType();
            if( deref(t)->isFloat() )
                out << ws(level) << result << " = fsub " << getLlvmFloatType(t) << " " << lhs << ", " << rhs << endl;
            else
                out << ws(level) << result << " = sub " << getLlvmIntType(t) << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_mul:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            Type* t = e->getType();
            if( deref(t)->isFloat() )
                out << ws(level) << result << " = fmul " << getLlvmFloatType(t) << " " << lhs << ", " << rhs << endl;
            else
                out << ws(level) << result << " = mul " << getLlvmIntType(t) << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_div:
    case IL_div_un:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            Type* t = e->getType();
            if( deref(t)->isFloat() )
                out << ws(level) << result << " = fdiv " << getLlvmFloatType(t) << " " << lhs << ", " << rhs << endl;
            else if( e->kind == IL_div_un )
                out << ws(level) << result << " = udiv " << getLlvmIntType(t) << " " << lhs << ", " << rhs << endl;
            else
                out << ws(level) << result << " = sdiv " << getLlvmIntType(t) << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_rem:
    case IL_rem_un:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            Type* t = e->getType();
            if( deref(t)->isFloat() )
                out << ws(level) << result << " = frem " << getLlvmFloatType(t) << " " << lhs << ", " << rhs << endl;
            else if( e->kind == IL_rem_un )
                out << ws(level) << result << " = urem " << getLlvmIntType(t) << " " << lhs << ", " << rhs << endl;
            else
                out << ws(level) << result << " = srem " << getLlvmIntType(t) << " " << lhs << ", " << rhs << endl;
        }
        break;

    case IL_and:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            out << ws(level) << result << " = and " << getLlvmIntType(e->getType()) 
                << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_or:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            out << ws(level) << result << " = or " << getLlvmIntType(e->getType()) 
                << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_xor:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            out << ws(level) << result << " = xor " << getLlvmIntType(e->getType()) 
                << " " << lhs << ", " << rhs << endl;
        }
        break;

    case IL_shl:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            out << ws(level) << result << " = shl " << getLlvmIntType(e->getType()) 
                << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_shr:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            out << ws(level) << result << " = ashr " << getLlvmIntType(e->getType()) 
                << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_shr_un:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            out << ws(level) << result << " = lshr " << getLlvmIntType(e->getType()) 
                << " " << lhs << ", " << rhs << endl;
        }
        break;

    case IL_neg:
        {
            QByteArray val = expression(e->lhs, level+1);
            result = nextTemp();
            Type* t = e->getType();
            if( deref(t)->isFloat() )
                out << ws(level) << result << " = fneg " << getLlvmFloatType(t) << " " << val << endl;
            else
                out << ws(level) << result << " = sub " << getLlvmIntType(t) << " 0, " << val << endl;
        }
        break;
        
    case IL_abs:
        {
            QByteArray val = expression(e->lhs, level+1);
            result = nextTemp();
            Type* t = e->lhs->getType();
            if( deref(t)->isFloat() )
            {
                if( deref(t)->kind == Type::FLOAT32 )
                    out << ws(level) << result << " = call float @llvm.fabs.f32(float " << val << ")" << endl;
                else
                    out << ws(level) << result << " = call double @llvm.fabs.f64(double " << val << ")" << endl;
            }
            else
            {
                // For integers, abs(x) = (x < 0) ? -x : x
                QByteArray cond = nextTemp();
                QByteArray neg = nextTemp();
                out << ws(level) << cond << " = icmp slt " << getLlvmIntType(t) << " " << val << ", 0" << endl;
                out << ws(level) << neg << " = sub " << getLlvmIntType(t) << " 0, " << val << endl;
                out << ws(level) << result << " = select i1 " << cond << ", " << getLlvmIntType(t) 
                    << " " << neg << ", " << getLlvmIntType(t) << " " << val << endl;
            }
        }
        break;

    case IL_not:
        {
            QByteArray val = expression(e->lhs, level+1);
            result = nextTemp();
            out << ws(level) << result << " = xor " << getLlvmIntType(e->getType()) 
                << " " << val << ", -1" << endl;
        }
        break;

    case IL_ldc_i4_0:
    case IL_ldc_i4_1:
    case IL_ldc_i4_2:
    case IL_ldc_i4_3:
    case IL_ldc_i4_4:
    case IL_ldc_i4_5:
    case IL_ldc_i4_6:
    case IL_ldc_i4_7:
    case IL_ldc_i4_8:
    case IL_ldc_i4_m1:
    case IL_ldc_i4_s:
    case IL_ldc_i4:
    case IL_ldc_i8:
        result = QByteArray::number(e->i);
        break;

    case IL_ldc_r4:
    case IL_ldc_r8:
        result = QByteArray::number(e->f,'e',16);
        break;

    case IL_ldnull:
        result = "null";
        break;

    case IL_ldstr:
        {
            // Create global string constant
            QByteArray str(e->c->s);
            int len = str.length() + 1;
            QByteArray name = "@.str." + QByteArray::number(tempCount++);
            // This would need to be declared as a global
            result = nextTemp();
            out << ws(level) << result << " = getelementptr [" << len << " x i8], [" 
                << len << " x i8]* " << name << ", i32 0, i32 0" << endl;
        }
        break;

    case IL_ldc_obj:
        // Load aggregate constant
        if( e->c )
            constValue(e->c, e->getType());
        result = "zeroinitializer";
        break;

    case IL_conv_i1:
    case IL_conv_i2:
    case IL_conv_i4:
    case IL_conv_u1:
    case IL_conv_u2:
    case IL_conv_u4:
    case IL_conv_i8:
    case IL_conv_u8:
    case IL_conv_r4:
    case IL_conv_r8:
        {
            QByteArray val = expression(e->lhs, level+1);
            Type* toType = Validator::tokToBasicType(mdl, e->kind);
            result = emitCast(val, e->lhs->getType(), toType);
        }
        break;

    case IL_ceq:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            Type* t = e->lhs->getType();
            if( deref(t)->isFloat() )
                out << ws(level) << result << " = fcmp oeq " << getLlvmFloatType(t) 
                    << " " << lhs << ", " << rhs << endl;
            else
                out << ws(level) << result << " = icmp eq " << getLlvmIntType(t) 
                    << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_cgt:
    case IL_cgt_un:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            Type* t = e->lhs->getType();
            if( deref(t)->isFloat() )
                out << ws(level) << result << " = fcmp ogt " << getLlvmFloatType(t) 
                    << " " << lhs << ", " << rhs << endl;
            else if( e->kind == IL_cgt_un )
                out << ws(level) << result << " = icmp ugt " << getLlvmIntType(t) 
                    << " " << lhs << ", " << rhs << endl;
            else
                out << ws(level) << result << " = icmp sgt " << getLlvmIntType(t) 
                    << " " << lhs << ", " << rhs << endl;
        }
        break;
        
    case IL_clt:
    case IL_clt_un:
        {
            QByteArray lhs = expression(e->lhs, level+1);
            QByteArray rhs = expression(e->rhs, level+1);
            result = nextTemp();
            Type* t = e->lhs->getType();
            if( deref(t)->isFloat() )
                out << ws(level) << result << " = fcmp olt " << getLlvmFloatType(t) 
                    << " " << lhs << ", " << rhs << endl;
            else if( e->kind == IL_clt_un )
                out << ws(level) << result << " = icmp ult " << getLlvmIntType(t) 
                    << " " << lhs << ", " << rhs << endl;
            else
                out << ws(level) << result << " = icmp slt " << getLlvmIntType(t) 
                    << " " << lhs << ", " << rhs << endl;
        }
        break;

    case IL_ldvar:
        result = emitLoad(e->d->getType(), mangle(qualident(e->d)));
        break;
        
    case IL_ldvara:
        result = mangle(qualident(e->d));
        break;

    case IL_ldarg_0:
    case IL_ldarg_1:
    case IL_ldarg_2:
    case IL_ldarg_3:
    case IL_ldarg_s:
    case IL_ldarg:
        {
            DeclList paramList = curProc->getParams();
            Q_ASSERT( e->id < paramList.size() );
            result = emitLoad(paramList[e->id]->getType(), params[paramList[e->id]]);
        }
        break;
        
    case IL_ldarga_s:
    case IL_ldarga:
        {
            DeclList paramList = curProc->getParams();
            Q_ASSERT( e->id < paramList.size() );
            result = params[paramList[e->id]];
        }
        break;

    case IL_ldloc_0:
    case IL_ldloc_1:
    case IL_ldloc_2:
    case IL_ldloc_3:
    case IL_ldloc_s:
    case IL_ldloc:
        {
            DeclList localList = curProc->getLocals();
            Q_ASSERT( e->id < localList.size() );
            result = emitLoad(localList[e->id]->getType(), locals[localList[e->id]]);
        }
        break;
        
    case IL_ldloca_s:
    case IL_ldloca:
        {
            DeclList localList = curProc->getLocals();
            Q_ASSERT( e->id < localList.size() );
            result = locals[localList[e->id]];
        }
        break;

    case IL_ldind_i1:
    case IL_ldind_i2:
    case IL_ldind_i4:
    case IL_ldind_i8:
    case IL_ldind_ip:
    case IL_ldind_ipp:
    case IL_ldind_r4:
    case IL_ldind_r8:
    case IL_ldind_u1:
    case IL_ldind_u2:
    case IL_ldind_u4:
    case IL_ldind_u8:
    case IL_ldind:
        {
            QByteArray ptr = expression(e->lhs, level+1);
            Type* t = e->lhs->getType();
            if( t && t->kind == Type::Pointer )
                t = t->getType();
            result = emitLoad(t, ptr);
        }
        break;

    case IL_ldelem_i1:
    case IL_ldelem_i2:
    case IL_ldelem_i4:
    case IL_ldelem_i8:
    case IL_ldelem_ip:
    case IL_ldelem_r4:
    case IL_ldelem_r8:
    case IL_ldelem_u1:
    case IL_ldelem_u2:
    case IL_ldelem_u4:
    case IL_ldelem_u8:
    case IL_ldelem:
        {
            QByteArray arr = expression(e->lhs, level+1);
            QByteArray idx = expression(e->rhs, level+1);
            
            Type* arrType = e->lhs->getType();
            Type* elemType = 0;
            if( arrType && arrType->kind == Type::Pointer )
                elemType = arrType->getType();
            else if( arrType && arrType->kind == Type::Array )
                elemType = arrType->getType();
                
            QByteArray ptr = nextTemp();
            out << ws(level) << ptr << " = getelementptr " << getLlvmType(elemType) 
                << ", " << getLlvmType(elemType) << "* " << arr << ", " 
                << getLlvmIntType(e->rhs->getType()) << " " << idx << endl;
            result = emitLoad(elemType, ptr);
        }
        break;
        
    case IL_ldelema:
        {
            QByteArray arr = expression(e->lhs, level+1);
            QByteArray idx = expression(e->rhs, level+1);
            
            Type* arrType = e->lhs->getType();
            Type* elemType = 0;
            if( arrType && arrType->kind == Type::Pointer )
                elemType = arrType->getType();
            else if( arrType && arrType->kind == Type::Array )
                elemType = arrType->getType();
                
            result = nextTemp();
            out << ws(level) << result << " = getelementptr " << getLlvmType(elemType) 
                << ", " << getLlvmType(elemType) << "* " << arr << ", " 
                << getLlvmIntType(e->rhs->getType()) << " " << idx << endl;
        }
        break;

    case IL_ldfld:
    case IL_ldflda:
        {
            QByteArray obj = expression(e->lhs, level+1);
            Type* objType = e->lhs->getType();
            if( objType && objType->kind == Type::Pointer )
                objType = objType->getType();
                
            // Find field index
            int fieldIdx = 0;
            if( objType && objType->kind == Type::Object )
            {
                fieldIdx = 1; // Skip vtable pointer
                QList<Declaration*> fields = objType->getFieldList(true);
                for( int i = 0; i < fields.size(); i++ )
                {
                    if( fields[i] == e->d )
                        break;
                    fieldIdx++;
                }
            }
            else if( objType )
            {
                foreach( Declaration* field, objType->subs )
                {
                    if( field->kind == Declaration::Field )
                    {
                        if( field == e->d )
                            break;
                        fieldIdx++;
                    }
                }
            }
            
            QByteArray ptr = nextTemp();
            out << ws(level) << ptr << " = getelementptr " << getLlvmType(objType) 
                << ", " << getLlvmType(objType) << "* " << obj << ", i32 0, i32 " 
                << fieldIdx << endl;
                
            if( e->kind == IL_ldfld )
                result = emitLoad(e->d->getType(), ptr);
            else
                result = ptr;
        }
        break;

    case IL_ldproc:
        result = mangle(qualident(e->d));
        break;

        // TODO: ld_iface
    case IL_ldmeth:
        {
            // Load method from vtable
            QByteArray obj = expression(e->lhs, level+1);
            Type* objType = e->lhs->getType();
            if( objType && objType->kind == Type::Pointer )
                objType = objType->getType();
                
            // Get vtable pointer
            QByteArray vtblPtr = nextTemp();
            out << ws(level) << vtblPtr << " = getelementptr " << getLlvmType(objType) 
                << ", " << getLlvmType(objType) << "* " << obj << ", i32 0, i32 0" << endl;
            QByteArray vtbl = emitLoad(mdl->getBasicType(Type::INTPTR), vtblPtr);
            
            // Find method index in vtable
            int methodIdx = 1; // Skip super pointer
            DeclList methods = objType->getMethodTable();
            for( int i = 0; i < methods.size(); i++ )
            {
                if( methods[i] == e->d )
                    break;
                methodIdx++;
            }
            
            // Load method pointer
            QByteArray methPtr = nextTemp();
            out << ws(level) << methPtr << " = getelementptr %" << qualident(objType->decl) 
                << ".vtbl, %" << qualident(objType->decl) << ".vtbl* " << vtbl 
                << ", i32 0, i32 " << methodIdx << endl;
            result = emitLoad(e->d->getType(), methPtr);
        }
        break;

    case IL_castptr:
        {
            QByteArray val = expression(e->lhs, level+1);
            result = nextTemp();
            out << ws(level) << result << " = bitcast " << getLlvmType(e->lhs->getType()) 
                << " " << val << " to " << getLlvmType(e->d->getType()) << endl;
        }
        break;

    case IL_call:
    case IL_callinst:
        result = emitCall(e, level);
        break;

    case IL_callvirt:
        {
            // Virtual method call
            QByteArray obj = expression(e->lhs, level+1);
            Type* objType = e->lhs->getType();
            if( objType && objType->kind == Type::Pointer )
                objType = objType->getType();
                
            // Get vtable and method pointer (similar to IL_ldmeth)
            QByteArray vtblPtr = nextTemp();
            out << ws(level) << vtblPtr << " = getelementptr " << getLlvmType(objType) 
                << ", " << getLlvmType(objType) << "* " << obj << ", i32 0, i32 0" << endl;
            QByteArray vtbl = emitLoad(mdl->getBasicType(Type::INTPTR), vtblPtr);
            
            int methodIdx = 1;
            DeclList methods = objType->getMethodTable();
            for( int i = 0; i < methods.size(); i++ )
            {
                if( methods[i] == e->d )
                    break;
                methodIdx++;
            }
            
            QByteArray methPtr = nextTemp();
            out << ws(level) << methPtr << " = getelementptr %" << qualident(objType->decl) 
                << ".vtbl, %" << qualident(objType->decl) << ".vtbl* " << vtbl 
                << ", i32 0, i32 " << methodIdx << endl;
            QByteArray meth = emitLoad(e->d->getType(), methPtr);
            
            // Call with self as first argument
            QList<Expression*> args;
            if( e->rhs && e->rhs->kind == Expression::Argument )
            {
                Expression* arg = e->rhs;
                while(arg)
                {
                    if( arg->lhs )
                        args << arg->lhs;
                    args << arg->rhs;
                    arg = arg->next;
                }
            }
            else if(e->rhs)
                args << e->rhs;
                
            result = nextTemp();
            Type* retType = e->d->getType();
            if( retType && retType->kind != Type::Any )
                out << ws(level) << result << " = ";
            else
                out << ws(level);
                
            out << "call " << getLlvmType(retType) << " " << meth << "(";
            out << getLlvmType(objType) << "* " << obj;
            for( int i = 0; i < args.size(); i++ )
            {
                out << ", ";
                QByteArray argVal = expression(args[i], level+1);
                out << getLlvmType(args[i]->getType()) << " " << argVal;
            }
            out << ")" << endl;
            
            if( !retType || retType->kind == Type::Any )
                result.clear();
        }
        break;

    case IL_calli:
    case IL_callmi:
        {
            // Indirect call
            QByteArray fptr = expression(e->lhs, level+1);
            
            QList<Expression*> args;
            if( e->rhs && e->rhs->kind == Expression::Argument )
            {
                Expression* arg = e->rhs;
                while(arg)
                {
                    if( arg->lhs )
                        args << arg->lhs;
                    args << arg->rhs;
                    arg = arg->next;
                }
            }
            else if(e->rhs)
                args << e->rhs;
                
            Type* funcType = e->lhs->getType();
            Type* retType = funcType ? funcType->getType() : 0;
            
            result = nextTemp();
            if( retType && retType->kind != Type::Any )
                out << ws(level) << result << " = ";
            else
                out << ws(level);
                
            out << "call " << getLlvmType(retType) << " " << fptr << "(";
            for( int i = 0; i < args.size(); i++ )
            {
                if( i > 0 )
                    out << ", ";
                QByteArray argVal = expression(args[i], level+1);
                out << getLlvmType(args[i]->getType()) << " " << argVal;
            }
            out << ")" << endl;
            
            if( !retType || retType->kind == Type::Any )
                result.clear();
        }
        break;

    case IL_newobj:
        {
            Type* t = e->d->getType();
            QByteArray size = QByteArray::number(t->getByteSize(8));
            QByteArray mem = nextTemp();
            
            out << ws(level) << mem << " = call i8* @calloc(i64 1, i64 " << size << ")" << endl;
            result = nextTemp();
            out << ws(level) << result << " = bitcast i8* " << mem << " to " 
                << getLlvmType(e->getType()) << endl;
                
            if( deref(t)->objectInit )
            {
                out << ws(level) << "call void " << mangle(qualident(t->decl)) 
                    << "$init(" << getLlvmType(t) << "* " << result << ", i32 1)" << endl;
            }
        }
        break;

    case IL_newarr:
        {
            QByteArray count = expression(e->lhs, level+1);
            Type* elemType = e->d->getType();
            QByteArray elemSize = QByteArray::number(elemType->getByteSize(8));
            
            QByteArray totalSize = nextTemp();
            out << ws(level) << totalSize << " = mul i64 " << count << ", " << elemSize << endl;
            
            QByteArray mem = nextTemp();
            out << ws(level) << mem << " = call i8* @calloc(i64 " << count << ", i64 " 
                << elemSize << ")" << endl;
                
            result = nextTemp();
            out << ws(level) << result << " = bitcast i8* " << mem << " to " 
                << getLlvmType(elemType) << "*" << endl;
                
            if( deref(elemType)->objectInit )
            {
                out << ws(level) << "call void " << mangle(qualident(elemType->decl)) 
                    << "$init(" << getLlvmType(elemType) << "* " << result << ", i32 " 
                    << count << ")" << endl;
            }
        }
        break;

    case IL_initobj:
        {
            QByteArray ptr = expression(e->lhs, level+1);
            Type* t = e->d->getType();
            
            // Zero initialize
            QByteArray cast = nextTemp();
            out << ws(level) << cast << " = bitcast " << getLlvmType(t) << "* " << ptr 
                << " to i8*" << endl;
            out << ws(level) << "call void @llvm.memset.p0i8.i64(i8* " << cast 
                << ", i8 0, i64 " << t->getByteSize(8) << ", i32 1, i1 false)" << endl;
                
            if( deref(t)->objectInit )
                emitSoapInit(ptr, t, level);
        }
        break;

    case IL_dup:
        result = expression(e->lhs, level+1);
        break;

    case IL_nop:
        break;

    case IL_ptroff:
        {
            QByteArray ptr = expression(e->lhs, level+1);
            QByteArray off = expression(e->rhs, level+1);
            Type* elemType = e->d->getType();
            
            result = nextTemp();
            out << ws(level) << result << " = getelementptr " << getLlvmType(elemType) 
                << ", " << getLlvmType(elemType) << "* " << ptr << ", " 
                << getLlvmIntType(e->rhs->getType()) << " " << off << endl;
        }
        break;

    case IL_iif:
        {
            Expression* if_ = e->e;
            Q_ASSERT(if_ && if_->kind == IL_if && if_->next->kind == IL_then && 
                     if_->next->next->kind == IL_else && if_->next->next->next == 0);
            Expression* then_ = if_->next;
            Expression* else_ = if_->next->next;
            
            QByteArray cond = expression(if_->lhs, level+1);
            QByteArray thenVal = expression(then_->lhs, level+1);
            QByteArray elseVal = expression(else_->lhs, level+1);
            
            result = nextTemp();
            out << ws(level) << result << " = select i1 " << cond << ", " 
                << getLlvmType(then_->lhs->getType()) << " " << thenVal << ", " 
                << getLlvmType(else_->lhs->getType()) << " " << elseVal << endl;
        }
        break;

    case IL_sizeof:
        result = QByteArray::number(e->d->getType()->getByteSize(8));
        break;

    default:
        Q_ASSERT(false);
    }
    
    return result;
}

QByteArray LlvmGen::emitCall(Expression* e, int level)
{
    QList<Expression*> args;
    if( e->rhs && e->rhs->kind == Expression::Argument )
    {
        Expression* arg = e->rhs;
        while(arg)
        {
            if( arg->lhs )
                args << arg->lhs;
            args << arg->rhs;
            arg = arg->next;
        }
    }
    else if(e->rhs)
        args << e->rhs;
        
    QByteArray result;
    Type* retType = e->d->getType();
    if( retType && retType->kind != Type::Any )
    {
        result = nextTemp();
        out << ws(level) << result << " = ";
    }
    else
        out << ws(level);
        
    out << "call " << getLlvmType(retType) << " " << mangle(qualident(e->d)) << "(";
    for( int i = 0; i < args.size(); i++ )
    {
        if( i > 0 )
            out << ", ";
        QByteArray argVal = expression(args[i], level+1);
        out << getLlvmType(args[i]->getType()) << " " << argVal;
    }
    out << ")" << endl;
    
    return result;
} 
