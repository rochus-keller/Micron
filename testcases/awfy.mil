// Generated by MicCompiler  on 2025-03-25T18:52:44

module Benchmark
  type $1 = pointer to Benchmark
  type $2 = proc(me: $1)
  type $3 = pointer to Benchmark
  type $4 = proc(me: $3):int32
  type $5 = pointer to Benchmark
  type $6 = proc(me: $5; result: int32):bool
  type $7 = pointer to Benchmark
  type $8 = proc(me: $7; innerIterations: int32):bool
  type Benchmark* = struct 
    dispose: $2
    benchmark: $4
    verifyResult: $6
    innerBenchmarkLoop: $8
  end
  type $9 = pointer to Benchmark
  procedure innerBenchmarkLoop(me: $9; innerIterations: int32):bool
  var i: int32; $10: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldarg_1
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldarg_0
        ldarg_0
        ldfld Benchmark.benchmark
        calli $4
        ldarg_0
        ldfld Benchmark.verifyResult
        calli $6
        ldc_i4_0
        ceq
      then
        ldc_i4_0
        ret
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldc_i4_1
    ret
  end innerBenchmarkLoop
end Benchmark

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Input
  type Available = proc():int32 extern 
  type $1 = pointer to char
  type Read = proc(ch: $1) extern 
  type $2 = pointer to uint32
  type $3 = pointer to int32
  type Mouse = proc(keys: $2; x: $3; y: $3) extern 
  type SetMouseLimits = proc(w: int32; h: int32) extern 
  type Time = proc():int32 extern 
end Input

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Out
  type Open = proc() extern 
  type Char = proc(ch: char) extern 
  type $1 = array of char
  type $2 = pointer to $1
  type String = proc(str: $2) extern 
  type Int = proc(i: int64; n: int32) extern 
  type Real = proc(x: float32; n: int32) extern 
  type LongReal = proc(x: float64; n: int32) extern 
  type Ln = proc() extern 
end Out

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Random
  var seed: uint32
  procedure reset()
  begin
    ldvara seed
    ldc_i4 74755
    stind_i4
  end reset
  procedure next():uint32
  begin
    ldvara seed
    ldvar seed
    ldc_i4 1309
    mul
    ldc_i4 13849
    add
    ldc_i4 65535
    and
    stind_i4
    ldvar seed
    ret
  end next
  procedure $begin() init 
  begin
    ldvara seed
    ldc_i4 74755
    stind_i4
  end $begin
end Random

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Bounce
  import Random
  import Benchmark
  type Ball = struct 
    x: int32
    y: int32
    xVel: int32
    yVel: int32
  end
  type $1 = pointer to Ball
  procedure Ball_init(me: $1)
  begin
    ldarg_0
    ldflda Ball.x
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Ball.y
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Ball.xVel
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Ball.yVel
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Ball.x
    call Random!next
    ldc_i4 500
    rem_un
    conv_i4
    stind_i4
    ldarg_0
    ldflda Ball.y
    call Random!next
    ldc_i4 500
    rem_un
    conv_i4
    stind_i4
    ldarg_0
    ldflda Ball.xVel
    call Random!next
    ldc_i4 300
    rem_un
    conv_i4
    ldc_i4 150
    sub
    stind_i4
    ldarg_0
    ldflda Ball.yVel
    call Random!next
    ldc_i4 300
    rem_un
    conv_i4
    ldc_i4 150
    sub
    stind_i4
  end Ball_init
  type $2 = pointer to Ball
  procedure Ball_bounce(me: $2):bool
  var bounced: bool; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda Ball.x
    ldarg_0
    ldfld Ball.x
    ldarg_0
    ldfld Ball.xVel
    add
    stind_i4
    ldarg_0
    ldflda Ball.y
    ldarg_0
    ldfld Ball.y
    ldarg_0
    ldfld Ball.yVel
    add
    stind_i4
    if
      ldarg_0
      ldfld Ball.x
      ldc_i4 500
      cgt
    then
      ldarg_0
      ldflda Ball.x
      ldc_i4 500
      stind_i4
      ldarg_0
      ldflda Ball.xVel
      ldc_i4_0
      ldarg_0
      ldfld Ball.xVel
      dup
      ldc_i4_0
      cgt
      ifgoto $ABS0
      neg
      label $ABS0
      sub
      stind_i4
      ldloca_s 0
      ldc_i4_1
      stind_i1
    end
    if
      ldarg_0
      ldfld Ball.x
      ldc_i4_0
      clt
    then
      ldarg_0
      ldflda Ball.x
      ldc_i4_0
      stind_i4
      ldarg_0
      ldflda Ball.xVel
      ldarg_0
      ldfld Ball.xVel
      dup
      ldc_i4_0
      cgt
      ifgoto $ABS1
      neg
      label $ABS1
      stind_i4
      ldloca_s 0
      ldc_i4_1
      stind_i1
    end
    if
      ldarg_0
      ldfld Ball.y
      ldc_i4 500
      cgt
    then
      ldarg_0
      ldflda Ball.y
      ldc_i4 500
      stind_i4
      ldarg_0
      ldflda Ball.yVel
      ldc_i4_0
      ldarg_0
      ldfld Ball.yVel
      dup
      ldc_i4_0
      cgt
      ifgoto $ABS2
      neg
      label $ABS2
      sub
      stind_i4
      ldloca_s 0
      ldc_i4_1
      stind_i1
    end
    if
      ldarg_0
      ldfld Ball.y
      ldc_i4_0
      clt
    then
      ldarg_0
      ldflda Ball.y
      ldc_i4_0
      stind_i4
      ldarg_0
      ldflda Ball.yVel
      ldarg_0
      ldfld Ball.yVel
      dup
      ldc_i4_0
      cgt
      ifgoto $ABS3
      neg
      label $ABS3
      stind_i4
      ldloca_s 0
      ldc_i4_1
      stind_i1
    end
    ldloc_0
    ret
  end Ball_bounce
  type $3 = pointer to Benchmark!Benchmark
  type $4 = array of Ball
  type $5 = pointer to $4
  type $7 = pointer to Ball
  type $10 = pointer to Ball
  procedure benchmark(me: $3):int32
  var bounces: int32; i: int32; j: int32; balls: $5; $6: int32; $8: int32; $9: int32; 
  begin
    call Random!reset
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4_s 100
    newarr Ball
    stind_ip
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 4
    ldc_i4_s 99
    stind_i4
    while
      ldloc_1
      ldloc_s 4
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_3
      ldloc_1
      ldelema Ball
      call Ball_init
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 5
    ldc_i4_s 49
    stind_i4
    while
      ldloc_1
      ldloc_s 5
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 2
      ldc_i4_0
      stind_i4
      ldloca_s 6
      ldc_i4_s 99
      stind_i4
      while
        ldloc_2
        ldloc_s 6
        cgt
        ldc_i4_0
        ceq
      do
        if
          ldloc_3
          ldloc_2
          ldelema Ball
          call Ball_bounce
        then
          ldloca_s 0
          dup
          ldind_i4
          ldc_i4_1
          add
          stind_i4
        end
        ldloca_s 2
        ldloc_2
        ldc_i4_1
        add
        stind_i4
      end
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_3
    free
    ldloc_0
    ret
  end benchmark
  type $11 = pointer to Benchmark!Benchmark
  procedure verifyResult(bench: $11; result: int32):bool
  begin
    ldc_i4 1331
    ldarg_1
    ceq
    ret
  end verifyResult
  type $12 = pointer to Benchmark!Benchmark
  type $13 = pointer to Benchmark!Benchmark
  procedure create():$12
  var bench: $13; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Bounce

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Mandelbrot
  import Out
  import Benchmark
  procedure verifyResult2(result: int32; innerIterations: int32):bool
  begin
    if
      ldarg_1
      ldc_i4 500
      ceq
    then
      ldarg_0
      ldc_i4 191
      ceq
      ret
    end
    if
      ldarg_1
      ldc_i4 750
      ceq
    then
      ldarg_0
      ldc_i4_s 50
      ceq
      ret
    end
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      ldarg_0
      ldc_i4 128
      ceq
      ret
    end
    ldstr "No verification result for "
    call Out!String
    ldarg_1
    ldc_i4_0
    call Out!Int
    ldstr " found"
    call Out!String
    call Out!Ln
    ldstr "Result is: "
    call Out!String
    ldarg_0
    ldc_i4_0
    call Out!Int
    call Out!Ln
    ldc_i4_0
    ret
  end verifyResult2
  procedure mandelbrot(size: int32):int32
  var sum: int32; byteAcc: int32; bitNum: int32; y: int32; z: int32; x: int32; escape: int32; ci: float64; zr: float64; zrzr: float64; zi: float64; zizi: float64; cr: float64; notDone: bool; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4_0
    stind_i4
    while
      ldloc_3
      ldarg_0
      clt
    do
      ldloca_s 7
      ldc_r4 2
      ldloc_3
      ldarg_0
      div
      conv_r4
      mul
      ldc_r4 1
      sub
      conv_r8
      stind_r8
      ldloca_s 5
      ldc_i4_0
      stind_i4
      while
        ldloc_s 5
        ldarg_0
        clt
      do
        ldloca_s 8
        ldc_r4 0
        conv_r8
        stind_r8
        ldloca_s 9
        ldc_r4 0
        conv_r8
        stind_r8
        ldloca_s 10
        ldc_r4 0
        conv_r8
        stind_r8
        ldloca_s 11
        ldc_r4 0
        conv_r8
        stind_r8
        ldloca_s 12
        ldc_r4 2
        ldloc_s 5
        ldarg_0
        div
        conv_r4
        mul
        ldc_r4 1.5
        sub
        conv_r8
        stind_r8
        ldloca_s 4
        ldc_i4_0
        stind_i4
        ldloca_s 13
        ldc_i4_1
        stind_i1
        ldloca_s 6
        ldc_i4_0
        stind_i4
        while
          iif
            ldloc_s 13
          then
            ldloc_s 4
            ldc_i4_s 50
            clt
          else
            ldc_i4_0
          end
        do
          ldloca_s 8
          ldloc_s 9
          ldloc_s 11
          sub
          ldloc_s 12
          add
          stind_r8
          ldloca_s 10
          ldc_r8 2
          ldloc_s 8
          mul
          ldloc_s 10
          mul
          ldloc_s 7
          add
          stind_r8
          ldloca_s 9
          ldloc_s 8
          ldloc_s 8
          mul
          stind_r8
          ldloca_s 11
          ldloc_s 10
          ldloc_s 10
          mul
          stind_r8
          if
            ldloc_s 9
            ldloc_s 11
            add
            ldc_r8 4
            cgt
          then
            ldloca_s 13
            ldc_i4_0
            stind_i1
            ldloca_s 6
            ldc_i4_1
            stind_i4
          end
          ldloca_s 4
          dup
          ldind_i4
          ldc_i4_1
          add
          stind_i4
        end
        ldloca_s 1
        ldloc_1
        conv_u4
        ldc_i4_1
        shl
        conv_i4
        ldloc_s 6
        add
        stind_i4
        ldloca_s 2
        dup
        ldind_i4
        ldc_i4_1
        add
        stind_i4
        if
          ldloc_2
          ldc_i4_8
          ceq
        then
          ldloca_s 0
          ldloc_0
          conv_u4
          ldloc_1
          conv_u4
          xor
          conv_i4
          stind_i4
          ldloca_s 1
          ldc_i4_0
          stind_i4
          ldloca_s 2
          ldc_i4_0
          stind_i4
        else
          if
            ldloc_s 5
            ldarg_0
            ldc_i4_1
            sub
            ceq
          then
            ldloca_s 1
            ldloc_1
            conv_u4
            ldc_i4_8
            ldloc_2
            sub
            conv_u4
            shl
            conv_i4
            stind_i4
            ldloca_s 0
            ldloc_0
            conv_u4
            ldloc_1
            conv_u4
            xor
            conv_i4
            stind_i4
            ldloca_s 1
            ldc_i4_0
            stind_i4
            ldloca_s 2
            ldc_i4_0
            stind_i4
          end
        end
        ldloca_s 5
        dup
        ldind_i4
        ldc_i4_1
        add
        stind_i4
      end
      ldloca_s 3
      dup
      ldind_i4
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end mandelbrot
  type $1 = pointer to Benchmark!Benchmark
  procedure innerBenchmarkLoop(bench: $1; innerIterations: int32):bool
  begin
    ldarg_1
    call mandelbrot
    ldarg_1
    call verifyResult2
    ret
  end innerBenchmarkLoop
  type $2 = pointer to Benchmark!Benchmark
  procedure benchmark(bench: $2):int32
  begin
    ldc_i4_0
    ldc_i4 134
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Mandelbrot.mic"
    call $MIC!assert
  end benchmark
  type $3 = pointer to Benchmark!Benchmark
  procedure verifyResult(bench: $3; result: int32):bool
  begin
    ldc_i4_0
    ldc_i4 139
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Mandelbrot.mic"
    call $MIC!assert
  end verifyResult
  type $4 = pointer to Benchmark!Benchmark
  type $5 = pointer to Benchmark!Benchmark
  procedure create():$4
  var bench: $5; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldproc innerBenchmarkLoop
    stind_ip
    ldloc_0
    ret
  end create
end Mandelbrot

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Permute
  import Benchmark
  type $1 = array of int32
  type $2 = pointer to $1
  type Permute = struct 
    base: Benchmark!Benchmark
    count: int32
    v: $2
  end
  type $3 = pointer to Permute
  procedure swap(me: $3; i: int32; j: int32)
  var tmp: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld Permute.v
    ldarg_1
    ldelem_i4
    stind_i4
    ldarg_0
    ldfld Permute.v
    ldarg_1
    ldelema int32
    ldarg_0
    ldfld Permute.v
    ldarg_2
    ldelem_i4
    stind_i4
    ldarg_0
    ldfld Permute.v
    ldarg_2
    ldelema int32
    ldloc_0
    stind_i4
  end swap
  type $4 = pointer to Permute
  procedure permute(me: $4; n: int32)
  var n1: int32; i: int32; $5: int32; 
  begin
    ldarg_0
    ldflda Permute.count
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    if
      ldarg_1
      ldc_i4_0
      ceq
      ldc_i4_0
      ceq
    then
      ldloca_s 0
      ldarg_1
      ldc_i4_1
      sub
      stind_i4
      ldarg_0
      ldloc_0
      call permute
      ldloca_s 1
      ldloc_0
      stind_i4
      ldloca_s 2
      ldc_i4_0
      stind_i4
      while
        ldloc_1
        ldloc_2
        clt
        ldc_i4_0
        ceq
      do
        ldarg_0
        ldloc_0
        ldloc_1
        call swap
        ldarg_0
        ldloc_0
        call permute
        ldarg_0
        ldloc_0
        ldloc_1
        call swap
        ldloca_s 1
        ldloc_1
        ldc_i4_m1
        add
        stind_i4
      end
    end
  end permute
  type $6 = pointer to Benchmark!Benchmark
  type $7 = pointer to Permute
  type $8 = pointer to Permute
  procedure benchmark(me: $6):int32
  var p: $7; i: int32; 
  begin
    ldloca_s 0
    ldarg_0
    castptr Permute
    stind_ip
    ldloc_0
    ldflda Permute.count
    ldc_i4_0
    stind_i4
    ldloc_0
    ldflda Permute.v
    ldc_i4_6
    newarr int32
    stind_ip
    ldloc_0
    ldc_i4_6
    call permute
    ldloc_0
    ldfld Permute.v
    free
    ldloc_0
    ldfld Permute.count
    ret
  end benchmark
  type $9 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: $9; result: int32):bool
  begin
    ldarg_1
    ldc_i4 8660
    ceq
    ret
  end verifyResult
  type $10 = pointer to Benchmark!Benchmark
  type $11 = pointer to Permute
  procedure create():$10
  var per: $11; 
  begin
    ldloca_s 0
    newobj Permute
    stind_ip
    ldloc_0
    ldflda Permute.base
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Permute.base
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Permute.base
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Permute.base
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Permute

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Object
  type $1 = pointer to Object
  type $2 = proc(obj: $1)
  type Object* = struct 
    deinit: $2
    refCount: int32
  end
  type $3 = pointer to Object
  type $4 = pointer to Object
  type $5 = proc(obj: $4)
  procedure init(obj: $3; deinitProc: $5)
  begin
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldflda Object.deinit
      ldarg_1
      stind_ip
      ldarg_0
      ldflda Object.refCount
      ldc_i4_0
      stind_i4
    end
  end init
  type $6 = pointer to Object
  procedure addRef(obj: $6)
  begin
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldflda Object.refCount
      dup
      ldind_i4
      ldc_i4_1
      add
      stind_i4
    end
  end addRef
  type $7 = pointer to Object
  procedure release(obj: $7)
  begin
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldflda Object.refCount
      dup
      ldind_i4
      ldc_i4_1
      sub
      stind_i4
      if
        ldarg_0
        ldfld Object.refCount
        ldc_i4_0
        ceq
      then
        if
          ldarg_0
          ldfld Object.deinit
          ldnull
          ceq
          ldc_i4_0
          ceq
        then
          ldarg_0
          ldarg_0
          ldfld Object.deinit
          calli $2
        end
        ldarg_0
        free
      end
    end
  end release
end Object

// Generated by MicCompiler  on 2025-03-25T18:52:44

module List
  import Object
  import Benchmark
  type $1 = pointer to Element
  type Element = struct 
    base: Object!Object
    val: int32
    next: $1
  end
  type $2 = pointer to Element
  type $3 = pointer to Element
  procedure Element_setNext(me: $2; e: $3)
  begin
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldfld Element.next
      call Object!release
    end
    ldarg_0
    ldflda Element.next
    ldarg_1
    stind_ip
  end Element_setNext
  type $4 = pointer to Object!Object
  type $5 = pointer to Element
  type $6 = pointer to Element
  procedure Element_deinit(me: $4)
  var elem: $5; 
  begin
    ldloca_s 0
    ldarg_0
    castptr Element
    stind_ip
    ldloc_0
    ldnull
    call Element_setNext
  end Element_deinit
  type $7 = pointer to Element
  type $8 = pointer to Element
  type $9 = pointer to Object!Object
  type $10 = pointer to Object!Object
  procedure Element_create(v: int32):$7
  var e: $8; 
  begin
    ldloca_s 0
    newobj Element
    stind_ip
    ldloc_0
    ldflda Element.base
    ldproc Element_deinit
    call Object!init
    ldloc_0
    ldflda Element.base
    call Object!addRef
    ldloc_0
    ldflda Element.val
    ldarg_0
    stind_i4
    ldloc_0
    ldflda Element.next
    ldnull
    stind_ip
    ldloc_0
    ret
  end Element_create
  type $11 = pointer to Element
  procedure Element_length(me: $11):int32
  begin
    if
      ldarg_0
      ldfld Element.next
      ldnull
      ceq
    then
      ldc_i4_1
      ret
    else
      ldc_i4_1
      ldarg_0
      ldfld Element.next
      call Element_length
      add
      ret
    end
  end Element_length
  type $12 = pointer to Element
  type $13 = pointer to Element
  procedure Element_getNext(me: $12):$13
  begin
    ldarg_0
    ldfld Element.next
    ret
  end Element_getNext
  type $14 = pointer to Element
  procedure Element_setVal(me: $14; v: int32)
  begin
    ldarg_0
    ldflda Element.val
    ldarg_1
    stind_i4
  end Element_setVal
  type $15 = pointer to Element
  procedure Element_getVal(me: $15):int32
  begin
    ldarg_0
    ldfld Element.val
    ret
  end Element_getVal
  type $16 = pointer to Element
  type $17 = pointer to Element
  procedure makeList(length: int32):$16
  var e: $17; 
  begin
    if
      ldarg_0
      ldc_i4_0
      ceq
    then
      ldnull
      ret
    else
      ldloca_s 0
      ldarg_0
      call Element_create
      stind_ip
      ldloc_0
      ldarg_0
      ldc_i4_1
      sub
      call makeList
      call Element_setNext
      ldloc_0
      ret
    end
  end makeList
  type $18 = pointer to Element
  type $19 = pointer to Element
  procedure isShorterThan(x: $18; y: $18):bool
  var xTail: $19; yTail: $19; 
  begin
    ldloca_s 0
    ldarg_0
    stind_ip
    ldloca_s 1
    ldarg_1
    stind_ip
    while
      ldloc_1
      ldnull
      ceq
      ldc_i4_0
      ceq
    do
      if
        ldloc_0
        ldnull
        ceq
      then
        ldc_i4_1
        ret
      end
      ldloca_s 0
      ldloc_0
      call Element_getNext
      stind_ip
      ldloca_s 1
      ldloc_1
      call Element_getNext
      stind_ip
    end
    ldc_i4_0
    ret
  end isShorterThan
  type $20 = pointer to Element
  type $21 = pointer to Element
  type $22 = pointer to Element
  type $23 = pointer to Object!Object
  type $24 = pointer to Object!Object
  type $25 = pointer to Object!Object
  type $26 = pointer to Object!Object
  procedure tail(x: $20; y: $20; z: $20):$21
  var xx: $22; yy: $22; zz: $22; res: $22; 
  begin
    if
      ldarg_1
      ldarg_0
      call isShorterThan
    then
      ldloca_s 0
      ldarg_0
      call Element_getNext
      ldarg_1
      ldarg_2
      call tail
      stind_ip
      ldloca_s 1
      ldarg_1
      call Element_getNext
      ldarg_2
      ldarg_0
      call tail
      stind_ip
      ldloca_s 2
      ldarg_2
      call Element_getNext
      ldarg_0
      ldarg_1
      call tail
      stind_ip
      ldloca_s 3
      ldloc_0
      ldloc_1
      ldloc_2
      call tail
      stind_ip
      ldloc_0
      ldflda Element.base
      call Object!release
      ldloc_1
      ldflda Element.base
      call Object!release
      ldloc_2
      ldflda Element.base
      call Object!release
    else
      ldloca_s 3
      ldarg_2
      stind_ip
      ldarg_2
      ldflda Element.base
      call Object!addRef
    end
    ldloc_3
    ret
  end tail
  type $27 = pointer to Benchmark!Benchmark
  type $28 = pointer to Element
  type $29 = pointer to Object!Object
  type $30 = pointer to Object!Object
  type $31 = pointer to Object!Object
  type $32 = pointer to Object!Object
  procedure benchmark(bench: $27):int32
  var x: $28; y: $28; z: $28; resultElem: $28; res: int32; 
  begin
    ldloca_s 0
    ldc_i4_s 15
    call makeList
    stind_ip
    ldloca_s 1
    ldc_i4_s 10
    call makeList
    stind_ip
    ldloca_s 2
    ldc_i4_6
    call makeList
    stind_ip
    ldloca_s 3
    ldloc_0
    ldloc_1
    ldloc_2
    call tail
    stind_ip
    ldloca_s 4
    ldloc_3
    call Element_length
    stind_i4
    ldloc_3
    ldflda Element.base
    call Object!release
    ldloc_0
    ldflda Element.base
    call Object!release
    ldloc_1
    ldflda Element.base
    call Object!release
    ldloc_2
    ldflda Element.base
    call Object!release
    ldloc_s 4
    ret
  end benchmark
  type $33 = pointer to Benchmark!Benchmark
  procedure verifyResult(bench: $33; result: int32):bool
  begin
    ldc_i4_s 10
    ldarg_1
    ceq
    ret
  end verifyResult
  type $34 = pointer to Benchmark!Benchmark
  type $35 = pointer to Benchmark!Benchmark
  procedure create():$34
  var bench: $35; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end List

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Queens
  import Benchmark
  type $1 = array of bool
  type BoolArray = pointer to $1
  type $2 = array of int32
  type IntArray = pointer to $2
  type Queens = struct 
    base: Benchmark!Benchmark
    freeMaxs: BoolArray
    freeRows: BoolArray
    freeMins: BoolArray
    queenRows: IntArray
  end
  type $3 = pointer to Queens
  procedure getRowColumn(me: $3; r: int32; c: int32):bool
  begin
    iif
      iif
        ldarg_0
        ldfld Queens.freeRows
        ldarg_1
        ldelem bool
      then
        ldarg_0
        ldfld Queens.freeMaxs
        ldarg_2
        ldarg_1
        add
        ldelem bool
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld Queens.freeMins
      ldarg_2
      ldarg_1
      sub
      ldc_i4_7
      add
      ldelem bool
    else
      ldc_i4_0
    end
    ret
  end getRowColumn
  type $4 = pointer to Queens
  procedure setRowColumn(me: $4; r: int32; c: int32; v: bool)
  begin
    ldarg_0
    ldfld Queens.freeRows
    ldarg_1
    ldelema bool
    ldarg_3
    stind_i1
    ldarg_0
    ldfld Queens.freeMaxs
    ldarg_2
    ldarg_1
    add
    ldelema bool
    ldarg_3
    stind_i1
    ldarg_0
    ldfld Queens.freeMins
    ldarg_2
    ldarg_1
    sub
    ldc_i4_7
    add
    ldelema bool
    ldarg_3
    stind_i1
  end setRowColumn
  type $5 = pointer to Queens
  procedure placeQueen(me: $5; c: int32):bool
  var r: int32; $6: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_7
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldloc_0
        ldarg_1
        call getRowColumn
      then
        ldarg_0
        ldfld Queens.queenRows
        ldloc_0
        ldelema int32
        ldarg_1
        stind_i4
        ldarg_0
        ldloc_0
        ldarg_1
        ldc_i4_0
        call setRowColumn
        if
          ldarg_1
          ldc_i4_7
          ceq
        then
          ldc_i4_1
          ret
        end
        if
          ldarg_0
          ldarg_1
          ldc_i4_1
          add
          call placeQueen
        then
          ldc_i4_1
          ret
        end
        ldarg_0
        ldloc_0
        ldarg_1
        ldc_i4_1
        call setRowColumn
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldc_i4_0
    ret
  end placeQueen
  type $7 = pointer to Queens
  procedure queens(me: $7):bool
  var i: int32; res: bool; $8: int32; $9: int32; 
  begin
    ldarg_0
    ldflda Queens.freeRows
    ldc_i4_8
    newarr bool
    stind_ip
    ldarg_0
    ldflda Queens.freeMaxs
    ldc_i4_s 16
    newarr bool
    stind_ip
    ldarg_0
    ldflda Queens.freeMins
    ldc_i4_s 16
    newarr bool
    stind_ip
    ldarg_0
    ldflda Queens.queenRows
    ldc_i4_8
    newarr int32
    stind_ip
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_7
    stind_i4
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldfld Queens.freeRows
      ldloc_0
      ldelema bool
      ldc_i4_1
      stind_i1
      ldarg_0
      ldfld Queens.queenRows
      ldloc_0
      ldelema int32
      ldc_i4_m1
      stind_i4
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4_s 15
    stind_i4
    while
      ldloc_0
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldfld Queens.freeMaxs
      ldloc_0
      ldelema bool
      ldc_i4_1
      stind_i1
      ldarg_0
      ldfld Queens.freeMins
      ldloc_0
      ldelema bool
      ldc_i4_1
      stind_i1
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 1
    ldarg_0
    ldc_i4_0
    call placeQueen
    stind_i1
    ldarg_0
    ldfld Queens.freeRows
    free
    ldarg_0
    ldfld Queens.freeMaxs
    free
    ldarg_0
    ldfld Queens.freeMins
    free
    ldarg_0
    ldfld Queens.queenRows
    free
    ldloc_1
    ret
  end queens
  type $10 = pointer to Benchmark!Benchmark
  type $12 = pointer to Queens
  procedure benchmark(me: $10):int32
  var i: int32; resultBool: bool; $11: int32; 
  begin
    ldloca_s 1
    ldc_i4_1
    stind_i1
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_s 9
    stind_i4
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 1
      iif
        ldloc_1
      then
        ldarg_0
        castptr Queens
        call queens
      else
        ldc_i4_0
      end
      stind_i1
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    if
      ldloc_1
    then
      ldc_i4_1
      ret
    else
      ldc_i4_0
      ret
    end
  end benchmark
  type $13 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: $13; result: int32):bool
  begin
    ldarg_1
    ldc_i4_0
    ceq
    ldc_i4_0
    ceq
    ret
  end verifyResult
  type $14 = pointer to Queens
  type $15 = pointer to Queens
  procedure create():$14
  var q: $15; 
  begin
    ldloca_s 0
    newobj Queens
    stind_ip
    ldloc_0
    ldflda Queens.base
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Queens.base
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Queens.base
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Queens.base
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Queens

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Sieve
  import Benchmark
  type $1 = array of bool
  type $2 = pointer to $1
  procedure sieve(flags: $2; size: int32):int32
  var primeCount: int32; i: int32; k: int32; $3: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_2
    stind_i4
    ldloca_s 3
    ldarg_1
    stind_i4
    while
      ldloc_1
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldloc_1
        ldc_i4_1
        sub
        ldelem bool
      then
        ldloca_s 0
        dup
        ldind_i4
        ldc_i4_1
        add
        stind_i4
        ldloca_s 2
        ldloc_1
        ldloc_1
        add
        stind_i4
        while
          ldloc_2
          ldarg_1
          cgt
          ldc_i4_0
          ceq
        do
          ldarg_0
          ldloc_2
          ldc_i4_1
          sub
          ldelema bool
          ldc_i4_0
          stind_i1
          ldloca_s 2
          ldloc_2
          ldloc_1
          add
          stind_i4
        end
      end
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end sieve
  type $4 = pointer to Benchmark!Benchmark
  type $5 = array of bool
  type $6 = pointer to $5
  procedure benchmark(me: $4):int32
  var i: int32; res: int32; flags: $6; $7: int32; 
  begin
    ldloca_s 2
    ldc_i4 5000
    newarr bool
    stind_ip
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4 4999
    stind_i4
    while
      ldloc_0
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_2
      ldloc_0
      ldelema bool
      ldc_i4_1
      stind_i1
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 1
    ldloc_2
    ldc_i4 5000
    call sieve
    stind_i4
    ldloc_2
    free
    ldloc_1
    ret
  end benchmark
  type $8 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: $8; result: int32):bool
  begin
    ldc_i4 669
    ldarg_1
    ceq
    ret
  end verifyResult
  type $9 = pointer to Benchmark!Benchmark
  type $10 = pointer to Benchmark!Benchmark
  procedure create():$9
  var bench: $10; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Sieve

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Storage
  import Random
  import Benchmark
  type Storage = struct 
    base: Benchmark!Benchmark
    count: int32
  end
  type $1 = array of TreeArray
  type $2 = pointer to $1
  type TreeArray = struct 
    arr: $2
    len: uint32
  end
  type $3 = pointer to TreeArray
  type $5 = pointer to TreeArray
  procedure freeTree(ta: $3)
  var i: int32; t: TreeArray; $4: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldarg_0
    ldfld TreeArray.len
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 1
      ldarg_0
      ldfld TreeArray.arr
      ldloc_0
      ldelem TreeArray
      stind TreeArray
      ldloca_s 1
      call freeTree
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    if
      ldarg_0
      ldfld TreeArray.arr
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldfld TreeArray.arr
      free
    end
    ldarg_0
    ldflda TreeArray.len
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda TreeArray.arr
    ldnull
    stind_ip
  end freeTree
  type $6 = pointer to Storage
  procedure buildTreeDepth(me: $6; depth: int32):TreeArray
  var res: TreeArray; i: int32; $7: int32; 
  begin
    ldarg_0
    ldflda Storage.count
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      ldloca_s 0
      ldflda TreeArray.len
      call Random!next
      ldc_i4_s 10
      rem_un
      ldc_i4_1
      add
      stind_i4
      ldloca_s 0
      ldflda TreeArray.arr
      ldloca_s 0
      ldfld TreeArray.len
      newarr TreeArray
      stind_ip
      ldloc_0
      ret
    else
      ldloca_s 0
      ldflda TreeArray.len
      ldc_i4_4
      stind_i4
      ldloca_s 0
      ldflda TreeArray.arr
      ldloca_s 0
      ldfld TreeArray.len
      newarr TreeArray
      stind_ip
      ldloca_s 1
      ldc_i4_0
      stind_i4
      ldloca_s 2
      ldloca_s 0
      ldfld TreeArray.len
      ldc_i4_1
      sub
      stind_i4
      while
        ldloc_1
        ldloc_2
        cgt
        ldc_i4_0
        ceq
      do
        ldloca_s 0
        ldfld TreeArray.arr
        ldloc_1
        ldelema TreeArray
        ldarg_0
        ldarg_1
        ldc_i4_1
        sub
        call buildTreeDepth
        stind TreeArray
        ldloca_s 1
        ldloc_1
        ldc_i4_1
        add
        stind_i4
      end
      ldloc_0
      ret
    end
  end buildTreeDepth
  type $8 = pointer to Benchmark!Benchmark
  type $9 = pointer to Storage
  type $10 = pointer to Storage
  type $11 = pointer to TreeArray
  procedure benchmark(me: $8):int32
  var s: $9; arr: TreeArray; 
  begin
    ldloca_s 0
    ldarg_0
    castptr Storage
    stind_ip
    call Random!reset
    ldloc_0
    ldflda Storage.count
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldloc_0
    ldc_i4_7
    call buildTreeDepth
    stind TreeArray
    ldloca_s 1
    call freeTree
    ldloc_0
    ldfld Storage.count
    ret
  end benchmark
  type $12 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: $12; result: int32):bool
  begin
    ldc_i4 5461
    ldarg_1
    ceq
    ret
  end verifyResult
  type $13 = pointer to Benchmark!Benchmark
  type $14 = pointer to Storage
  procedure create():$13
  var s: $14; 
  begin
    ldloca_s 0
    newobj Storage
    stind_ip
    ldloc_0
    ldflda Storage.base
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Storage.base
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Storage.base
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Storage.base
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Storage

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Towers
  import Benchmark
  type $1 = pointer to TowersDisk
  type TowersDisk = struct 
    size: int32
    next: $1
  end
  type $2 = pointer to TowersDisk
  type $3 = array 3 of $2
  type Towers = struct 
    base: Benchmark!Benchmark
    piles: $3
    movesDone: int32
  end
  type $4 = pointer to TowersDisk
  procedure TowersDisk_dispose(me: $4)
  begin
    if
      ldarg_0
      ldfld TowersDisk.next
    then
      ldarg_0
      ldfld TowersDisk.next
      call TowersDisk_dispose
    end
    ldarg_0
    free
  end TowersDisk_dispose
  type $5 = pointer to TowersDisk
  type $6 = pointer to TowersDisk
  procedure TowersDisk_create(size: int32):$5
  var d: $6; 
  begin
    ldloca_s 0
    newobj TowersDisk
    stind_ip
    ldloc_0
    ldflda TowersDisk.next
    ldnull
    stind_ip
    ldloc_0
    ldflda TowersDisk.size
    ldarg_0
    stind_i4
    ldloc_0
    ret
  end TowersDisk_create
  type $7 = pointer to TowersDisk
  procedure TowersDisk_getSize(me: $7):int32
  begin
    ldarg_0
    ldfld TowersDisk.size
    ret
  end TowersDisk_getSize
  type $8 = pointer to TowersDisk
  type $9 = pointer to TowersDisk
  procedure TowersDisk_getNext(me: $8):$9
  begin
    ldarg_0
    ldfld TowersDisk.next
    ret
  end TowersDisk_getNext
  type $10 = pointer to TowersDisk
  procedure TowersDisk_setNext(me: $10; value: $10)
  begin
    ldarg_0
    ldflda TowersDisk.next
    ldarg_1
    stind_ip
  end TowersDisk_setNext
  type $11 = pointer to Towers
  type $12 = pointer to TowersDisk
  type $13 = pointer to TowersDisk
  procedure pushDisk(me: $11; disk: $12; pile: int32)
  var top: $13; 
  begin
    ldloca_s 0
    ldarg_0
    ldflda Towers.piles
    ldarg_2
    ldelem $2
    stind_ip
    if
      iif
        ldloc_0
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        ldarg_1
        call TowersDisk_getSize
        ldloc_0
        call TowersDisk_getSize
        clt
        ldc_i4_0
        ceq
      else
        ldc_i4_0
      end
    then
      ldc_i4_0
      ldc_i4_s 81
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Towers.mic"
      call $MIC!assert
    end
    ldarg_1
    ldloc_0
    call TowersDisk_setNext
    ldarg_0
    ldflda Towers.piles
    ldarg_2
    ldelema $2
    ldarg_1
    stind_ip
  end pushDisk
  type $14 = pointer to Towers
  type $15 = pointer to TowersDisk
  type $16 = pointer to TowersDisk
  procedure popDiskFrom(me: $14; pile: int32):$15
  var top: $16; 
  begin
    ldloca_s 0
    ldarg_0
    ldflda Towers.piles
    ldarg_1
    ldelem $2
    stind_ip
    if
      ldloc_0
      ldnull
      ceq
    then
      ldc_i4_0
      ldc_i4_s 92
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Towers.mic"
      call $MIC!assert
    end
    ldarg_0
    ldflda Towers.piles
    ldarg_1
    ldelema $2
    ldloc_0
    call TowersDisk_getNext
    stind_ip
    ldloc_0
    ldnull
    call TowersDisk_setNext
    ldloc_0
    ret
  end popDiskFrom
  type $17 = pointer to Towers
  procedure moveTopDisk(me: $17; fromPile: int32; toPile: int32)
  begin
    ldarg_0
    ldarg_0
    ldarg_1
    call popDiskFrom
    ldarg_2
    call pushDisk
    ldarg_0
    ldflda Towers.movesDone
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
  end moveTopDisk
  type $18 = pointer to Towers
  procedure buildTowerAt(me: $18; pile: int32; disks: int32)
  var i: int32; $19: int32; 
  begin
    ldloca_s 0
    ldarg_2
    stind_i4
    ldloca_s 1
    ldc_i4_0
    stind_i4
    while
      ldloc_0
      ldloc_1
      clt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldloc_0
      call TowersDisk_create
      ldarg_1
      call pushDisk
      ldloca_s 0
      ldloc_0
      ldc_i4_m1
      add
      stind_i4
    end
  end buildTowerAt
  type $20 = pointer to Towers
  procedure moveDisks(me: $20; disks: int32; fromPile: int32; toPile: int32)
  var otherPile: int32; 
  begin
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      ldarg_0
      ldarg_2
      ldarg_3
      call moveTopDisk
    else
      ldloca_s 0
      ldc_i4_3
      ldarg_2
      sub
      ldarg_3
      sub
      stind_i4
      ldarg_0
      ldarg_1
      ldc_i4_1
      sub
      ldarg_2
      ldloc_0
      call moveDisks
      ldarg_0
      ldarg_2
      ldarg_3
      call moveTopDisk
      ldarg_0
      ldarg_1
      ldc_i4_1
      sub
      ldloc_0
      ldarg_3
      call moveDisks
    end
  end moveDisks
  type $21 = pointer to Benchmark!Benchmark
  type $22 = pointer to Towers
  type $23 = pointer to Towers
  procedure benchmark(b: $21):int32
  var i: int32; me: $22; $24: int32; $25: int32; 
  begin
    ldloca_s 1
    ldarg_0
    castptr Towers
    stind_ip
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_2
    stind_i4
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_1
      ldflda Towers.piles
      ldloc_0
      ldelema $2
      ldnull
      stind_ip
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_1
    ldc_i4_0
    ldc_i4_s 13
    call buildTowerAt
    ldloc_1
    ldflda Towers.movesDone
    ldc_i4_0
    stind_i4
    ldloc_1
    ldc_i4_s 13
    ldc_i4_0
    ldc_i4_1
    call moveDisks
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4_2
    stind_i4
    while
      ldloc_0
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldloc_1
        ldflda Towers.piles
        ldloc_0
        ldelem $2
      then
        ldloc_1
        ldflda Towers.piles
        ldloc_0
        ldelem $2
        call TowersDisk_dispose
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_1
    ldfld Towers.movesDone
    ret
  end benchmark
  type $26 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: $26; result: int32):bool
  begin
    ldc_i4 8191
    ldarg_1
    ceq
    ret
  end verifyResult
  type $27 = pointer to Benchmark!Benchmark
  type $28 = pointer to Towers
  procedure create():$27
  var t: $28; 
  begin
    ldloca_s 0
    newobj Towers
    stind_ip
    ldloc_0
    ldflda Towers.base
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Towers.base
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Towers.base
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Towers.base
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Towers

// Generated by MicCompiler  on 2025-03-25T18:52:44

module MathL
  type sqrt = proc(x: float64):float64 extern 
  type power = proc(x: float64; base: float64):float64 extern 
  type exp = proc(x: float64):float64 extern 
  type ln = proc(x: float64):float64 extern 
  type log = proc(x: float64; base: float64):float64 extern 
  type round = proc(x: float64):float64 extern 
  type sin = proc(x: float64):float64 extern 
  type cos = proc(x: float64):float64 extern 
  type tan = proc(x: float64):float64 extern 
  type arcsin = proc(x: float64):float64 extern 
  type arccos = proc(x: float64):float64 extern 
  type arctan = proc(x: float64):float64 extern 
  type arctan2 = proc(x: float64; y: float64):float64 extern 
  type sinh = proc(x: float64):float64 extern 
  type cosh = proc(x: float64):float64 extern 
  type tanh = proc(x: float64):float64 extern 
  type arcsinh = proc(x: float64):float64 extern 
  type arccosh = proc(x: float64):float64 extern 
  type arctanh = proc(x: float64):float64 extern 
end MathL

// Generated by MicCompiler  on 2025-03-25T18:52:44

module NBody
  import Benchmark
  import MathL
  type Body = struct 
    x: float64
    y: float64
    z: float64
    vx: float64
    vy: float64
    vz: float64
    mass: float64
  end
  type $1 = array 5 of Body
  type NBodySystem = struct 
    bodies: $1
  end
  type $2 = pointer to Body
  procedure Body_getX(me: $2):float64
  begin
    ldarg_0
    ldfld Body.x
    ret
  end Body_getX
  type $3 = pointer to Body
  procedure Body_getY(me: $3):float64
  begin
    ldarg_0
    ldfld Body.y
    ret
  end Body_getY
  type $4 = pointer to Body
  procedure Body_getZ(me: $4):float64
  begin
    ldarg_0
    ldfld Body.z
    ret
  end Body_getZ
  type $5 = pointer to Body
  procedure Body_getVX(me: $5):float64
  begin
    ldarg_0
    ldfld Body.vx
    ret
  end Body_getVX
  type $6 = pointer to Body
  procedure Body_getVY(me: $6):float64
  begin
    ldarg_0
    ldfld Body.vy
    ret
  end Body_getVY
  type $7 = pointer to Body
  procedure Body_getVZ(me: $7):float64
  begin
    ldarg_0
    ldfld Body.vz
    ret
  end Body_getVZ
  type $8 = pointer to Body
  procedure Body_getMass(me: $8):float64
  begin
    ldarg_0
    ldfld Body.mass
    ret
  end Body_getMass
  type $9 = pointer to Body
  procedure Body_setX(me: $9; x: float64)
  begin
    ldarg_0
    ldflda Body.x
    ldarg_1
    stind_r8
  end Body_setX
  type $10 = pointer to Body
  procedure Body_setY(me: $10; y: float64)
  begin
    ldarg_0
    ldflda Body.y
    ldarg_1
    stind_r8
  end Body_setY
  type $11 = pointer to Body
  procedure Body_setZ(me: $11; z: float64)
  begin
    ldarg_0
    ldflda Body.z
    ldarg_1
    stind_r8
  end Body_setZ
  type $12 = pointer to Body
  procedure Body_setVX(me: $12; vx: float64)
  begin
    ldarg_0
    ldflda Body.vx
    ldarg_1
    stind_r8
  end Body_setVX
  type $13 = pointer to Body
  procedure Body_setVY(me: $13; vy: float64)
  begin
    ldarg_0
    ldflda Body.vy
    ldarg_1
    stind_r8
  end Body_setVY
  type $14 = pointer to Body
  procedure Body_setVZ(me: $14; vz: float64)
  begin
    ldarg_0
    ldflda Body.vz
    ldarg_1
    stind_r8
  end Body_setVZ
  type $15 = pointer to Body
  procedure Body_offsetMomentum(me: $15; px: float64; py: float64; pz: float64)
  begin
    ldarg_0
    ldflda Body.vx
    ldc_r8 0
    ldarg_1
    ldc_r8 39.4784176043574
    div
    sub
    stind_r8
    ldarg_0
    ldflda Body.vy
    ldc_r8 0
    ldarg_2
    ldc_r8 39.4784176043574
    div
    sub
    stind_r8
    ldarg_0
    ldflda Body.vz
    ldc_r8 0
    ldarg_3
    ldc_r8 39.4784176043574
    div
    sub
    stind_r8
  end Body_offsetMomentum
  procedure Body_create(x: float64; y: float64; z: float64; vx: float64; vy: float64; vz: float64; mass: float64):Body
  var res: Body; 
  begin
    ldloca_s 0
    ldflda Body.x
    ldarg_0
    stind_r8
    ldloca_s 0
    ldflda Body.y
    ldarg_1
    stind_r8
    ldloca_s 0
    ldflda Body.z
    ldarg_2
    stind_r8
    ldloca_s 0
    ldflda Body.vx
    ldarg_3
    ldc_r8 365.24
    mul
    stind_r8
    ldloca_s 0
    ldflda Body.vy
    ldarg_s 4
    ldc_r8 365.24
    mul
    stind_r8
    ldloca_s 0
    ldflda Body.vz
    ldarg_s 5
    ldc_r8 365.24
    mul
    stind_r8
    ldloca_s 0
    ldflda Body.mass
    ldarg_s 6
    ldc_r8 39.4784176043574
    mul
    stind_r8
    ldloc_0
    ret
  end Body_create
  procedure Body_jupiter():Body
  begin
    ldc_r8 4.84143144246472
    ldc_r8 -1.16032004402743
    ldc_r8 -0.103622044471123
    ldc_r8 0.00166007664274404
    ldc_r8 0.0076990111841974
    ldc_r8 -6.90460016972063e-05
    ldc_r8 0.000954791938424327
    call Body_create
    ret
  end Body_jupiter
  procedure Body_saturn():Body
  begin
    ldc_r8 8.34336671824458
    ldc_r8 4.1247985641243
    ldc_r8 -0.403523417114321
    ldc_r8 -0.00276742510726862
    ldc_r8 0.00499852801234917
    ldc_r8 2.30417297573764e-05
    ldc_r8 0.000285885980666131
    call Body_create
    ret
  end Body_saturn
  procedure Body_uranus():Body
  begin
    ldc_r8 12.8943695621391
    ldc_r8 -15.1111514016986
    ldc_r8 -0.223307578892656
    ldc_r8 0.00296460137564762
    ldc_r8 0.00237847173959481
    ldc_r8 -2.96589568540238e-05
    ldc_r8 4.36624404335156e-05
    call Body_create
    ret
  end Body_uranus
  procedure Body_neptune():Body
  begin
    ldc_r8 15.3796971148509
    ldc_r8 -25.919314609988
    ldc_r8 0.179258772950371
    ldc_r8 0.00268067772490389
    ldc_r8 0.00162824170038242
    ldc_r8 -9.51592254519716e-05
    ldc_r8 5.15138902046611e-05
    call Body_create
    ret
  end Body_neptune
  procedure Body_sun():Body
  begin
    ldc_r4 0
    ldc_r4 0
    ldc_r4 0
    ldc_r4 0
    ldc_r4 0
    ldc_r4 0
    ldc_r4 1
    call Body_create
    ret
  end Body_sun
  type $16 = pointer to Body
  procedure test(b: $16)
  begin
    ldarg_0
    ldfld Body.mass
    call $MIC!printF8
    ldc_i4_s 10
    call $MIC!printCh
  end test
  type $17 = pointer to NBodySystem
  type $18 = pointer to Body
  type $20 = pointer to Body
  type $21 = pointer to Body
  procedure NBodySystem_init(me: $17)
  var px: float64; py: float64; pz: float64; i: int32; b: $18; tmp: float64; $19: int32; 
  begin
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_0
    ldelema Body
    call Body_sun
    stind Body
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_1
    ldelema Body
    call Body_jupiter
    stind Body
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_2
    ldelema Body
    call Body_saturn
    stind Body
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_3
    ldelema Body
    call Body_uranus
    stind Body
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_4
    ldelema Body
    call Body_neptune
    stind Body
    ldloca_s 0
    ldc_r4 0
    conv_r8
    stind_r8
    ldloca_s 1
    ldc_r4 0
    conv_r8
    stind_r8
    ldloca_s 2
    ldc_r4 0
    conv_r8
    stind_r8
    ldloca_s 3
    ldc_i4_0
    stind_i4
    ldloca_s 6
    ldc_i4_4
    stind_i4
    while
      ldloc_3
      ldloc_s 6
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 4
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_3
      ldelema Body
      stind_ip
      ldloca_s 0
      ldloc_0
      ldloc_s 4
      call Body_getVX
      ldloc_s 4
      call Body_getMass
      mul
      add
      stind_r8
      ldloca_s 1
      ldloc_1
      ldloc_s 4
      call Body_getVY
      ldloc_s 4
      call Body_getMass
      mul
      add
      stind_r8
      ldloca_s 2
      ldloc_2
      ldloc_s 4
      call Body_getVZ
      ldloc_s 4
      call Body_getMass
      mul
      add
      stind_r8
      ldloca_s 3
      ldloc_3
      ldc_i4_1
      add
      stind_i4
    end
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_0
    ldelema Body
    ldloc_0
    ldloc_1
    ldloc_2
    call Body_offsetMomentum
  end NBodySystem_init
  type $22 = pointer to NBodySystem
  type $23 = pointer to Body
  type $25 = pointer to Body
  type $27 = pointer to Body
  type $29 = pointer to Body
  procedure NBodySystem_advance(me: $22; dt: float64)
  var i: int32; j: int32; iBody: $23; jBody: $23; dx: float64; dy: float64; dz: float64; dSquared: float64; distance: float64; mag: float64; $24: int32; $26: int32; $28: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 10
    ldc_i4_4
    stind_i4
    while
      ldloc_0
      ldloc_s 10
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 2
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_0
      ldelema Body
      stind_ip
      ldloca_s 1
      ldloc_0
      ldc_i4_1
      add
      stind_i4
      ldloca_s 11
      ldc_i4_4
      stind_i4
      while
        ldloc_1
        ldloc_s 11
        cgt
        ldc_i4_0
        ceq
      do
        ldloca_s 3
        ldarg_0
        ldflda NBodySystem.bodies
        ldloc_1
        ldelema Body
        stind_ip
        ldloca_s 4
        ldloc_2
        call Body_getX
        ldloc_3
        call Body_getX
        sub
        stind_r8
        ldloca_s 5
        ldloc_2
        call Body_getY
        ldloc_3
        call Body_getY
        sub
        stind_r8
        ldloca_s 6
        ldloc_2
        call Body_getZ
        ldloc_3
        call Body_getZ
        sub
        stind_r8
        ldloca_s 7
        ldloc_s 4
        ldloc_s 4
        mul
        ldloc_s 5
        ldloc_s 5
        mul
        add
        ldloc_s 6
        ldloc_s 6
        mul
        add
        stind_r8
        ldloca_s 8
        ldloc_s 7
        call MathL!sqrt
        stind_r8
        ldloca_s 9
        ldarg_1
        ldloc_s 7
        ldloc_s 8
        mul
        div
        stind_r8
        ldloc_2
        ldloc_2
        call Body_getVX
        ldloc_s 4
        ldloc_3
        call Body_getMass
        mul
        ldloc_s 9
        mul
        sub
        call Body_setVX
        ldloc_2
        ldloc_2
        call Body_getVY
        ldloc_s 5
        ldloc_3
        call Body_getMass
        mul
        ldloc_s 9
        mul
        sub
        call Body_setVY
        ldloc_2
        ldloc_2
        call Body_getVZ
        ldloc_s 6
        ldloc_3
        call Body_getMass
        mul
        ldloc_s 9
        mul
        sub
        call Body_setVZ
        ldloc_3
        ldloc_3
        call Body_getVX
        ldloc_s 4
        ldloc_2
        call Body_getMass
        mul
        ldloc_s 9
        mul
        add
        call Body_setVX
        ldloc_3
        ldloc_3
        call Body_getVY
        ldloc_s 5
        ldloc_2
        call Body_getMass
        mul
        ldloc_s 9
        mul
        add
        call Body_setVY
        ldloc_3
        ldloc_3
        call Body_getVZ
        ldloc_s 6
        ldloc_2
        call Body_getMass
        mul
        ldloc_s 9
        mul
        add
        call Body_setVZ
        ldloca_s 1
        ldloc_1
        ldc_i4_1
        add
        stind_i4
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 12
    ldc_i4_4
    stind_i4
    while
      ldloc_0
      ldloc_s 12
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 2
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_0
      ldelema Body
      stind_ip
      ldloc_2
      ldloc_2
      call Body_getX
      ldarg_1
      ldloc_2
      call Body_getVX
      mul
      add
      call Body_setX
      ldloc_2
      ldloc_2
      call Body_getY
      ldarg_1
      ldloc_2
      call Body_getVY
      mul
      add
      call Body_setY
      ldloc_2
      ldloc_2
      call Body_getZ
      ldarg_1
      ldloc_2
      call Body_getVZ
      mul
      add
      call Body_setZ
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
  end NBodySystem_advance
  type $30 = pointer to NBodySystem
  type $31 = pointer to Body
  type $33 = pointer to Body
  type $35 = pointer to Body
  procedure NBodySystem_energy(me: $30):float64
  var e: float64; i: int32; j: int32; iBody: $31; jBody: $31; dx: float64; dy: float64; dz: float64; distance: float64; $32: int32; $34: int32; 
  begin
    ldloca_s 0
    ldc_r4 0
    conv_r8
    stind_r8
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 9
    ldc_i4_4
    stind_i4
    while
      ldloc_1
      ldloc_s 9
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 3
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_1
      ldelema Body
      stind_ip
      ldloca_s 0
      ldloc_0
      ldc_r8 0.5
      ldloc_3
      call Body_getMass
      mul
      ldloc_3
      call Body_getVX
      ldloc_3
      call Body_getVX
      mul
      ldloc_3
      call Body_getVY
      ldloc_3
      call Body_getVY
      mul
      add
      ldloc_3
      call Body_getVZ
      ldloc_3
      call Body_getVZ
      mul
      add
      mul
      add
      stind_r8
      ldloca_s 2
      ldloc_1
      ldc_i4_1
      add
      stind_i4
      ldloca_s 10
      ldc_i4_4
      stind_i4
      while
        ldloc_2
        ldloc_s 10
        cgt
        ldc_i4_0
        ceq
      do
        ldloca_s 4
        ldarg_0
        ldflda NBodySystem.bodies
        ldloc_2
        ldelema Body
        stind_ip
        ldloca_s 5
        ldloc_3
        call Body_getX
        ldloc_s 4
        call Body_getX
        sub
        stind_r8
        ldloca_s 6
        ldloc_3
        call Body_getY
        ldloc_s 4
        call Body_getY
        sub
        stind_r8
        ldloca_s 7
        ldloc_3
        call Body_getZ
        ldloc_s 4
        call Body_getZ
        sub
        stind_r8
        ldloca_s 8
        ldloc_s 5
        ldloc_s 5
        mul
        ldloc_s 6
        ldloc_s 6
        mul
        add
        ldloc_s 7
        ldloc_s 7
        mul
        add
        call MathL!sqrt
        stind_r8
        ldloca_s 0
        ldloc_0
        ldloc_3
        call Body_getMass
        ldloc_s 4
        call Body_getMass
        mul
        ldloc_s 8
        div
        sub
        stind_r8
        ldloca_s 2
        ldloc_2
        ldc_i4_1
        add
        stind_i4
      end
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end NBodySystem_energy
  procedure verifyResult2(resultValue: float64; innerIterations: int32):bool
  begin
    if
      ldarg_1
      ldc_i4 250000
      ceq
    then
      ldarg_0
      dup
      ldc_r8 0
      cgt
      ifgoto $ABS4
      neg
      label $ABS4
      ldc_r8 0.169085988990931
      sub
      ldc_r8 5.0e-14
      clt
      ret
    end
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      ldarg_0
      dup
      ldc_r8 0
      cgt
      ifgoto $ABS5
      neg
      label $ABS5
      ldc_r8 0.169074954025067
      sub
      ldc_r8 5.0e-14
      clt
      ret
    end
    ldstr "No verification result for "
    call $MIC!printStr
    ldarg_1
    conv_i8
    call $MIC!printI8
    ldstr " found"
    call $MIC!printStr
    ldc_i4_s 10
    call $MIC!printCh
    ldstr "Result is: "
    call $MIC!printStr
    ldarg_0
    call $MIC!printF8
    ldc_i4_s 10
    call $MIC!printCh
    ldc_i4_0
    ret
  end verifyResult2
  type $36 = pointer to Benchmark!Benchmark
  type $37 = pointer to NBodySystem
  type $39 = pointer to NBodySystem
  type $40 = pointer to NBodySystem
  procedure innerBenchmarkLoop(me: $36; innerIterations: int32):bool
  var system: NBodySystem; i: int32; $38: int32; 
  begin
    ldloca_s 0
    call NBodySystem_init
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldarg_1
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_1
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 0
      ldc_r4 0.00999999977648258
      call NBodySystem_advance
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 0
    call NBodySystem_energy
    ldarg_1
    call verifyResult2
    ret
  end innerBenchmarkLoop
  type $41 = pointer to Benchmark!Benchmark
  procedure benchmark(me: $41):int32
  begin
    ldc_i4_0
    ldc_i4 295
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/NBody.mic"
    call $MIC!assert
    ldc_i4_0
    ret
  end benchmark
  type $42 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: $42; resultVal: int32):bool
  begin
    ldc_i4_0
    ldc_i4 301
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/NBody.mic"
    call $MIC!assert
    ldc_i4_0
    ret
  end verifyResult
  type $43 = pointer to Benchmark!Benchmark
  type $44 = pointer to Benchmark!Benchmark
  procedure create():$43
  var bench: $44; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldproc innerBenchmarkLoop
    stind_ip
    ldloc_0
    ret
  end create
end NBody

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Richards
  import Benchmark
  type $1 = pointer to RBObject
  type RBObject = struct 
    next: $1
  end
  type PacketData = array 4 of int32
  type $2 = pointer to Packet
  type Packet = struct 
    base: RBObject
    link: $2
    identity: int32
    kind: int32
    datum: int32
    data: PacketData
  end
  type TaskState = struct 
    base: RBObject
    packetPending: bool
    taskWaiting: bool
    taskHolding: bool
  end
  type $3 = pointer to TaskControlBlock
  type $4 = pointer to Packet
  type $5 = pointer to ProcessFunction
  type $6 = pointer to RBObject
  type TaskControlBlock = struct 
    base: TaskState
    link: $3
    identity: int32
    priority: int32
    input: $4
    procedure_: $5
    handle: $6
  end
  type $7 = pointer to ProcessFunction
  type $8 = pointer to Packet
  type $9 = pointer to RBObject
  type $10 = pointer to TaskControlBlock
  type $11 = proc(me: $7; work: $8; word: $9):$10
  type ProcessFunction = struct 
    base: RBObject
    apply: $11
  end
  type $12 = pointer to Packet
  type DeviceTaskDataRecord = struct 
    base: RBObject
    pending: $12
  end
  type $13 = pointer to Packet
  type $14 = pointer to Packet
  type HandlerTaskDataRecord = struct 
    base: RBObject
    workIn: $13
    deviceIn: $14
  end
  type IdleTaskDataRecord = struct 
    base: RBObject
    control: int32
    count: int32
  end
  type WorkerTaskDataRecord = struct 
    base: RBObject
    destination: int32
    count: int32
  end
  type $15 = pointer to TaskControlBlock
  type $16 = pointer to TaskControlBlock
  type $17 = pointer to TaskControlBlock
  type $18 = array 6 of $17
  type Scheduler = struct 
    base: RBObject
    taskList: $15
    currentTask: $16
    currentTaskIdentity: int32
    taskTable: $18
    queuePacketCount: int32
    holdCount: int32
    layout: int32
  end
  type $19 = pointer to Scheduler
  type FP = struct 
    base: ProcessFunction
    s: $19
  end
  type $20 = pointer to Packet
  var NO_WORK: $20
  type $21 = pointer to TaskControlBlock
  var NO_TASK: $21
  type $22 = pointer to RBObject
  var toDelete: $22
  var TRACING: bool
  type $23 = pointer to Scheduler
  type $24 = pointer to TaskControlBlock
  type $25 = pointer to Scheduler
  type $26 = pointer to Packet
  type $27 = pointer to TaskControlBlock
  type $28 = pointer to Scheduler
  type $29 = pointer to Scheduler
  type $30 = pointer to TaskControlBlock
  type $31 = pointer to Scheduler
  type $32 = pointer to TaskControlBlock
  type $33 = pointer to Scheduler
  type $34 = pointer to RBObject
  procedure RBObject_init(o: $34)
  begin
    ldarg_0
    ldflda RBObject.next
    ldvar toDelete
    stind_ip
    ldvara toDelete
    ldarg_0
    stind_ip
  end RBObject_init
  type $35 = pointer to RBObject
  procedure RBObject_delete(o: $35)
  begin
    if
      ldarg_0
      ldfld RBObject.next
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldfld RBObject.next
      call RBObject_delete
    end
    ldarg_0
    free
  end RBObject_delete
  type $36 = pointer to Packet
  type $37 = pointer to Packet
  type $38 = pointer to Packet
  type $39 = pointer to RBObject
  procedure Packet_create(link: $36; identity: int32; kind: int32):$37
  var me: $38; i: int32; $40: int32; 
  begin
    ldloca_s 0
    newobj Packet
    stind_ip
    ldloc_0
    ldflda Packet.base
    call RBObject_init
    ldloc_0
    ldflda Packet.link
    ldarg_0
    stind_ip
    ldloc_0
    ldflda Packet.identity
    ldarg_1
    stind_i4
    ldloc_0
    ldflda Packet.kind
    ldarg_2
    stind_i4
    ldloc_0
    ldflda Packet.datum
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_3
    stind_i4
    while
      ldloc_1
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_0
      ldflda Packet.data
      ldloc_1
      ldelema int32
      ldc_i4_0
      stind_i4
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end Packet_create
  type $41 = pointer to Packet
  type $42 = pointer to PacketData
  type $43 = pointer to PacketData
  procedure Packet_getData(me: $41):$42
  begin
    ldarg_0
    ldflda Packet.data
    ret
  end Packet_getData
  type $44 = pointer to Packet
  procedure Packet_getDatum(me: $44):int32
  begin
    ldarg_0
    ldfld Packet.datum
    ret
  end Packet_getDatum
  type $45 = pointer to Packet
  procedure Packet_setDatum(me: $45; someData: int32)
  begin
    ldarg_0
    ldflda Packet.datum
    ldarg_1
    stind_i4
  end Packet_setDatum
  type $46 = pointer to Packet
  procedure Packet_getIdentity(me: $46):int32
  begin
    ldarg_0
    ldfld Packet.identity
    ret
  end Packet_getIdentity
  type $47 = pointer to Packet
  procedure Packet_setIdentity(me: $47; anIdentity: int32)
  begin
    ldarg_0
    ldflda Packet.identity
    ldarg_1
    stind_i4
  end Packet_setIdentity
  type $48 = pointer to Packet
  procedure Packet_getKind(me: $48):int32
  begin
    ldarg_0
    ldfld Packet.kind
    ret
  end Packet_getKind
  type $49 = pointer to Packet
  type $50 = pointer to Packet
  procedure Packet_getLink(me: $49):$50
  begin
    ldarg_0
    ldfld Packet.link
    ret
  end Packet_getLink
  type $51 = pointer to Packet
  type $52 = pointer to Packet
  procedure Packet_setLink(me: $51; aLink: $52)
  begin
    ldarg_0
    ldflda Packet.link
    ldarg_1
    stind_ip
  end Packet_setLink
  type $53 = pointer to Packet
  type $54 = pointer to Packet
  type $55 = pointer to Packet
  procedure RBObject_append(packet: $53; queueHead: $53):$54
  var mouse: $55; link: $55; 
  begin
    ldarg_0
    ldvar NO_WORK
    call Packet_setLink
    if
      ldarg_1
      ldvar NO_WORK
      ceq
    then
      ldarg_0
      ret
    end
    ldloca_s 0
    ldarg_1
    stind_ip
    ldloca_s 1
    ldloc_0
    call Packet_getLink
    stind_ip
    while
      ldvar NO_WORK
      ldloc_1
      ceq
      ldc_i4_0
      ceq
    do
      ldloca_s 0
      ldloc_1
      stind_ip
      ldloca_s 1
      ldloc_0
      call Packet_getLink
      stind_ip
    end
    ldloc_0
    ldarg_0
    call Packet_setLink
    ldarg_1
    ret
  end RBObject_append
  type $56 = pointer to TaskState
  type $57 = pointer to RBObject
  procedure TaskState_init(me: $56)
  begin
    ldarg_0
    ldflda TaskState.base
    call RBObject_init
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
  end TaskState_init
  type $58 = pointer to TaskState
  type $59 = pointer to TaskState
  procedure TaskState_create():$58
  var me: $59; 
  begin
    ldloca_s 0
    newobj TaskState
    stind_ip
    ldloc_0
    call TaskState_init
    ldloc_0
    ret
  end TaskState_create
  type $60 = pointer to TaskState
  procedure TaskState_isPacketPending(me: $60):bool
  begin
    ldarg_0
    ldfld TaskState.packetPending
    ret
  end TaskState_isPacketPending
  type $61 = pointer to TaskState
  procedure TaskState_isTaskHolding(me: $61):bool
  begin
    ldarg_0
    ldfld TaskState.taskHolding
    ret
  end TaskState_isTaskHolding
  type $62 = pointer to TaskState
  procedure TaskState_isTaskWaiting(me: $62):bool
  begin
    ldarg_0
    ldfld TaskState.taskWaiting
    ret
  end TaskState_isTaskWaiting
  type $63 = pointer to TaskState
  procedure TaskState_setTaskHolding(me: $63; b: bool)
  begin
    ldarg_0
    ldflda TaskState.taskHolding
    ldarg_1
    stind_i1
  end TaskState_setTaskHolding
  type $64 = pointer to TaskState
  procedure TaskState_setTaskWaiting(me: $64; b: bool)
  begin
    ldarg_0
    ldflda TaskState.taskWaiting
    ldarg_1
    stind_i1
  end TaskState_setTaskWaiting
  type $65 = pointer to TaskState
  procedure TaskState_setPacketPending(me: $65; b: bool)
  begin
    ldarg_0
    ldflda TaskState.packetPending
    ldarg_1
    stind_i1
  end TaskState_setPacketPending
  type $66 = pointer to TaskState
  procedure TaskState_packetPending(me: $66)
  begin
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_1
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
  end TaskState_packetPending
  type $67 = pointer to TaskState
  procedure TaskState_running(me: $67)
  begin
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
  end TaskState_running
  type $68 = pointer to TaskState
  procedure TaskState_waiting(me: $68)
  begin
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_1
    stind_i1
  end TaskState_waiting
  type $69 = pointer to TaskState
  procedure TaskState_waitingWithPacket(me: $69)
  begin
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_1
    stind_i1
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_1
    stind_i1
  end TaskState_waitingWithPacket
  type $70 = pointer to TaskState
  procedure TaskState_isRunning(me: $70):bool
  begin
    iif
      iif
        ldarg_0
        ldfld TaskState.packetPending
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld TaskState.taskWaiting
        ldc_i4_0
        ceq
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld TaskState.taskHolding
      ldc_i4_0
      ceq
    else
      ldc_i4_0
    end
    ret
  end TaskState_isRunning
  type $71 = pointer to TaskState
  procedure TaskState_isTaskHoldingOrWaiting(me: $71):bool
  begin
    iif
      ldarg_0
      ldfld TaskState.taskHolding
    then
      ldc_i4_1
    else
      iif
        ldarg_0
        ldfld TaskState.packetPending
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld TaskState.taskWaiting
      else
        ldc_i4_0
      end
    end
    ret
  end TaskState_isTaskHoldingOrWaiting
  type $72 = pointer to TaskState
  procedure TaskState_isWaiting(me: $72):bool
  begin
    iif
      iif
        ldarg_0
        ldfld TaskState.packetPending
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld TaskState.taskWaiting
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld TaskState.taskHolding
      ldc_i4_0
      ceq
    else
      ldc_i4_0
    end
    ret
  end TaskState_isWaiting
  type $73 = pointer to TaskState
  procedure TaskState_isWaitingWithPacket(me: $73):bool
  begin
    iif
      iif
        ldarg_0
        ldfld TaskState.packetPending
      then
        ldarg_0
        ldfld TaskState.taskWaiting
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld TaskState.taskHolding
      ldc_i4_0
      ceq
    else
      ldc_i4_0
    end
    ret
  end TaskState_isWaitingWithPacket
  type $74 = pointer to TaskState
  type $75 = pointer to TaskState
  procedure TaskState_createPacketPending():$74
  var t: $75; 
  begin
    ldloca_s 0
    call TaskState_create
    stind_ip
    ldloc_0
    call TaskState_packetPending
    ldloc_0
    ret
  end TaskState_createPacketPending
  type $76 = pointer to TaskState
  type $77 = pointer to TaskState
  procedure TaskState_createRunning():$76
  var t: $77; 
  begin
    ldloca_s 0
    call TaskState_create
    stind_ip
    ldloc_0
    call TaskState_running
    ldloc_0
    ret
  end TaskState_createRunning
  type $78 = pointer to TaskState
  type $79 = pointer to TaskState
  procedure TaskState_createWaiting():$78
  var t: $79; 
  begin
    ldloca_s 0
    call TaskState_create
    stind_ip
    ldloc_0
    call TaskState_waiting
    ldloc_0
    ret
  end TaskState_createWaiting
  type $80 = pointer to TaskState
  type $81 = pointer to TaskState
  procedure TaskState_createWaitingWithPacket():$80
  var t: $81; 
  begin
    ldloca_s 0
    call TaskState_create
    stind_ip
    ldloc_0
    call TaskState_waitingWithPacket
    ldloc_0
    ret
  end TaskState_createWaitingWithPacket
  type $82 = pointer to TaskControlBlock
  type $83 = pointer to Packet
  type $84 = pointer to TaskState
  type $85 = pointer to ProcessFunction
  type $86 = pointer to RBObject
  type $87 = pointer to TaskControlBlock
  type $88 = pointer to TaskControlBlock
  type $89 = pointer to TaskState
  type $90 = pointer to TaskState
  type $91 = pointer to TaskState
  type $92 = pointer to TaskState
  procedure TaskControlBlock_create(aLink: $82; anIdentity: int32; aPriority: int32; anInitialWorkQueue: $83; anInitialState: $84; aBlock: $85; aPrivateData: $86):$87
  var me: $88; 
  begin
    ldloca_s 0
    newobj TaskControlBlock
    stind_ip
    ldloc_0
    ldflda TaskControlBlock.base
    call TaskState_init
    ldloc_0
    ldflda TaskControlBlock.link
    ldarg_0
    stind_ip
    ldloc_0
    ldflda TaskControlBlock.identity
    ldarg_1
    stind_i4
    ldloc_0
    ldflda TaskControlBlock.priority
    ldarg_2
    stind_i4
    ldloc_0
    ldflda TaskControlBlock.input
    ldarg_3
    stind_ip
    ldloc_0
    ldflda TaskControlBlock.base
    ldarg_s 4
    call TaskState_isPacketPending
    call TaskState_setPacketPending
    ldloc_0
    ldflda TaskControlBlock.base
    ldarg_s 4
    call TaskState_isTaskWaiting
    call TaskState_setTaskWaiting
    ldloc_0
    ldflda TaskControlBlock.base
    ldarg_s 4
    call TaskState_isTaskHolding
    call TaskState_setTaskHolding
    ldloc_0
    ldflda TaskControlBlock.procedure_
    ldarg_s 5
    stind_ip
    ldloc_0
    ldflda TaskControlBlock.handle
    ldarg_s 6
    stind_ip
    ldloc_0
    ret
  end TaskControlBlock_create
  type $93 = pointer to TaskControlBlock
  procedure TaskControlBlock_getIdentity(me: $93):int32
  begin
    ldarg_0
    ldfld TaskControlBlock.identity
    ret
  end TaskControlBlock_getIdentity
  type $94 = pointer to TaskControlBlock
  type $95 = pointer to TaskControlBlock
  procedure TaskControlBlock_getLink(me: $94):$95
  begin
    ldarg_0
    ldfld TaskControlBlock.link
    ret
  end TaskControlBlock_getLink
  type $96 = pointer to TaskControlBlock
  procedure TaskControlBlock_getPriority(me: $96):int32
  begin
    ldarg_0
    ldfld TaskControlBlock.priority
    ret
  end TaskControlBlock_getPriority
  type $97 = pointer to TaskControlBlock
  type $98 = pointer to Packet
  type $99 = pointer to TaskControlBlock
  type $100 = pointer to TaskControlBlock
  type $101 = pointer to TaskState
  procedure TaskControlBlock_addInputAndCheckPriority(me: $97; packet: $98; oldTask: $99):$100
  begin
    if
      ldarg_0
      ldfld TaskControlBlock.input
      ldvar NO_WORK
      ceq
    then
      ldarg_0
      ldflda TaskControlBlock.input
      ldarg_1
      stind_ip
      ldarg_0
      ldflda TaskControlBlock.base
      ldc_i4_1
      call TaskState_setPacketPending
      if
        ldarg_0
        ldfld TaskControlBlock.priority
        ldarg_2
        call TaskControlBlock_getPriority
        cgt
      then
        ldarg_0
        ret
      end
    else
      ldarg_0
      ldflda TaskControlBlock.input
      ldarg_1
      ldarg_0
      ldfld TaskControlBlock.input
      call RBObject_append
      stind_ip
    end
    ldarg_2
    ret
  end TaskControlBlock_addInputAndCheckPriority
  type $102 = pointer to TaskControlBlock
  type $103 = pointer to TaskControlBlock
  type $104 = pointer to Packet
  type $105 = pointer to TaskState
  type $106 = pointer to TaskState
  type $107 = pointer to TaskState
  procedure TaskControlBlock_runTask(me: $102):$103
  var message: $104; 
  begin
    if
      ldarg_0
      ldflda TaskControlBlock.base
      call TaskState_isWaitingWithPacket
    then
      ldloca_s 0
      ldarg_0
      ldfld TaskControlBlock.input
      stind_ip
      ldarg_0
      ldflda TaskControlBlock.input
      ldloc_0
      call Packet_getLink
      stind_ip
      if
        ldarg_0
        ldfld TaskControlBlock.input
        ldvar NO_WORK
        ceq
      then
        ldarg_0
        ldflda TaskControlBlock.base
        call TaskState_running
      else
        ldarg_0
        ldflda TaskControlBlock.base
        call TaskState_packetPending
      end
    else
      ldloca_s 0
      ldvar NO_WORK
      stind_ip
    end
    ldarg_0
    ldfld TaskControlBlock.procedure_
    ldloc_0
    ldarg_0
    ldfld TaskControlBlock.handle
    ldarg_0
    ldfld TaskControlBlock.procedure_
    ldfld ProcessFunction.apply
    calli $11
    ret
  end TaskControlBlock_runTask
  type $108 = pointer to DeviceTaskDataRecord
  type $109 = pointer to DeviceTaskDataRecord
  type $110 = pointer to RBObject
  procedure DeviceTaskDataRecord_create():$108
  var me: $109; 
  begin
    ldloca_s 0
    newobj DeviceTaskDataRecord
    stind_ip
    ldloc_0
    ldflda DeviceTaskDataRecord.base
    call RBObject_init
    ldloc_0
    ldflda DeviceTaskDataRecord.pending
    ldvar NO_WORK
    stind_ip
    ldloc_0
    ret
  end DeviceTaskDataRecord_create
  type $111 = pointer to DeviceTaskDataRecord
  type $112 = pointer to Packet
  procedure DeviceTaskDataRecord_getPending(me: $111):$112
  begin
    ldarg_0
    ldfld DeviceTaskDataRecord.pending
    ret
  end DeviceTaskDataRecord_getPending
  type $113 = pointer to DeviceTaskDataRecord
  type $114 = pointer to Packet
  procedure DeviceTaskDataRecord_setPending(me: $113; packet: $114)
  begin
    ldarg_0
    ldflda DeviceTaskDataRecord.pending
    ldarg_1
    stind_ip
  end DeviceTaskDataRecord_setPending
  type $115 = pointer to HandlerTaskDataRecord
  type $116 = pointer to HandlerTaskDataRecord
  type $117 = pointer to RBObject
  procedure HandlerTaskDataRecord_create():$115
  var me: $116; 
  begin
    ldloca_s 0
    newobj HandlerTaskDataRecord
    stind_ip
    ldloc_0
    ldflda HandlerTaskDataRecord.base
    call RBObject_init
    ldloc_0
    ldflda HandlerTaskDataRecord.workIn
    ldvar NO_WORK
    stind_ip
    ldloc_0
    ldflda HandlerTaskDataRecord.deviceIn
    ldvar NO_WORK
    stind_ip
    ldloc_0
    ret
  end HandlerTaskDataRecord_create
  type $118 = pointer to HandlerTaskDataRecord
  type $119 = pointer to Packet
  procedure HandlerTaskDataRecord_deviceIn(me: $118):$119
  begin
    ldarg_0
    ldfld HandlerTaskDataRecord.deviceIn
    ret
  end HandlerTaskDataRecord_deviceIn
  type $120 = pointer to HandlerTaskDataRecord
  type $121 = pointer to Packet
  procedure HandlerTaskDataRecord_setDeviceIn(me: $120; aPacket: $121)
  begin
    ldarg_0
    ldflda HandlerTaskDataRecord.deviceIn
    ldarg_1
    stind_ip
  end HandlerTaskDataRecord_setDeviceIn
  type $122 = pointer to HandlerTaskDataRecord
  type $123 = pointer to Packet
  procedure HandlerTaskDataRecord_deviceInAdd(me: $122; packet: $123)
  begin
    ldarg_0
    ldflda HandlerTaskDataRecord.deviceIn
    ldarg_1
    ldarg_0
    ldfld HandlerTaskDataRecord.deviceIn
    call RBObject_append
    stind_ip
  end HandlerTaskDataRecord_deviceInAdd
  type $124 = pointer to HandlerTaskDataRecord
  type $125 = pointer to Packet
  procedure HandlerTaskDataRecord_workIn(me: $124):$125
  begin
    ldarg_0
    ldfld HandlerTaskDataRecord.workIn
    ret
  end HandlerTaskDataRecord_workIn
  type $126 = pointer to HandlerTaskDataRecord
  type $127 = pointer to Packet
  procedure HandlerTaskDataRecord_setWorkIn(me: $126; aWorkQueue: $127)
  begin
    ldarg_0
    ldflda HandlerTaskDataRecord.workIn
    ldarg_1
    stind_ip
  end HandlerTaskDataRecord_setWorkIn
  type $128 = pointer to HandlerTaskDataRecord
  type $129 = pointer to Packet
  procedure HandlerTaskDataRecord_workInAdd(me: $128; packet: $129)
  begin
    ldarg_0
    ldflda HandlerTaskDataRecord.workIn
    ldarg_1
    ldarg_0
    ldfld HandlerTaskDataRecord.workIn
    call RBObject_append
    stind_ip
  end HandlerTaskDataRecord_workInAdd
  type $130 = pointer to IdleTaskDataRecord
  type $131 = pointer to IdleTaskDataRecord
  type $132 = pointer to RBObject
  procedure IdleTaskDataRecord_create():$130
  var me: $131; 
  begin
    ldloca_s 0
    newobj IdleTaskDataRecord
    stind_ip
    ldloc_0
    ldflda IdleTaskDataRecord.base
    call RBObject_init
    ldloc_0
    ldflda IdleTaskDataRecord.control
    ldc_i4_1
    stind_i4
    ldloc_0
    ldflda IdleTaskDataRecord.count
    ldc_i4 10000
    stind_i4
    ldloc_0
    ret
  end IdleTaskDataRecord_create
  type $133 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_getControl(me: $133):int32
  begin
    ldarg_0
    ldfld IdleTaskDataRecord.control
    ret
  end IdleTaskDataRecord_getControl
  type $134 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_setControl(me: $134; aNumber: int32)
  begin
    ldarg_0
    ldflda IdleTaskDataRecord.control
    ldarg_1
    stind_i4
  end IdleTaskDataRecord_setControl
  type $135 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_getCount(me: $135):int32
  begin
    ldarg_0
    ldfld IdleTaskDataRecord.count
    ret
  end IdleTaskDataRecord_getCount
  type $136 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_setCount(me: $136; aCount: int32)
  begin
    ldarg_0
    ldflda IdleTaskDataRecord.count
    ldarg_1
    stind_i4
  end IdleTaskDataRecord_setCount
  type $137 = pointer to WorkerTaskDataRecord
  type $138 = pointer to WorkerTaskDataRecord
  type $139 = pointer to RBObject
  procedure WorkerTaskDataRecord_create():$137
  var me: $138; 
  begin
    ldloca_s 0
    newobj WorkerTaskDataRecord
    stind_ip
    ldloc_0
    ldflda WorkerTaskDataRecord.base
    call RBObject_init
    ldloc_0
    ldflda WorkerTaskDataRecord.destination
    ldc_i4_2
    stind_i4
    ldloc_0
    ldflda WorkerTaskDataRecord.count
    ldc_i4_0
    stind_i4
    ldloc_0
    ret
  end WorkerTaskDataRecord_create
  type $140 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_getCount(me: $140):int32
  begin
    ldarg_0
    ldfld WorkerTaskDataRecord.count
    ret
  end WorkerTaskDataRecord_getCount
  type $141 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_setCount(me: $141; aCount: int32)
  begin
    ldarg_0
    ldflda WorkerTaskDataRecord.count
    ldarg_1
    stind_i4
  end WorkerTaskDataRecord_setCount
  type $142 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_getDestination(me: $142):int32
  begin
    ldarg_0
    ldfld WorkerTaskDataRecord.destination
    ret
  end WorkerTaskDataRecord_getDestination
  type $143 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_setDestination(me: $143; aHandler: int32)
  begin
    ldarg_0
    ldflda WorkerTaskDataRecord.destination
    ldarg_1
    stind_i4
  end WorkerTaskDataRecord_setDestination
  type $144 = pointer to Scheduler
  procedure Scheduler_init(me: $144)
  var i: int32; $145: int32; 
  begin
    ldarg_0
    ldflda Scheduler.layout
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Scheduler.currentTask
    ldnull
    stind_ip
    ldarg_0
    ldflda Scheduler.currentTaskIdentity
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Scheduler.queuePacketCount
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Scheduler.holdCount
    ldc_i4_0
    stind_i4
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_5
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldflda Scheduler.taskTable
      ldloc_0
      ldelema $17
      ldvar NO_TASK
      stind_ip
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldarg_0
    ldflda Scheduler.taskList
    ldvar NO_TASK
    stind_ip
  end Scheduler_init
  type $146 = pointer to Scheduler
  type $147 = pointer to ProcessFunction
  type $148 = pointer to Packet
  type $149 = pointer to RBObject
  type $150 = pointer to TaskControlBlock
  type $151 = proc(me: $147; work: $148; word: $149):$150
  type $152 = pointer to FP
  type $153 = pointer to FP
  type $154 = pointer to ProcessFunction
  procedure FP_create(s: $146; apply: $151):$152
  var me: $153; 
  begin
    ldloca_s 0
    newobj FP
    stind_ip
    ldloc_0
    ldflda FP.base
    call RBObject_init
    ldloc_0
    ldflda FP.s
    ldarg_0
    stind_ip
    ldloc_0
    ldflda FP.base
    ldflda ProcessFunction.apply
    ldarg_1
    stind_ip
    ldloc_0
    ret
  end FP_create
  type $155 = pointer to ProcessFunction
  type $156 = pointer to Packet
  type $157 = pointer to RBObject
  type $158 = pointer to TaskControlBlock
  type $159 = pointer to DeviceTaskDataRecord
  type $160 = pointer to FP
  type $161 = pointer to Packet
  type $162 = pointer to DeviceTaskDataRecord
  type $163 = pointer to FP
  procedure createDevice_apply(me: $155; workArg: $156; wordArg: $157):$158
  var dataRecord: $159; fp: $160; functionWork: $161; 
  begin
    ldloca_s 0
    ldarg_2
    castptr DeviceTaskDataRecord
    stind_ip
    ldloca_s 1
    ldarg_0
    castptr FP
    stind_ip
    ldloca_s 2
    ldarg_1
    stind_ip
    if
      ldloc_2
      ldvar NO_WORK
      ceq
    then
      ldloca_s 2
      ldloc_0
      call DeviceTaskDataRecord_getPending
      stind_ip
      if
        ldvar NO_WORK
        ldloc_2
        ceq
      then
        ldloc_1
        ldfld FP.s
        call Scheduler_markWaiting
        ret
      else
        ldloc_0
        ldvar NO_WORK
        call DeviceTaskDataRecord_setPending
        ldloc_1
        ldfld FP.s
        ldloc_2
        call Scheduler_queuePacket
        ret
      end
    else
      ldloc_0
      ldloc_2
      call DeviceTaskDataRecord_setPending
      if
        ldvar TRACING
      then
        ldloc_1
        ldfld FP.s
        ldloc_2
        call Packet_getDatum
        call Scheduler_trace
      end
      ldloc_1
      ldfld FP.s
      call Scheduler_holdSelf
      ret
    end
  end createDevice_apply
  type $164 = pointer to Scheduler
  type $165 = pointer to Packet
  type $166 = pointer to TaskState
  type $167 = pointer to ProcessFunction
  type $168 = pointer to RBObject
  type $169 = pointer to TaskControlBlock
  procedure Scheduler_createTask(me: $164; identity: int32; priority: int32; work: $165; state: $166; aBlock: $167; data: $168)
  var t: $169; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld Scheduler.taskList
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldarg_s 5
    ldarg_s 6
    call TaskControlBlock_create
    stind_ip
    ldarg_0
    ldflda Scheduler.taskList
    ldloc_0
    stind_ip
    ldarg_0
    ldflda Scheduler.taskTable
    ldarg_1
    ldelema $17
    ldloc_0
    stind_ip
  end Scheduler_createTask
  type $170 = pointer to Scheduler
  type $171 = pointer to Packet
  type $172 = pointer to TaskState
  type $173 = pointer to DeviceTaskDataRecord
  type $174 = pointer to FP
  type $175 = pointer to ProcessFunction
  procedure Scheduler_createDevice(me: $170; identity: int32; priority: int32; workPacket: $171; state: $172)
  var data: $173; fp: $174; 
  begin
    ldloca_s 0
    call DeviceTaskDataRecord_create
    stind_ip
    ldloca_s 1
    ldarg_0
    ldproc createDevice_apply
    call FP_create
    stind_ip
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
  end Scheduler_createDevice
  type $176 = pointer to ProcessFunction
  type $177 = pointer to Packet
  type $178 = pointer to RBObject
  type $179 = pointer to TaskControlBlock
  type $180 = pointer to HandlerTaskDataRecord
  type $181 = pointer to FP
  type $182 = pointer to Packet
  type $183 = pointer to HandlerTaskDataRecord
  type $184 = pointer to FP
  procedure createHandler_apply(me: $176; work: $177; word: $178):$179
  var dataRecord: $180; fp: $181; workPacket: $182; devicePacket: $182; count: int32; 
  begin
    ldloca_s 0
    ldarg_2
    castptr HandlerTaskDataRecord
    stind_ip
    ldloca_s 1
    ldarg_0
    castptr FP
    stind_ip
    if
      ldarg_1
      ldvar NO_WORK
      ceq
      ldc_i4_0
      ceq
    then
      if
        ldarg_1
        call Packet_getKind
        ldc_i4_1
        ceq
      then
        ldloc_0
        ldarg_1
        call HandlerTaskDataRecord_workInAdd
      else
        ldloc_0
        ldarg_1
        call HandlerTaskDataRecord_deviceInAdd
      end
    end
    ldloca_s 2
    ldloc_0
    call HandlerTaskDataRecord_workIn
    stind_ip
    if
      ldloc_2
      ldvar NO_WORK
      ceq
    then
      ldloc_1
      ldfld FP.s
      call Scheduler_markWaiting
      ret
    else
      ldloca_s 4
      ldloc_2
      call Packet_getDatum
      stind_i4
      if
        ldloc_s 4
        ldc_i4_4
        clt
        ldc_i4_0
        ceq
      then
        ldloc_0
        ldloc_2
        call Packet_getLink
        call HandlerTaskDataRecord_setWorkIn
        ldloc_1
        ldfld FP.s
        ldloc_2
        call Scheduler_queuePacket
        ret
      else
        ldloca_s 3
        ldloc_0
        call HandlerTaskDataRecord_deviceIn
        stind_ip
        if
          ldloc_3
          ldvar NO_WORK
          ceq
        then
          ldloc_1
          ldfld FP.s
          call Scheduler_markWaiting
          ret
        else
          ldloc_0
          ldloc_3
          call Packet_getLink
          call HandlerTaskDataRecord_setDeviceIn
          ldloc_3
          ldloc_2
          call Packet_getData
          ldloc_s 4
          ldelema int32
          call Packet_setDatum
          ldloc_2
          ldloc_s 4
          ldc_i4_1
          add
          call Packet_setDatum
          ldloc_1
          ldfld FP.s
          ldloc_3
          call Scheduler_queuePacket
          ret
        end
      end
    end
  end createHandler_apply
  type $185 = pointer to Scheduler
  type $186 = pointer to Packet
  type $187 = pointer to TaskState
  type $188 = pointer to HandlerTaskDataRecord
  type $189 = pointer to FP
  type $190 = pointer to ProcessFunction
  procedure Scheduler_createHandler(me: $185; identity: int32; priority: int32; workPacket: $186; state: $187)
  var data: $188; fp: $189; 
  begin
    ldloca_s 0
    call HandlerTaskDataRecord_create
    stind_ip
    ldloca_s 1
    ldarg_0
    ldproc createHandler_apply
    call FP_create
    stind_ip
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
  end Scheduler_createHandler
  type $191 = pointer to ProcessFunction
  type $192 = pointer to Packet
  type $193 = pointer to RBObject
  type $194 = pointer to TaskControlBlock
  type $195 = pointer to IdleTaskDataRecord
  type $196 = pointer to FP
  type $197 = pointer to IdleTaskDataRecord
  type $198 = pointer to FP
  procedure createIdler_apply(me: $191; workArg: $192; wordArg: $193):$194
  var dataRecord: $195; fp: $196; 
  begin
    ldloca_s 0
    ldarg_2
    castptr IdleTaskDataRecord
    stind_ip
    ldloca_s 1
    ldarg_0
    castptr FP
    stind_ip
    ldloc_0
    ldloc_0
    call IdleTaskDataRecord_getCount
    ldc_i4_1
    sub
    call IdleTaskDataRecord_setCount
    if
      ldloc_0
      call IdleTaskDataRecord_getCount
      ldc_i4_0
      ceq
    then
      ldloc_1
      ldfld FP.s
      call Scheduler_holdSelf
      ret
    else
      if
        ldloc_0
        call IdleTaskDataRecord_getControl
        conv_u4
        ldc_i4_1
        and
        ldc_i4_0
        ceq
      then
        ldloc_0
        ldloc_0
        call IdleTaskDataRecord_getControl
        ldc_i4_2
        div
        call IdleTaskDataRecord_setControl
        ldloc_1
        ldfld FP.s
        ldc_i4_4
        call Scheduler_release
        ret
      else
        ldloc_0
        ldloc_0
        call IdleTaskDataRecord_getControl
        conv_u4
        ldc_i4_2
        div_un
        ldc_i4 53256
        xor
        conv_i4
        call IdleTaskDataRecord_setControl
        ldloc_1
        ldfld FP.s
        ldc_i4_5
        call Scheduler_release
        ret
      end
    end
  end createIdler_apply
  type $199 = pointer to Scheduler
  type $200 = pointer to Packet
  type $201 = pointer to TaskState
  type $202 = pointer to IdleTaskDataRecord
  type $203 = pointer to FP
  type $204 = pointer to ProcessFunction
  procedure Scheduler_createIdler(me: $199; identity: int32; priority: int32; work: $200; state: $201)
  var data: $202; fp: $203; 
  begin
    ldloca_s 0
    call IdleTaskDataRecord_create
    stind_ip
    ldloca_s 1
    ldarg_0
    ldproc createIdler_apply
    call FP_create
    stind_ip
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
  end Scheduler_createIdler
  type $205 = pointer to Scheduler
  type $206 = pointer to Packet
  type $207 = pointer to Packet
  procedure Scheduler_createPacket(me: $205; link: $206; identity: int32; kind: int32):$207
  begin
    ldarg_1
    ldarg_2
    ldarg_3
    call Packet_create
    ret
  end Scheduler_createPacket
  type $208 = pointer to ProcessFunction
  type $209 = pointer to Packet
  type $210 = pointer to RBObject
  type $211 = pointer to TaskControlBlock
  type $212 = pointer to WorkerTaskDataRecord
  type $213 = pointer to FP
  type $214 = pointer to WorkerTaskDataRecord
  type $215 = pointer to FP
  procedure createWorker_apply(me: $208; work: $209; word: $210):$211
  var data: $212; fp: $213; i: int32; $216: int32; 
  begin
    ldloca_s 0
    ldarg_2
    castptr WorkerTaskDataRecord
    stind_ip
    ldloca_s 1
    ldarg_0
    castptr FP
    stind_ip
    if
      ldarg_1
      ldvar NO_WORK
      ceq
    then
      ldloc_1
      ldfld FP.s
      call Scheduler_markWaiting
      ret
    else
      if
        ldloc_0
        call WorkerTaskDataRecord_getDestination
        ldc_i4_2
        ceq
      then
        ldloc_0
        ldc_i4_3
        call WorkerTaskDataRecord_setDestination
      else
        ldloc_0
        ldc_i4_2
        call WorkerTaskDataRecord_setDestination
      end
      ldarg_1
      ldloc_0
      call WorkerTaskDataRecord_getDestination
      call Packet_setIdentity
      ldarg_1
      ldc_i4_0
      call Packet_setDatum
      ldloca_s 2
      ldc_i4_0
      stind_i4
      ldloca_s 3
      ldc_i4_3
      stind_i4
      while
        ldloc_2
        ldloc_3
        cgt
        ldc_i4_0
        ceq
      do
        ldloc_0
        ldloc_0
        call WorkerTaskDataRecord_getCount
        ldc_i4_1
        add
        call WorkerTaskDataRecord_setCount
        if
          ldloc_0
          call WorkerTaskDataRecord_getCount
          ldc_i4_s 26
          cgt
        then
          ldloc_0
          ldc_i4_1
          call WorkerTaskDataRecord_setCount
        end
        ldarg_1
        call Packet_getData
        ldloc_2
        ldelema int32
        ldc_i4_s 65
        ldloc_0
        call WorkerTaskDataRecord_getCount
        add
        ldc_i4_1
        sub
        stind_i4
        ldloca_s 2
        ldloc_2
        ldc_i4_1
        add
        stind_i4
      end
      ldloc_1
      ldfld FP.s
      ldarg_1
      call Scheduler_queuePacket
      ret
    end
  end createWorker_apply
  type $217 = pointer to Scheduler
  type $218 = pointer to Packet
  type $219 = pointer to TaskState
  type $220 = pointer to WorkerTaskDataRecord
  type $221 = pointer to FP
  type $222 = pointer to ProcessFunction
  procedure Scheduler_createWorker(me: $217; identity: int32; priority: int32; workPacket: $218; state: $219)
  var dataRecord: $220; fp: $221; 
  begin
    ldloca_s 0
    call WorkerTaskDataRecord_create
    stind_ip
    ldloca_s 1
    ldarg_0
    ldproc createWorker_apply
    call FP_create
    stind_ip
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
  end Scheduler_createWorker
  type $223 = pointer to Scheduler
  type $224 = pointer to Packet
  procedure Scheduler_start(me: $223):bool
  var workQ: $224; 
  begin
    ldloca_s 0
    ldnull
    stind_ip
    ldarg_0
    ldc_i4_0
    ldc_i4_0
    ldvar NO_WORK
    call TaskState_createRunning
    call Scheduler_createIdler
    ldloca_s 0
    ldarg_0
    ldvar NO_WORK
    ldc_i4_1
    ldc_i4_1
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_1
    ldc_i4_1
    call Scheduler_createPacket
    stind_ip
    ldarg_0
    ldc_i4_1
    ldc_i4 1000
    ldloc_0
    call TaskState_createWaitingWithPacket
    call Scheduler_createWorker
    ldloca_s 0
    ldarg_0
    ldvar NO_WORK
    ldc_i4_4
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_4
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_4
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldarg_0
    ldc_i4_2
    ldc_i4 2000
    ldloc_0
    call TaskState_createWaitingWithPacket
    call Scheduler_createHandler
    ldloca_s 0
    ldarg_0
    ldvar NO_WORK
    ldc_i4_5
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_5
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_5
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldarg_0
    ldc_i4_3
    ldc_i4 3000
    ldloc_0
    call TaskState_createWaitingWithPacket
    call Scheduler_createHandler
    ldarg_0
    ldc_i4_4
    ldc_i4 4000
    ldvar NO_WORK
    call TaskState_createWaiting
    call Scheduler_createDevice
    ldarg_0
    ldc_i4_5
    ldc_i4 5000
    ldvar NO_WORK
    call TaskState_createWaiting
    call Scheduler_createDevice
    ldarg_0
    call Scheduler_schedule
    iif
      ldarg_0
      ldfld Scheduler.queuePacketCount
      ldc_i4 23246
      ceq
    then
      ldarg_0
      ldfld Scheduler.holdCount
      ldc_i4 9297
      ceq
    else
      ldc_i4_0
    end
    ret
  end Scheduler_start
  type $225 = pointer to Scheduler
  type $226 = pointer to TaskControlBlock
  type $227 = pointer to TaskControlBlock
  procedure Scheduler_findTask(me: $225; identity: int32):$226
  var t: $227; 
  begin
    ldloca_s 0
    ldarg_0
    ldflda Scheduler.taskTable
    ldarg_1
    ldelem $17
    stind_ip
    if
      ldloc_0
      ldvar NO_TASK
      ceq
    then
      ldc_i4_0
      ldc_i4 759
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Richards.mic"
      call $MIC!assert
    end
    ldloc_0
    ret
  end Scheduler_findTask
  type $228 = pointer to Scheduler
  type $229 = pointer to TaskControlBlock
  type $230 = pointer to TaskState
  procedure Scheduler_holdSelf(me: $228):$229
  begin
    ldarg_0
    ldflda Scheduler.holdCount
    ldarg_0
    ldfld Scheduler.holdCount
    ldc_i4_1
    add
    stind_i4
    ldarg_0
    ldfld Scheduler.currentTask
    ldflda TaskControlBlock.base
    ldc_i4_1
    call TaskState_setTaskHolding
    ldarg_0
    ldfld Scheduler.currentTask
    call TaskControlBlock_getLink
    ret
  end Scheduler_holdSelf
  type $231 = pointer to Scheduler
  type $232 = pointer to Packet
  type $233 = pointer to TaskControlBlock
  type $234 = pointer to TaskControlBlock
  procedure Scheduler_queuePacket(me: $231; packet: $232):$233
  var t: $234; 
  begin
    ldloca_s 0
    ldarg_0
    ldarg_1
    call Packet_getIdentity
    call Scheduler_findTask
    stind_ip
    if
      ldloc_0
      ldvar NO_TASK
      ceq
    then
      ldvar NO_TASK
      ret
    end
    ldarg_0
    ldflda Scheduler.queuePacketCount
    ldarg_0
    ldfld Scheduler.queuePacketCount
    ldc_i4_1
    add
    stind_i4
    ldarg_1
    ldvar NO_WORK
    call Packet_setLink
    ldarg_1
    ldarg_0
    ldfld Scheduler.currentTaskIdentity
    call Packet_setIdentity
    ldloc_0
    ldarg_1
    ldarg_0
    ldfld Scheduler.currentTask
    call TaskControlBlock_addInputAndCheckPriority
    ret
  end Scheduler_queuePacket
  type $235* = pointer to Scheduler
  type $236 = pointer to TaskControlBlock
  type $237 = pointer to TaskControlBlock
  type $238 = pointer to TaskState
  procedure Scheduler_release(me: $235; identity: int32):$236
  var t: $237; 
  begin
    ldloca_s 0
    ldarg_0
    ldarg_1
    call Scheduler_findTask
    stind_ip
    if
      ldloc_0
      ldvar NO_TASK
      ceq
    then
      ldvar NO_TASK
      ret
    end
    ldloc_0
    ldflda TaskControlBlock.base
    ldc_i4_0
    call TaskState_setTaskHolding
    if
      ldloc_0
      call TaskControlBlock_getPriority
      ldarg_0
      ldfld Scheduler.currentTask
      call TaskControlBlock_getPriority
      cgt
    then
      ldloc_0
      ret
    else
      ldarg_0
      ldfld Scheduler.currentTask
      ret
    end
  end Scheduler_release
  type $239 = pointer to Scheduler
  procedure Scheduler_trace(me: $239; id: int32)
  begin
    ldarg_0
    ldflda Scheduler.layout
    ldarg_0
    ldfld Scheduler.layout
    ldc_i4_1
    sub
    stind_i4
    if
      ldarg_0
      ldfld Scheduler.layout
      ldc_i4_0
      cgt
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldflda Scheduler.layout
      ldc_i4_s 50
      stind_i4
    end
    ldarg_1
    conv_i8
    call $MIC!printI8
  end Scheduler_trace
  type $240 = pointer to Scheduler
  type $241 = pointer to TaskControlBlock
  type $242 = pointer to TaskState
  procedure Scheduler_markWaiting(me: $240):$241
  begin
    ldarg_0
    ldfld Scheduler.currentTask
    ldflda TaskControlBlock.base
    ldc_i4_1
    call TaskState_setTaskWaiting
    ldarg_0
    ldfld Scheduler.currentTask
    ret
  end Scheduler_markWaiting
  type $243* = pointer to Scheduler
  type $244 = pointer to TaskControlBlock
  type $245 = pointer to TaskState
  procedure Scheduler_schedule(me: $243)
  var tmp: $244; 
  begin
    ldarg_0
    ldflda Scheduler.currentTask
    ldarg_0
    ldfld Scheduler.taskList
    stind_ip
    while
      ldarg_0
      ldfld Scheduler.currentTask
      ldvar NO_TASK
      ceq
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldfld Scheduler.currentTask
        ldflda TaskControlBlock.base
        call TaskState_isTaskHoldingOrWaiting
      then
        ldloca_s 0
        ldarg_0
        ldfld Scheduler.currentTask
        call TaskControlBlock_getLink
        stind_ip
        ldarg_0
        ldflda Scheduler.currentTask
        ldloc_0
        stind_ip
      else
        ldarg_0
        ldflda Scheduler.currentTaskIdentity
        ldarg_0
        ldfld Scheduler.currentTask
        call TaskControlBlock_getIdentity
        stind_i4
        if
          ldvar TRACING
        then
          ldarg_0
          ldarg_0
          ldfld Scheduler.currentTaskIdentity
          call Scheduler_trace
        end
        ldloca_s 0
        ldarg_0
        ldfld Scheduler.currentTask
        call TaskControlBlock_runTask
        stind_ip
        ldarg_0
        ldflda Scheduler.currentTask
        ldloc_0
        stind_ip
      end
    end
  end Scheduler_schedule
  type $246 = pointer to Benchmark!Benchmark
  type $247 = pointer to Scheduler
  type $248 = pointer to Scheduler
  procedure benchmark(me: $246):int32
  var s: Scheduler; res: bool; 
  begin
    ldloca_s 1
    ldc_i4_0
    stind_i1
    ldloca_s 0
    call Scheduler_init
    ldloca_s 1
    ldloca_s 0
    call Scheduler_start
    stind_i1
    ldvar toDelete
    call RBObject_delete
    ldvara toDelete
    ldnull
    stind_ip
    if
      ldloc_1
    then
      ldc_i4_1
      ret
    else
      ldc_i4_0
      ret
    end
  end benchmark
  type $249 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: $249; result: int32):bool
  begin
    ldarg_1
    ldc_i4_0
    ceq
    ldc_i4_0
    ceq
    ret
  end verifyResult
  type $250 = pointer to Benchmark!Benchmark
  type $251 = pointer to Benchmark!Benchmark
  procedure create():$250
  var bench: $251; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Richards

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Run
  import Benchmark
  import Input
  import Out
  import Bounce
  import Mandelbrot
  import Permute
  import List
  import Queens
  import Sieve
  import Storage
  import Towers
  import NBody
  import Richards
  type $1 = array of char
  type $2 = pointer to $1
  type $3 = pointer to Benchmark!Benchmark
  type Run* = struct 
    name*: $2
    benchmarkSuite*: $3
    numIterations*: int32
    innerIterations*: int32
    total*: int32
  end
  type $4 = array of char
  type $5 = pointer to $4
  type $6 = pointer to Benchmark!Benchmark
  procedure getSuiteFromName(name: $5):$6
  begin
    if
      ldarg_0
      ldstr "Bounce"
      ldc_i4_1
      call $MIC!relop1
    then
      call Bounce!create
      ret
    else
      if
        ldarg_0
        ldstr "Mandelbrot"
        ldc_i4_1
        call $MIC!relop1
      then
        call Mandelbrot!create
        ret
      else
        if
          ldarg_0
          ldstr "Permute"
          ldc_i4_1
          call $MIC!relop1
        then
          call Permute!create
          ret
        else
          if
            ldarg_0
            ldstr "List"
            ldc_i4_1
            call $MIC!relop1
          then
            call List!create
            ret
          else
            if
              ldarg_0
              ldstr "Queens"
              ldc_i4_1
              call $MIC!relop1
            then
              call Queens!create
              ret
            else
              if
                ldarg_0
                ldstr "Sieve"
                ldc_i4_1
                call $MIC!relop1
              then
                call Sieve!create
                ret
              else
                if
                  ldarg_0
                  ldstr "Storage"
                  ldc_i4_1
                  call $MIC!relop1
                then
                  call Storage!create
                  ret
                else
                  if
                    ldarg_0
                    ldstr "Towers"
                    ldc_i4_1
                    call $MIC!relop1
                  then
                    call Towers!create
                    ret
                  else
                    if
                      ldarg_0
                      ldstr "NBody"
                      ldc_i4_1
                      call $MIC!relop1
                    then
                      call NBody!create
                      ret
                    else
                      if
                        ldarg_0
                        ldstr "Richards"
                        ldc_i4_1
                        call $MIC!relop1
                      then
                        call Richards!create
                        ret
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    ldnull
    ret
  end getSuiteFromName
  type $7 = pointer to Run
  type $8 = array of char
  type $9 = pointer to $8
  procedure init(me: $7; name: $9)
  begin
    ldarg_0
    ldflda Run.numIterations
    ldc_i4_1
    stind_i4
    ldarg_0
    ldflda Run.innerIterations
    ldc_i4_1
    stind_i4
    ldarg_0
    ldflda Run.total
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Run.name
    ldarg_1
    stind_ip
    ldarg_0
    ldflda Run.benchmarkSuite
    ldarg_1
    call getSuiteFromName
    stind_ip
  end init
  type $10 = pointer to Run
  procedure deinit(me: $10)
  begin
    if
      ldarg_0
      ldfld Run.benchmarkSuite
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      if
        ldarg_0
        ldfld Run.benchmarkSuite
        ldfld Benchmark!Benchmark.dispose
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld Run.benchmarkSuite
        ldarg_0
        ldfld Run.benchmarkSuite
        ldfld Benchmark!Benchmark.dispose
        calli Benchmark!$2
      end
      ldarg_0
      ldfld Run.benchmarkSuite
      free
    end
  end deinit
  type $11 = pointer to Run
  procedure printResult(me: $11; runTime: int32)
  begin
    ret
    ldarg_0
    ldfld Run.name
    call Out!String
    ldstr ": iterations=1 runtime: "
    call Out!String
    ldarg_1
    ldc_i4_0
    call Out!Int
    ldstr "us"
    call Out!String
    call Out!Ln
  end printResult
  type $12 = pointer to Run
  procedure printTotal(me: $12)
  begin
    ret
    ldstr "Total Runtime: "
    call Out!String
    ldarg_0
    ldfld Run.total
    ldc_i4_0
    call Out!Int
    ldstr "us"
    call Out!String
    call Out!Ln
  end printTotal
  type $13 = pointer to Run
  type $14 = pointer to Benchmark!Benchmark
  type $15 = pointer to Benchmark!Benchmark
  type $16 = proc(me: $15; innerIterations: int32):bool
  procedure measure(me: $13; bench: $14):bool
  var startTime: int32; endTime: int32; runTime: int32; innerBenchmarkLoop: $16; 
  begin
    ldloca_s 0
    call Input!Time
    stind_i4
    ldloca_s 3
    ldarg_1
    ldfld Benchmark!Benchmark.innerBenchmarkLoop
    stind_ip
    if
      ldloc_3
      ldnull
      ceq
    then
      ldloca_s 3
      ldproc Benchmark!innerBenchmarkLoop
      stind_ip
    end
    if
      ldarg_1
      ldarg_0
      ldfld Run.innerIterations
      ldloc_3
      calli $16
      ldc_i4_0
      ceq
    then
      ldc_i4_0
      ret
    end
    ldloca_s 1
    call Input!Time
    stind_i4
    ldloca_s 2
    ldloc_1
    ldloc_0
    sub
    stind_i4
    ldarg_0
    ldloc_2
    call printResult
    ldarg_0
    ldflda Run.total
    ldarg_0
    ldfld Run.total
    ldloc_2
    add
    stind_i4
    ldc_i4_1
    ret
  end measure
  type $17 = pointer to Run
  type $18 = pointer to Benchmark!Benchmark
  procedure doRuns(me: $17; bench: $18):bool
  var i: int32; $19: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldarg_0
    ldfld Run.numIterations
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldarg_1
        call measure
        ldc_i4_0
        ceq
      then
        ldc_i4_0
        ret
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldc_i4_1
    ret
  end doRuns
  type $20 = pointer to Run
  procedure reportBenchmark(me: $20)
  begin
    ldarg_0
    ldfld Run.name
    call Out!String
    ldstr ": iterations="
    call Out!String
    ldarg_0
    ldfld Run.numIterations
    ldc_i4_0
    call Out!Int
    ldstr " average: "
    call Out!String
    ldarg_0
    ldfld Run.total
    ldarg_0
    ldfld Run.numIterations
    div
    ldc_i4_0
    call Out!Int
    ldstr "us total: "
    call Out!String
    ldarg_0
    ldfld Run.total
    ldc_i4_0
    call Out!Int
    ldstr "us"
    call Out!String
    call Out!Ln
  end reportBenchmark
  type $21 = pointer to Run
  procedure runBenchmark(me: $21)
  begin
    ldstr "Starting "
    call Out!String
    ldarg_0
    ldfld Run.name
    call Out!String
    ldstr " benchmark ..."
    call Out!String
    call Out!Ln
    if
      ldarg_0
      ldfld Run.benchmarkSuite
      ldnull
      ceq
    then
      ldstr "ERROR unknown benchmark "
      call Out!String
      ldarg_0
      ldfld Run.name
      call Out!String
      call Out!Ln
      ret
    end
    if
      ldarg_0
      ldarg_0
      ldfld Run.benchmarkSuite
      call doRuns
      ldc_i4_0
      ceq
    then
      ldstr "ERROR"
      call Out!String
      call Out!Ln
      ret
    end
    ldarg_0
    call reportBenchmark
    call Out!Ln
  end runBenchmark
  type $22 = pointer to Run
  procedure setNumIterations(me: $22; numIterations: int32)
  begin
    ldarg_0
    ldflda Run.numIterations
    ldarg_1
    stind_i4
  end setNumIterations
  type $23 = pointer to Run
  procedure setInnerIterations(me: $23; innerIterations: int32)
  begin
    ldarg_0
    ldflda Run.innerIterations
    ldarg_1
    stind_i4
  end setInnerIterations
end Run

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Interfaces$20
  type T = int32
  type Data = pointer to any
  type $1 = pointer to T
  type ValueIterator* = proc(value: $1; data: Data)
  type $2 = pointer to T
  type TestIterator* = proc(value: $2; data: Data):bool
  type $3 = pointer to T
  type CompareIterator* = proc(lhs: $3; rhs: $3; data: Data):int32
end Interfaces$20

// Generated by MicCompiler  on 2025-03-25T18:52:44

module Vector$19
  type T = int32
  import Interfaces$20
  type $1 = pointer to T
  type Equal* = proc(lhs: $1; rhs: $1):bool
  type $2 = array of T
  type $3 = pointer to $2
  type $4 = struct 
    firstIdx: int32
    lastIdx: int32
    length: int32
    storage: $3
  end
  type Vector* = pointer to $4
  type $5 = array of int32
  type $6 = pointer to $5
  procedure expand(me: Vector; newLength: int32)
  var i: int32; old: $6; $7: int32; 
  begin
    if
      ldarg_1
      ldarg_0
      ldfld $4.length
      cgt
      ldc_i4_0
      ceq
    then
      ret
    end
    if
      ldarg_1
      ldc_i4_0
      cgt
    then
      ldloca_s 1
      ldarg_0
      ldfld $4.storage
      stind_ip
      ldarg_0
      ldflda $4.storage
      ldarg_1
      newarr int32
      stind_ip
      if
        ldloc_1
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        ldloca_s 0
        ldc_i4_0
        stind_i4
        ldloca_s 2
        ldarg_0
        ldfld $4.length
        ldc_i4_1
        sub
        stind_i4
        while
          ldloc_0
          ldloc_2
          cgt
          ldc_i4_0
          ceq
        do
          ldarg_0
          ldfld $4.storage
          ldloc_0
          ldelema int32
          ldloc_1
          ldloc_0
          ldelem_i4
          stind_i4
          ldloca_s 0
          ldloc_0
          ldc_i4_1
          add
          stind_i4
        end
      end
    end
    ldarg_0
    ldflda $4.length
    ldarg_1
    stind_i4
  end expand
  procedure enlarge(me: Vector; idx: int32)
  var newLength: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld $4.length
    stind_i4
    while
      ldloc_0
      ldarg_1
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 0
      ldloc_0
      ldc_i4_2
      mul
      stind_i4
      ldloca_s 0
      ldloc_0
      ldc_i4_s 50
      add
      stind_i4
    end
    ldarg_0
    ldloc_0
    call expand
  end enlarge
  type $8 = pointer to int32
  type $9 = pointer to int32
  procedure at(me: Vector; idx: int32):$8
  begin
    if
      iif
        ldarg_1
        ldc_i4_0
        clt
      then
        ldc_i4_1
      else
        ldarg_1
        ldarg_0
        ldfld $4.length
        clt
        ldc_i4_0
        ceq
      end
    then
      ldc_i4_0
      ldc_i4_s 68
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
      call $MIC!assert
    end
    ldarg_0
    ldfld $4.storage
    ldarg_1
    ldelema int32
    ret
  end at
  type $10 = pointer to int32
  procedure atPut(me: Vector; idx: int32; val: $10)
  begin
    if
      ldarg_1
      ldarg_0
      ldfld $4.length
      clt
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldarg_1
      call enlarge
    end
    ldarg_0
    ldfld $4.storage
    ldarg_1
    ldelema int32
    ldarg_2
    stind_i4
    if
      ldarg_0
      ldfld $4.lastIdx
      ldarg_1
      ldc_i4_1
      add
      clt
    then
      ldarg_0
      ldflda $4.lastIdx
      ldarg_1
      ldc_i4_1
      add
      stind_i4
    end
  end atPut
  type $12 = pointer to int32
  procedure forEach(me: Vector; iter: Interfaces$20!ValueIterator; data: Interfaces$20!Data)
  var i: int32; $11: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld $4.firstIdx
    stind_i4
    ldloca_s 1
    ldarg_0
    ldfld $4.lastIdx
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldfld $4.storage
      ldloc_0
      ldelema int32
      ldarg_2
      ldarg_1
      calli Interfaces$20!ValueIterator
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
  end forEach
  type $14 = pointer to int32
  procedure hasSome(me: Vector; iter: Interfaces$20!TestIterator; data: Interfaces$20!Data):bool
  var i: int32; $13: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld $4.firstIdx
    stind_i4
    ldloca_s 1
    ldarg_0
    ldfld $4.lastIdx
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldfld $4.storage
        ldloc_0
        ldelema int32
        ldarg_2
        ldarg_1
        calli Interfaces$20!TestIterator
      then
        ldc_i4_1
        ret
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldc_i4_0
    ret
  end hasSome
  type $15 = array of T
  type $16 = pointer to $15
  type $17 = pointer to T
  type Remove_Iterator = struct 
    newArray: $16
    newLast: int32
    obj: $17
    found: bool
    eq: Equal
  end
  type $18 = pointer to int32
  type $19 = pointer to Remove_Iterator
  type $20 = pointer to Remove_Iterator
  procedure remove_iter(value: $18; data: Interfaces$20!Data)
  var me: $19; 
  begin
    ldloca_s 0
    ldarg_1
    castptr Remove_Iterator
    stind_ip
    if
      ldarg_0
      ldloc_0
      ldfld Remove_Iterator.obj
      ldloc_0
      ldfld Remove_Iterator.eq
      calli Equal
    then
      ldloc_0
      ldflda Remove_Iterator.found
      ldc_i4_1
      stind_i1
    else
      ldloc_0
      ldfld Remove_Iterator.newArray
      ldloc_0
      ldfld Remove_Iterator.newLast
      ldelema int32
      ldarg_0
      stind_i4
      ldloc_0
      ldflda Remove_Iterator.newLast
      dup
      ldind_i4
      ldc_i4_1
      add
      stind_i4
    end
  end remove_iter
  type $21 = pointer to int32
  type $22 = pointer to Remove_Iterator
  procedure remove(me: Vector; obj: $21; eq: Equal):bool
  var iter: Remove_Iterator; 
  begin
    if
      ldarg_0
      ldfld $4.length
      ldc_i4_0
      ceq
    then
      ldc_i4_0
      ret
    end
    ldloca_s 0
    ldflda Remove_Iterator.newArray
    ldarg_0
    ldfld $4.length
    newarr int32
    stind_ip
    ldloca_s 0
    ldflda Remove_Iterator.found
    ldc_i4_0
    stind_i1
    ldloca_s 0
    ldflda Remove_Iterator.obj
    ldarg_1
    stind_ip
    ldloca_s 0
    ldflda Remove_Iterator.newLast
    ldc_i4_0
    stind_i4
    ldloca_s 0
    ldflda Remove_Iterator.eq
    ldarg_2
    stind_ip
    ldarg_0
    ldproc remove_iter
    ldloca_s 0
    call forEach
    ldarg_0
    ldfld $4.storage
    free
    ldarg_0
    ldflda $4.storage
    ldloca_s 0
    ldfld Remove_Iterator.newArray
    stind_ip
    ldarg_0
    ldflda $4.lastIdx
    ldloca_s 0
    ldfld Remove_Iterator.newLast
    stind_i4
    ldarg_0
    ldflda $4.firstIdx
    ldc_i4_0
    stind_i4
    ldloca_s 0
    ldfld Remove_Iterator.found
    ret
  end remove
  type $23 = pointer to int32
  procedure append(me: Vector; elem: $23)
  begin
    if
      ldarg_0
      ldfld $4.lastIdx
      ldarg_0
      ldfld $4.length
      clt
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldarg_0
      ldfld $4.lastIdx
      call enlarge
    end
    ldarg_0
    ldfld $4.storage
    ldarg_0
    ldfld $4.lastIdx
    ldelema int32
    ldarg_1
    stind_i4
    ldarg_0
    ldflda $4.lastIdx
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
  end append
  procedure isEmpty(me: Vector):bool
  begin
    ldarg_0
    ldfld $4.lastIdx
    ldarg_0
    ldfld $4.firstIdx
    ceq
    ret
  end isEmpty
  type $24 = pointer to int32
  type $25 = pointer to int32
  procedure removeFirst(me: Vector):$24
  begin
    if
      ldarg_0
      call isEmpty
    then
      ldc_i4_0
      ldc_i4 164
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
      call $MIC!assert
    end
    ldarg_0
    ldflda $4.firstIdx
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    ldarg_0
    ldfld $4.storage
    ldarg_0
    ldfld $4.firstIdx
    ldc_i4_1
    sub
    ldelema int32
    ret
  end removeFirst
  procedure removeAll(me: Vector)
  begin
    ldarg_0
    ldflda $4.firstIdx
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda $4.lastIdx
    ldc_i4_0
    stind_i4
  end removeAll
  procedure size(me: Vector):int32
  begin
    ldarg_0
    ldfld $4.lastIdx
    ldarg_0
    ldfld $4.firstIdx
    sub
    ret
  end size
  procedure capacity(me: Vector):int32
  begin
    ldarg_0
    ldfld $4.length
    ret
  end capacity
  procedure create(len: int32):Vector
  var v: Vector; 
  begin
    ldloca_s 0
    newobj $4
    stind_ip
    ldloc_0
    ldflda $4.firstIdx
    ldc_i4_0
    stind_i4
    ldloc_0
    ldflda $4.lastIdx
    ldc_i4_0
    stind_i4
    ldloc_0
    ldflda $4.length
    ldc_i4_0
    stind_i4
    ldloc_0
    ldflda $4.storage
    ldnull
    stind_ip
    ldloc_0
    ldarg_0
    call expand
    ldloc_0
    ret
  end create
  procedure createDefault():Vector
  begin
    ldc_i4_0
    call create
    ret
  end createDefault
  procedure copy(in_: Vector):Vector
  var me: Vector; i: int32; $26: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld $4.length
    call create
    stind_ip
    ldloc_0
    ldflda $4.firstIdx
    ldarg_0
    ldfld $4.firstIdx
    stind_i4
    ldloc_0
    ldflda $4.lastIdx
    ldarg_0
    ldfld $4.lastIdx
    stind_i4
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldarg_0
    ldfld $4.length
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_1
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_0
      ldfld $4.storage
      ldloc_1
      ldelema int32
      ldarg_0
      ldfld $4.storage
      ldloc_1
      ldelem_i4
      stind_i4
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end copy
  procedure free(me: Vector)
  begin
    if
      ldarg_0
      ldnull
      ceq
    then
      ret
    end
    if
      ldarg_0
      ldfld $4.storage
    then
      ldarg_0
      ldfld $4.storage
      free
    end
    ldarg_0
    free
  end free
  type $27 = array of int32
  type $28 = pointer to $27
  procedure swap(storage: $28; i: int32; j: int32) inline 
  begin
    ldc_i4_0
    ldc_i4 228
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
    call $MIC!assert
  end swap
  type $29 = pointer to int32
  type $30 = pointer to int32
  type $31 = pointer to int32
  type $32 = pointer to int32
  type $33 = pointer to int32
  type $34 = pointer to int32
  procedure sort_imp(me: Vector; i: int32; j: int32; c: Interfaces$20!CompareIterator; data: Interfaces$20!Data)
  var n: int32; ij: int32; k: int32; l: int32; di: $29; dj: $29; tt: $29; dij: $29; 
  begin
    ldloca_s 0
    ldarg_2
    ldc_i4_1
    add
    ldarg_1
    sub
    stind_i4
    if
      ldloc_0
      ldc_i4_1
      cgt
      ldc_i4_0
      ceq
    then
      ret
    end
    ldloca_s 4
    ldarg_0
    ldfld $4.storage
    ldarg_1
    ldelema int32
    stind_ip
    ldloca_s 5
    ldarg_0
    ldfld $4.storage
    ldarg_2
    ldelema int32
    stind_ip
    if
      ldloc_s 4
      ldloc_s 5
      ldarg_s 4
      ldarg_3
      calli Interfaces$20!CompareIterator
      ldc_i4_0
      cgt
    then
      ldarg_0
      ldfld $4.storage
      ldarg_1
      ldarg_2
      call swap
      ldloca_s 6
      ldloc_s 4
      stind_ip
      ldloca_s 4
      ldloc_s 5
      stind_ip
      ldloca_s 5
      ldloc_s 6
      stind_ip
    end
    if
      ldloc_0
      ldc_i4_2
      cgt
    then
      ldloca_s 1
      ldarg_1
      ldarg_2
      add
      ldc_i4_2
      div
      stind_i4
      ldloca_s 7
      ldarg_0
      ldfld $4.storage
      ldloc_1
      ldelema int32
      stind_ip
      if
        ldloc_s 4
        ldloc_s 7
        ldarg_s 4
        ldarg_3
        calli Interfaces$20!CompareIterator
        ldc_i4_0
        cgt
        ldc_i4_0
        ceq
      then
        if
          ldloc_s 7
          ldloc_s 5
          ldarg_s 4
          ldarg_3
          calli Interfaces$20!CompareIterator
          ldc_i4_0
          cgt
        then
          ldarg_0
          ldfld $4.storage
          ldarg_2
          ldloc_1
          call swap
          ldloca_s 7
          ldloc_s 5
          stind_ip
        end
      else
        ldarg_0
        ldfld $4.storage
        ldarg_1
        ldloc_1
        call swap
        ldloca_s 7
        ldloc_s 4
        stind_ip
      end
      if
        ldloc_0
        ldc_i4_3
        cgt
      then
        ldloca_s 2
        ldarg_1
        stind_i4
        ldloca_s 3
        ldarg_2
        ldc_i4_1
        sub
        stind_i4
        loop
          while
            iif
              ldloc_2
              ldloc_3
              cgt
              ldc_i4_0
              ceq
            then
              ldloc_s 7
              ldarg_0
              ldfld $4.storage
              ldloc_3
              ldelema int32
              ldarg_s 4
              ldarg_3
              calli Interfaces$20!CompareIterator
              ldc_i4_0
              cgt
              ldc_i4_0
              ceq
            else
              ldc_i4_0
            end
          do
            ldloca_s 3
            dup
            ldind_i4
            ldc_i4_1
            sub
            stind_i4
          end
          ldloca_s 2
          dup
          ldind_i4
          ldc_i4_1
          add
          stind_i4
          while
            iif
              ldloc_2
              ldloc_3
              cgt
              ldc_i4_0
              ceq
            then
              ldarg_0
              ldfld $4.storage
              ldloc_2
              ldelema int32
              ldloc_s 7
              ldarg_s 4
              ldarg_3
              calli Interfaces$20!CompareIterator
              ldc_i4_0
              cgt
              ldc_i4_0
              ceq
            else
              ldc_i4_0
            end
          do
            ldloca_s 2
            dup
            ldind_i4
            ldc_i4_1
            add
            stind_i4
          end
          if
            ldloc_2
            ldloc_3
            cgt
          then
            exit
          end
          ldarg_0
          ldfld $4.storage
          ldloc_2
          ldloc_3
          call swap
        end
        ldarg_0
        ldarg_1
        ldloc_3
        ldarg_3
        ldarg_s 4
        call sort_imp
        ldarg_0
        ldloc_2
        ldarg_2
        ldarg_3
        ldarg_s 4
        call sort_imp
      end
    end
  end sort_imp
  procedure sort(me: Vector; c: Interfaces$20!CompareIterator; data: Interfaces$20!Data)
  begin
    if
      ldarg_0
      call size
      ldc_i4_0
      cgt
    then
      ldarg_0
      ldarg_0
      ldfld $4.firstIdx
      ldarg_0
      ldfld $4.lastIdx
      ldc_i4_1
      sub
      ldarg_1
      ldarg_2
      call sort_imp
    end
  end sort
end Vector$19
