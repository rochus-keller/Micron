// Generated by MicCompiler  on 2025-04-09T23:21:10

module Benchmark
  type _$1 = pointer to Benchmark
  type _$2 = proc(me: _$1)
  type _$3 = pointer to Benchmark
  type _$4 = proc(me: _$3):int32
  type _$5 = pointer to Benchmark
  type _$6 = proc(me: _$5; result: int32):bool
  type _$7 = pointer to Benchmark
  type _$8 = proc(me: _$7; innerIterations: int32):bool
  type Benchmark* = struct 
    dispose: _$2
    benchmark: _$4
    verifyResult: _$6
    innerBenchmarkLoop: _$8
  end
  type _$9 = pointer to Benchmark
  procedure innerBenchmarkLoop(me: _$9; innerIterations: int32):bool
  var i: int32; _$10: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldarg_1
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldarg_0
        ldarg_0
        ldfld Benchmark.benchmark
        calli _$4
        ldarg_0
        ldfld Benchmark.verifyResult
        calli _$6
        ldc_i4_0
        ceq
      then
        ldc_i4_0
        ret
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldc_i4_1
    ret
  end innerBenchmarkLoop
end Benchmark

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Input
  procedure Available():int32 extern 
  type _$1 = pointer to char
  procedure Read(ch: _$1) extern 
  type _$2 = pointer to uint32
  type _$3 = pointer to int32
  procedure Mouse(keys: _$2; x: _$3; y: _$3) extern 
  procedure SetMouseLimits(w: int32; h: int32) extern 
  procedure Time():int32 extern 
end Input

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Out
  procedure Open() extern 
  procedure Char(ch: char) extern 
  type _$1 = array of char
  type _$2 = pointer to _$1
  procedure String(str: _$2) extern 
  procedure Int(i: int64; n: int32) extern 
  procedure Real(x: float32; n: int32) extern 
  procedure LongReal(x: float64; n: int32) extern 
  procedure Ln() extern 
end Out

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Random
  var seed: uint32
  procedure reset()
  begin
    ldvara seed
    ldc_i4 74755
    stind_i4
  end reset
  procedure next():uint32
  begin
    ldvara seed
    ldvar seed
    ldc_i4 1309
    mul
    ldc_i4 13849
    add
    ldc_i4 65535
    and
    stind_i4
    ldvar seed
    ret
  end next
  procedure begin$() init 
  begin
    ldvara seed
    ldc_i4 74755
    stind_i4
  end begin$
end Random

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Bounce
  import Random
  import Benchmark
  type Ball = struct 
    x: int32
    y: int32
    xVel: int32
    yVel: int32
  end
  type _$1 = pointer to Ball
  procedure Ball_init(me: _$1)
  begin
    ldarg_0
    ldflda Ball.x
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Ball.y
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Ball.xVel
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Ball.yVel
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Ball.x
    call Random!next
    ldc_i4 500
    rem_un
    conv_i4
    stind_i4
    ldarg_0
    ldflda Ball.y
    call Random!next
    ldc_i4 500
    rem_un
    conv_i4
    stind_i4
    ldarg_0
    ldflda Ball.xVel
    call Random!next
    ldc_i4 300
    rem_un
    conv_i4
    ldc_i4 150
    sub
    stind_i4
    ldarg_0
    ldflda Ball.yVel
    call Random!next
    ldc_i4 300
    rem_un
    conv_i4
    ldc_i4 150
    sub
    stind_i4
  end Ball_init
  type _$2 = pointer to Ball
  procedure Ball_bounce(me: _$2):bool
  var bounced: bool; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda Ball.x
    ldarg_0
    ldfld Ball.x
    ldarg_0
    ldfld Ball.xVel
    add
    stind_i4
    ldarg_0
    ldflda Ball.y
    ldarg_0
    ldfld Ball.y
    ldarg_0
    ldfld Ball.yVel
    add
    stind_i4
    if
      ldarg_0
      ldfld Ball.x
      ldc_i4 500
      cgt
    then
      ldarg_0
      ldflda Ball.x
      ldc_i4 500
      stind_i4
      ldarg_0
      ldflda Ball.xVel
      ldc_i4_0
      ldarg_0
      ldfld Ball.xVel
      dup
      ldc_i4_0
      cgt
      ifgoto ABS$0
      neg
      label ABS$0
      sub
      stind_i4
      ldloca_s 0
      ldc_i4_1
      stind_i1
    end
    if
      ldarg_0
      ldfld Ball.x
      ldc_i4_0
      clt
    then
      ldarg_0
      ldflda Ball.x
      ldc_i4_0
      stind_i4
      ldarg_0
      ldflda Ball.xVel
      ldarg_0
      ldfld Ball.xVel
      dup
      ldc_i4_0
      cgt
      ifgoto ABS$1
      neg
      label ABS$1
      stind_i4
      ldloca_s 0
      ldc_i4_1
      stind_i1
    end
    if
      ldarg_0
      ldfld Ball.y
      ldc_i4 500
      cgt
    then
      ldarg_0
      ldflda Ball.y
      ldc_i4 500
      stind_i4
      ldarg_0
      ldflda Ball.yVel
      ldc_i4_0
      ldarg_0
      ldfld Ball.yVel
      dup
      ldc_i4_0
      cgt
      ifgoto ABS$2
      neg
      label ABS$2
      sub
      stind_i4
      ldloca_s 0
      ldc_i4_1
      stind_i1
    end
    if
      ldarg_0
      ldfld Ball.y
      ldc_i4_0
      clt
    then
      ldarg_0
      ldflda Ball.y
      ldc_i4_0
      stind_i4
      ldarg_0
      ldflda Ball.yVel
      ldarg_0
      ldfld Ball.yVel
      dup
      ldc_i4_0
      cgt
      ifgoto ABS$3
      neg
      label ABS$3
      stind_i4
      ldloca_s 0
      ldc_i4_1
      stind_i1
    end
    ldloc_0
    ret
  end Ball_bounce
  type _$3 = pointer to Benchmark!Benchmark
  type _$4 = array of Ball
  type _$5 = pointer to _$4
  type _$7 = pointer to Ball
  type _$10 = pointer to Ball
  procedure benchmark(me: _$3):int32
  var bounces: int32; i: int32; j: int32; balls: _$5; _$6: int32; _$8: int32; _$9: int32; 
  begin
    call Random!reset
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4_s 100
    newarr Ball
    stind_ip
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 4
    ldc_i4_s 99
    stind_i4
    while
      ldloc_1
      ldloc_s 4
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_3
      ldloc_1
      ldelema Ball
      call Ball_init
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 5
    ldc_i4_s 49
    stind_i4
    while
      ldloc_1
      ldloc_s 5
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 2
      ldc_i4_0
      stind_i4
      ldloca_s 6
      ldc_i4_s 99
      stind_i4
      while
        ldloc_2
        ldloc_s 6
        cgt
        ldc_i4_0
        ceq
      do
        if
          ldloc_3
          ldloc_2
          ldelema Ball
          call Ball_bounce
        then
          ldloca_s 0
          dup
          ldind_i4
          ldc_i4_1
          add
          stind_i4
        end
        ldloca_s 2
        ldloc_2
        ldc_i4_1
        add
        stind_i4
      end
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_3
    free
    ldloc_0
    ret
  end benchmark
  type _$11 = pointer to Benchmark!Benchmark
  procedure verifyResult(bench: _$11; result: int32):bool
  begin
    ldc_i4 1331
    ldarg_1
    ceq
    ret
  end verifyResult
  type _$12 = pointer to Benchmark!Benchmark
  type _$13 = pointer to Benchmark!Benchmark
  procedure create():_$12
  var bench: _$13; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Bounce

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Mandelbrot
  import Out
  import Benchmark
  procedure verifyResult2(result: int32; innerIterations: int32):bool
  begin
    if
      ldarg_1
      ldc_i4 500
      ceq
    then
      ldarg_0
      ldc_i4 191
      ceq
      ret
    end
    if
      ldarg_1
      ldc_i4 750
      ceq
    then
      ldarg_0
      ldc_i4_s 50
      ceq
      ret
    end
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      ldarg_0
      ldc_i4 128
      ceq
      ret
    end
    ldstr "No verification result for "
    call Out!String
    ldarg_1
    ldc_i4_0
    call Out!Int
    ldstr " found"
    call Out!String
    call Out!Ln
    ldstr "Result is: "
    call Out!String
    ldarg_0
    ldc_i4_0
    call Out!Int
    call Out!Ln
    ldc_i4_0
    ret
  end verifyResult2
  procedure mandelbrot(size: int32):int32
  var sum: int32; byteAcc: int32; bitNum: int32; y: int32; z: int32; x: int32; escape: int32; ci: float64; zr: float64; zrzr: float64; zi: float64; zizi: float64; cr: float64; notDone: bool; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4_0
    stind_i4
    while
      ldloc_3
      ldarg_0
      clt
    do
      ldloca_s 7
      ldc_r4 2
      ldloc_3
      ldarg_0
      div
      conv_r4
      mul
      ldc_r4 1
      sub
      conv_r8
      stind_r8
      ldloca_s 5
      ldc_i4_0
      stind_i4
      while
        ldloc_s 5
        ldarg_0
        clt
      do
        ldloca_s 8
        ldc_r4 0
        conv_r8
        stind_r8
        ldloca_s 9
        ldc_r4 0
        conv_r8
        stind_r8
        ldloca_s 10
        ldc_r4 0
        conv_r8
        stind_r8
        ldloca_s 11
        ldc_r4 0
        conv_r8
        stind_r8
        ldloca_s 12
        ldc_r4 2
        ldloc_s 5
        ldarg_0
        div
        conv_r4
        mul
        ldc_r4 1.5
        sub
        conv_r8
        stind_r8
        ldloca_s 4
        ldc_i4_0
        stind_i4
        ldloca_s 13
        ldc_i4_1
        stind_i1
        ldloca_s 6
        ldc_i4_0
        stind_i4
        while
          iif
            ldloc_s 13
          then
            ldloc_s 4
            ldc_i4_s 50
            clt
          else
            ldc_i4_0
          end
        do
          ldloca_s 8
          ldloc_s 9
          ldloc_s 11
          sub
          ldloc_s 12
          add
          stind_r8
          ldloca_s 10
          ldc_r8 2
          ldloc_s 8
          mul
          ldloc_s 10
          mul
          ldloc_s 7
          add
          stind_r8
          ldloca_s 9
          ldloc_s 8
          ldloc_s 8
          mul
          stind_r8
          ldloca_s 11
          ldloc_s 10
          ldloc_s 10
          mul
          stind_r8
          if
            ldloc_s 9
            ldloc_s 11
            add
            ldc_r8 4
            cgt
          then
            ldloca_s 13
            ldc_i4_0
            stind_i1
            ldloca_s 6
            ldc_i4_1
            stind_i4
          end
          ldloca_s 4
          dup
          ldind_i4
          ldc_i4_1
          add
          stind_i4
        end
        ldloca_s 1
        ldloc_1
        conv_u4
        ldc_i4_1
        shl
        conv_i4
        ldloc_s 6
        add
        stind_i4
        ldloca_s 2
        dup
        ldind_i4
        ldc_i4_1
        add
        stind_i4
        if
          ldloc_2
          ldc_i4_8
          ceq
        then
          ldloca_s 0
          ldloc_0
          conv_u4
          ldloc_1
          conv_u4
          xor
          conv_i4
          stind_i4
          ldloca_s 1
          ldc_i4_0
          stind_i4
          ldloca_s 2
          ldc_i4_0
          stind_i4
        else
          if
            ldloc_s 5
            ldarg_0
            ldc_i4_1
            sub
            ceq
          then
            ldloca_s 1
            ldloc_1
            conv_u4
            ldc_i4_8
            ldloc_2
            sub
            conv_u4
            shl
            conv_i4
            stind_i4
            ldloca_s 0
            ldloc_0
            conv_u4
            ldloc_1
            conv_u4
            xor
            conv_i4
            stind_i4
            ldloca_s 1
            ldc_i4_0
            stind_i4
            ldloca_s 2
            ldc_i4_0
            stind_i4
          end
        end
        ldloca_s 5
        dup
        ldind_i4
        ldc_i4_1
        add
        stind_i4
      end
      ldloca_s 3
      dup
      ldind_i4
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end mandelbrot
  type _$1 = pointer to Benchmark!Benchmark
  procedure innerBenchmarkLoop(bench: _$1; innerIterations: int32):bool
  begin
    ldarg_1
    call mandelbrot
    ldarg_1
    call verifyResult2
    ret
  end innerBenchmarkLoop
  type _$2 = pointer to Benchmark!Benchmark
  procedure benchmark(bench: _$2):int32
  begin
    ldc_i4_0
    ldc_i4 134
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Mandelbrot.mic"
    call MIC$!assert
  end benchmark
  type _$3 = pointer to Benchmark!Benchmark
  procedure verifyResult(bench: _$3; result: int32):bool
  begin
    ldc_i4_0
    ldc_i4 139
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Mandelbrot.mic"
    call MIC$!assert
  end verifyResult
  type _$4 = pointer to Benchmark!Benchmark
  type _$5 = pointer to Benchmark!Benchmark
  procedure create():_$4
  var bench: _$5; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldproc innerBenchmarkLoop
    stind_ip
    ldloc_0
    ret
  end create
end Mandelbrot

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Permute
  import Benchmark
  type _$1 = array of int32
  type _$2 = pointer to _$1
  type Permute = struct 
    base: Benchmark!Benchmark
    count: int32
    v: _$2
  end
  type _$3 = pointer to Permute
  procedure swap(me: _$3; i: int32; j: int32)
  var tmp: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld Permute.v
    ldarg_1
    ldelem_i4
    stind_i4
    ldarg_0
    ldfld Permute.v
    ldarg_1
    ldelema int32
    ldarg_0
    ldfld Permute.v
    ldarg_2
    ldelem_i4
    stind_i4
    ldarg_0
    ldfld Permute.v
    ldarg_2
    ldelema int32
    ldloc_0
    stind_i4
  end swap
  type _$4 = pointer to Permute
  procedure permute(me: _$4; n: int32)
  var n1: int32; i: int32; _$5: int32; 
  begin
    ldarg_0
    ldflda Permute.count
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    if
      ldarg_1
      ldc_i4_0
      ceq
      ldc_i4_0
      ceq
    then
      ldloca_s 0
      ldarg_1
      ldc_i4_1
      sub
      stind_i4
      ldarg_0
      ldloc_0
      call permute
      ldloca_s 1
      ldloc_0
      stind_i4
      ldloca_s 2
      ldc_i4_0
      stind_i4
      while
        ldloc_1
        ldloc_2
        clt
        ldc_i4_0
        ceq
      do
        ldarg_0
        ldloc_0
        ldloc_1
        call swap
        ldarg_0
        ldloc_0
        call permute
        ldarg_0
        ldloc_0
        ldloc_1
        call swap
        ldloca_s 1
        ldloc_1
        ldc_i4_m1
        add
        stind_i4
      end
    end
  end permute
  type _$6 = pointer to Benchmark!Benchmark
  type _$7 = pointer to Permute
  type _$8 = pointer to Permute
  procedure benchmark(me: _$6):int32
  var p: _$7; i: int32; 
  begin
    ldloca_s 0
    ldarg_0
    castptr Permute
    stind_ip
    ldloc_0
    ldflda Permute.count
    ldc_i4_0
    stind_i4
    ldloc_0
    ldflda Permute.v
    ldc_i4_6
    newarr int32
    stind_ip
    ldloc_0
    ldc_i4_6
    call permute
    ldloc_0
    ldfld Permute.v
    free
    ldloc_0
    ldfld Permute.count
    ret
  end benchmark
  type _$9 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$9; result: int32):bool
  begin
    ldarg_1
    ldc_i4 8660
    ceq
    ret
  end verifyResult
  type _$10 = pointer to Benchmark!Benchmark
  type _$11 = pointer to Permute
  procedure create():_$10
  var per: _$11; 
  begin
    ldloca_s 0
    newobj Permute
    stind_ip
    ldloc_0
    ldflda Permute.base
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Permute.base
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Permute.base
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Permute.base
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Permute

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Object
  type _$1 = pointer to Object
  type _$2 = proc(obj: _$1)
  type Object* = struct 
    deinit: _$2
    refCount: int32
  end
  type _$3 = pointer to Object
  type _$4 = pointer to Object
  type _$5 = proc(obj: _$4)
  procedure init(obj: _$3; deinitProc: _$5)
  begin
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldflda Object.deinit
      ldarg_1
      stind_ip
      ldarg_0
      ldflda Object.refCount
      ldc_i4_0
      stind_i4
    end
  end init
  type _$6 = pointer to Object
  procedure addRef(obj: _$6)
  begin
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldflda Object.refCount
      dup
      ldind_i4
      ldc_i4_1
      add
      stind_i4
    end
  end addRef
  type _$7 = pointer to Object
  procedure release(obj: _$7)
  begin
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldflda Object.refCount
      dup
      ldind_i4
      ldc_i4_1
      sub
      stind_i4
      if
        ldarg_0
        ldfld Object.refCount
        ldc_i4_0
        ceq
      then
        if
          ldarg_0
          ldfld Object.deinit
          ldnull
          ceq
          ldc_i4_0
          ceq
        then
          ldarg_0
          ldarg_0
          ldfld Object.deinit
          calli _$2
        end
        ldarg_0
        free
      end
    end
  end release
end Object

// Generated by MicCompiler  on 2025-04-09T23:21:10

module List
  import Object
  import Benchmark
  type _$1 = pointer to Element
  type Element = struct 
    base: Object!Object
    val: int32
    next: _$1
  end
  type _$2 = pointer to Element
  type _$3 = pointer to Element
  procedure Element_setNext(me: _$2; e: _$3)
  begin
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldfld Element.next
      call Object!release
    end
    ldarg_0
    ldflda Element.next
    ldarg_1
    stind_ip
  end Element_setNext
  type _$4 = pointer to Object!Object
  type _$5 = pointer to Element
  type _$6 = pointer to Element
  procedure Element_deinit(me: _$4)
  var elem: _$5; 
  begin
    ldloca_s 0
    ldarg_0
    castptr Element
    stind_ip
    ldloc_0
    ldnull
    call Element_setNext
  end Element_deinit
  type _$7 = pointer to Element
  type _$8 = pointer to Element
  type _$9 = pointer to Object!Object
  type _$10 = pointer to Object!Object
  procedure Element_create(v: int32):_$7
  var e: _$8; 
  begin
    ldloca_s 0
    newobj Element
    stind_ip
    ldloc_0
    ldflda Element.base
    ldproc Element_deinit
    call Object!init
    ldloc_0
    ldflda Element.base
    call Object!addRef
    ldloc_0
    ldflda Element.val
    ldarg_0
    stind_i4
    ldloc_0
    ldflda Element.next
    ldnull
    stind_ip
    ldloc_0
    ret
  end Element_create
  type _$11 = pointer to Element
  procedure Element_length(me: _$11):int32
  begin
    if
      ldarg_0
      ldfld Element.next
      ldnull
      ceq
    then
      ldc_i4_1
      ret
    else
      ldc_i4_1
      ldarg_0
      ldfld Element.next
      call Element_length
      add
      ret
    end
  end Element_length
  type _$12 = pointer to Element
  type _$13 = pointer to Element
  procedure Element_getNext(me: _$12):_$13
  begin
    ldarg_0
    ldfld Element.next
    ret
  end Element_getNext
  type _$14 = pointer to Element
  procedure Element_setVal(me: _$14; v: int32)
  begin
    ldarg_0
    ldflda Element.val
    ldarg_1
    stind_i4
  end Element_setVal
  type _$15 = pointer to Element
  procedure Element_getVal(me: _$15):int32
  begin
    ldarg_0
    ldfld Element.val
    ret
  end Element_getVal
  type _$16 = pointer to Element
  type _$17 = pointer to Element
  procedure makeList(length: int32):_$16
  var e: _$17; 
  begin
    if
      ldarg_0
      ldc_i4_0
      ceq
    then
      ldnull
      ret
    else
      ldloca_s 0
      ldarg_0
      call Element_create
      stind_ip
      ldloc_0
      ldarg_0
      ldc_i4_1
      sub
      call makeList
      call Element_setNext
      ldloc_0
      ret
    end
  end makeList
  type _$18 = pointer to Element
  type _$19 = pointer to Element
  procedure isShorterThan(x: _$18; y: _$18):bool
  var xTail: _$19; yTail: _$19; 
  begin
    ldloca_s 0
    ldarg_0
    stind_ip
    ldloca_s 1
    ldarg_1
    stind_ip
    while
      ldloc_1
      ldnull
      ceq
      ldc_i4_0
      ceq
    do
      if
        ldloc_0
        ldnull
        ceq
      then
        ldc_i4_1
        ret
      end
      ldloca_s 0
      ldloc_0
      call Element_getNext
      stind_ip
      ldloca_s 1
      ldloc_1
      call Element_getNext
      stind_ip
    end
    ldc_i4_0
    ret
  end isShorterThan
  type _$20 = pointer to Element
  type _$21 = pointer to Element
  type _$22 = pointer to Element
  type _$23 = pointer to Object!Object
  type _$24 = pointer to Object!Object
  type _$25 = pointer to Object!Object
  type _$26 = pointer to Object!Object
  procedure tail(x: _$20; y: _$20; z: _$20):_$21
  var xx: _$22; yy: _$22; zz: _$22; res: _$22; 
  begin
    if
      ldarg_1
      ldarg_0
      call isShorterThan
    then
      ldloca_s 0
      ldarg_0
      call Element_getNext
      ldarg_1
      ldarg_2
      call tail
      stind_ip
      ldloca_s 1
      ldarg_1
      call Element_getNext
      ldarg_2
      ldarg_0
      call tail
      stind_ip
      ldloca_s 2
      ldarg_2
      call Element_getNext
      ldarg_0
      ldarg_1
      call tail
      stind_ip
      ldloca_s 3
      ldloc_0
      ldloc_1
      ldloc_2
      call tail
      stind_ip
      ldloc_0
      ldflda Element.base
      call Object!release
      ldloc_1
      ldflda Element.base
      call Object!release
      ldloc_2
      ldflda Element.base
      call Object!release
    else
      ldloca_s 3
      ldarg_2
      stind_ip
      ldarg_2
      ldflda Element.base
      call Object!addRef
    end
    ldloc_3
    ret
  end tail
  type _$27 = pointer to Benchmark!Benchmark
  type _$28 = pointer to Element
  type _$29 = pointer to Object!Object
  type _$30 = pointer to Object!Object
  type _$31 = pointer to Object!Object
  type _$32 = pointer to Object!Object
  procedure benchmark(bench: _$27):int32
  var x: _$28; y: _$28; z: _$28; resultElem: _$28; res: int32; 
  begin
    ldloca_s 0
    ldc_i4_s 15
    call makeList
    stind_ip
    ldloca_s 1
    ldc_i4_s 10
    call makeList
    stind_ip
    ldloca_s 2
    ldc_i4_6
    call makeList
    stind_ip
    ldloca_s 3
    ldloc_0
    ldloc_1
    ldloc_2
    call tail
    stind_ip
    ldloca_s 4
    ldloc_3
    call Element_length
    stind_i4
    ldloc_3
    ldflda Element.base
    call Object!release
    ldloc_0
    ldflda Element.base
    call Object!release
    ldloc_1
    ldflda Element.base
    call Object!release
    ldloc_2
    ldflda Element.base
    call Object!release
    ldloc_s 4
    ret
  end benchmark
  type _$33 = pointer to Benchmark!Benchmark
  procedure verifyResult(bench: _$33; result: int32):bool
  begin
    ldc_i4_s 10
    ldarg_1
    ceq
    ret
  end verifyResult
  type _$34 = pointer to Benchmark!Benchmark
  type _$35 = pointer to Benchmark!Benchmark
  procedure create():_$34
  var bench: _$35; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end List

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Queens
  import Benchmark
  type _$1 = array of bool
  type BoolArray = pointer to _$1
  type _$2 = array of int32
  type IntArray = pointer to _$2
  type Queens = struct 
    base: Benchmark!Benchmark
    freeMaxs: BoolArray
    freeRows: BoolArray
    freeMins: BoolArray
    queenRows: IntArray
  end
  type _$3 = pointer to Queens
  procedure getRowColumn(me: _$3; r: int32; c: int32):bool
  begin
    iif
      iif
        ldarg_0
        ldfld Queens.freeRows
        ldarg_1
        ldelem bool
      then
        ldarg_0
        ldfld Queens.freeMaxs
        ldarg_2
        ldarg_1
        add
        ldelem bool
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld Queens.freeMins
      ldarg_2
      ldarg_1
      sub
      ldc_i4_7
      add
      ldelem bool
    else
      ldc_i4_0
    end
    ret
  end getRowColumn
  type _$4 = pointer to Queens
  procedure setRowColumn(me: _$4; r: int32; c: int32; v: bool)
  begin
    ldarg_0
    ldfld Queens.freeRows
    ldarg_1
    ldelema bool
    ldarg_3
    stind_i1
    ldarg_0
    ldfld Queens.freeMaxs
    ldarg_2
    ldarg_1
    add
    ldelema bool
    ldarg_3
    stind_i1
    ldarg_0
    ldfld Queens.freeMins
    ldarg_2
    ldarg_1
    sub
    ldc_i4_7
    add
    ldelema bool
    ldarg_3
    stind_i1
  end setRowColumn
  type _$5 = pointer to Queens
  procedure placeQueen(me: _$5; c: int32):bool
  var r: int32; _$6: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_7
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldloc_0
        ldarg_1
        call getRowColumn
      then
        ldarg_0
        ldfld Queens.queenRows
        ldloc_0
        ldelema int32
        ldarg_1
        stind_i4
        ldarg_0
        ldloc_0
        ldarg_1
        ldc_i4_0
        call setRowColumn
        if
          ldarg_1
          ldc_i4_7
          ceq
        then
          ldc_i4_1
          ret
        end
        if
          ldarg_0
          ldarg_1
          ldc_i4_1
          add
          call placeQueen
        then
          ldc_i4_1
          ret
        end
        ldarg_0
        ldloc_0
        ldarg_1
        ldc_i4_1
        call setRowColumn
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldc_i4_0
    ret
  end placeQueen
  type _$7 = pointer to Queens
  procedure queens(me: _$7):bool
  var i: int32; res: bool; _$8: int32; _$9: int32; 
  begin
    ldarg_0
    ldflda Queens.freeRows
    ldc_i4_8
    newarr bool
    stind_ip
    ldarg_0
    ldflda Queens.freeMaxs
    ldc_i4_s 16
    newarr bool
    stind_ip
    ldarg_0
    ldflda Queens.freeMins
    ldc_i4_s 16
    newarr bool
    stind_ip
    ldarg_0
    ldflda Queens.queenRows
    ldc_i4_8
    newarr int32
    stind_ip
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_7
    stind_i4
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldfld Queens.freeRows
      ldloc_0
      ldelema bool
      ldc_i4_1
      stind_i1
      ldarg_0
      ldfld Queens.queenRows
      ldloc_0
      ldelema int32
      ldc_i4_m1
      stind_i4
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4_s 15
    stind_i4
    while
      ldloc_0
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldfld Queens.freeMaxs
      ldloc_0
      ldelema bool
      ldc_i4_1
      stind_i1
      ldarg_0
      ldfld Queens.freeMins
      ldloc_0
      ldelema bool
      ldc_i4_1
      stind_i1
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 1
    ldarg_0
    ldc_i4_0
    call placeQueen
    stind_i1
    ldarg_0
    ldfld Queens.freeRows
    free
    ldarg_0
    ldfld Queens.freeMaxs
    free
    ldarg_0
    ldfld Queens.freeMins
    free
    ldarg_0
    ldfld Queens.queenRows
    free
    ldloc_1
    ret
  end queens
  type _$10 = pointer to Benchmark!Benchmark
  type _$12 = pointer to Queens
  procedure benchmark(me: _$10):int32
  var i: int32; resultBool: bool; _$11: int32; 
  begin
    ldloca_s 1
    ldc_i4_1
    stind_i1
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_s 9
    stind_i4
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 1
      iif
        ldloc_1
      then
        ldarg_0
        castptr Queens
        call queens
      else
        ldc_i4_0
      end
      stind_i1
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    if
      ldloc_1
    then
      ldc_i4_1
      ret
    else
      ldc_i4_0
      ret
    end
  end benchmark
  type _$13 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$13; result: int32):bool
  begin
    ldarg_1
    ldc_i4_0
    ceq
    ldc_i4_0
    ceq
    ret
  end verifyResult
  type _$14 = pointer to Queens
  type _$15 = pointer to Queens
  procedure create():_$14
  var q: _$15; 
  begin
    ldloca_s 0
    newobj Queens
    stind_ip
    ldloc_0
    ldflda Queens.base
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Queens.base
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Queens.base
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Queens.base
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Queens

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Sieve
  import Benchmark
  type _$1 = array of bool
  type _$2 = pointer to _$1
  procedure sieve(flags: _$2; size: int32):int32
  var primeCount: int32; i: int32; k: int32; _$3: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_2
    stind_i4
    ldloca_s 3
    ldarg_1
    stind_i4
    while
      ldloc_1
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldloc_1
        ldc_i4_1
        sub
        ldelem bool
      then
        ldloca_s 0
        dup
        ldind_i4
        ldc_i4_1
        add
        stind_i4
        ldloca_s 2
        ldloc_1
        ldloc_1
        add
        stind_i4
        while
          ldloc_2
          ldarg_1
          cgt
          ldc_i4_0
          ceq
        do
          ldarg_0
          ldloc_2
          ldc_i4_1
          sub
          ldelema bool
          ldc_i4_0
          stind_i1
          ldloca_s 2
          ldloc_2
          ldloc_1
          add
          stind_i4
        end
      end
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end sieve
  type _$4 = pointer to Benchmark!Benchmark
  type _$5 = array of bool
  type _$6 = pointer to _$5
  procedure benchmark(me: _$4):int32
  var i: int32; res: int32; flags: _$6; _$7: int32; 
  begin
    ldloca_s 2
    ldc_i4 5000
    newarr bool
    stind_ip
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4 4999
    stind_i4
    while
      ldloc_0
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_2
      ldloc_0
      ldelema bool
      ldc_i4_1
      stind_i1
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 1
    ldloc_2
    ldc_i4 5000
    call sieve
    stind_i4
    ldloc_2
    free
    ldloc_1
    ret
  end benchmark
  type _$8 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$8; result: int32):bool
  begin
    ldc_i4 669
    ldarg_1
    ceq
    ret
  end verifyResult
  type _$9 = pointer to Benchmark!Benchmark
  type _$10 = pointer to Benchmark!Benchmark
  procedure create():_$9
  var bench: _$10; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Sieve

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Storage
  import Random
  import Benchmark
  type Storage = struct 
    base: Benchmark!Benchmark
    count: int32
  end
  type _$1 = pointer to TreeArrayArray
  type TreeArray = struct 
    arr: _$1
    len: uint32
  end
  type TreeArrayArray = array of TreeArray
  type _$2 = pointer to TreeArray
  type _$4 = pointer to TreeArray
  procedure freeTree(ta: _$2)
  var i: int32; t: TreeArray; _$3: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldarg_0
    ldfld TreeArray.len
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 1
      ldarg_0
      ldfld TreeArray.arr
      ldloc_0
      ldelem TreeArray
      stind TreeArray
      ldloca_s 1
      call freeTree
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    if
      ldarg_0
      ldfld TreeArray.arr
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldfld TreeArray.arr
      free
    end
    ldarg_0
    ldflda TreeArray.len
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda TreeArray.arr
    ldnull
    stind_ip
  end freeTree
  type _$5 = pointer to Storage
  procedure buildTreeDepth(me: _$5; depth: int32):TreeArray
  var res: TreeArray; i: int32; _$6: int32; 
  begin
    ldarg_0
    ldflda Storage.count
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      ldloca_s 0
      ldflda TreeArray.len
      call Random!next
      ldc_i4_s 10
      rem_un
      ldc_i4_1
      add
      stind_i4
      ldloca_s 0
      ldflda TreeArray.arr
      ldloca_s 0
      ldfld TreeArray.len
      newarr TreeArray
      stind_ip
      ldloc_0
      ret
    else
      ldloca_s 0
      ldflda TreeArray.len
      ldc_i4_4
      stind_i4
      ldloca_s 0
      ldflda TreeArray.arr
      ldloca_s 0
      ldfld TreeArray.len
      newarr TreeArray
      stind_ip
      ldloca_s 1
      ldc_i4_0
      stind_i4
      ldloca_s 2
      ldloca_s 0
      ldfld TreeArray.len
      ldc_i4_1
      sub
      stind_i4
      while
        ldloc_1
        ldloc_2
        cgt
        ldc_i4_0
        ceq
      do
        ldloca_s 0
        ldfld TreeArray.arr
        ldloc_1
        ldelema TreeArray
        ldarg_0
        ldarg_1
        ldc_i4_1
        sub
        call buildTreeDepth
        stind TreeArray
        ldloca_s 1
        ldloc_1
        ldc_i4_1
        add
        stind_i4
      end
      ldloc_0
      ret
    end
  end buildTreeDepth
  type _$7 = pointer to Benchmark!Benchmark
  type _$8 = pointer to Storage
  type _$9 = pointer to Storage
  type _$10 = pointer to TreeArray
  procedure benchmark(me: _$7):int32
  var s: _$8; arr: TreeArray; 
  begin
    ldloca_s 0
    ldarg_0
    castptr Storage
    stind_ip
    call Random!reset
    ldloc_0
    ldflda Storage.count
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldloc_0
    ldc_i4_7
    call buildTreeDepth
    stind TreeArray
    ldloca_s 1
    call freeTree
    ldloc_0
    ldfld Storage.count
    ret
  end benchmark
  type _$11 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$11; result: int32):bool
  begin
    ldc_i4 5461
    ldarg_1
    ceq
    ret
  end verifyResult
  type _$12 = pointer to Benchmark!Benchmark
  type _$13 = pointer to Storage
  procedure create():_$12
  var s: _$13; 
  begin
    ldloca_s 0
    newobj Storage
    stind_ip
    ldloc_0
    ldflda Storage.base
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Storage.base
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Storage.base
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Storage.base
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Storage

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Towers
  import Benchmark
  type _$1 = pointer to TowersDisk
  type TowersDisk = struct 
    size: int32
    next: _$1
  end
  type _$2 = pointer to TowersDisk
  type _$3 = array 3 of _$2
  type Towers = struct 
    base: Benchmark!Benchmark
    piles: _$3
    movesDone: int32
  end
  type _$4 = pointer to TowersDisk
  procedure TowersDisk_dispose(me: _$4)
  begin
    if
      ldarg_0
      ldfld TowersDisk.next
    then
      ldarg_0
      ldfld TowersDisk.next
      call TowersDisk_dispose
    end
    ldarg_0
    free
  end TowersDisk_dispose
  type _$5 = pointer to TowersDisk
  type _$6 = pointer to TowersDisk
  procedure TowersDisk_create(size: int32):_$5
  var d: _$6; 
  begin
    ldloca_s 0
    newobj TowersDisk
    stind_ip
    ldloc_0
    ldflda TowersDisk.next
    ldnull
    stind_ip
    ldloc_0
    ldflda TowersDisk.size
    ldarg_0
    stind_i4
    ldloc_0
    ret
  end TowersDisk_create
  type _$7 = pointer to TowersDisk
  procedure TowersDisk_getSize(me: _$7):int32
  begin
    ldarg_0
    ldfld TowersDisk.size
    ret
  end TowersDisk_getSize
  type _$8 = pointer to TowersDisk
  type _$9 = pointer to TowersDisk
  procedure TowersDisk_getNext(me: _$8):_$9
  begin
    ldarg_0
    ldfld TowersDisk.next
    ret
  end TowersDisk_getNext
  type _$10 = pointer to TowersDisk
  procedure TowersDisk_setNext(me: _$10; value: _$10)
  begin
    ldarg_0
    ldflda TowersDisk.next
    ldarg_1
    stind_ip
  end TowersDisk_setNext
  type _$11 = pointer to Towers
  type _$12 = pointer to TowersDisk
  type _$13 = pointer to TowersDisk
  procedure pushDisk(me: _$11; disk: _$12; pile: int32)
  var top: _$13; 
  begin
    ldloca_s 0
    ldarg_0
    ldflda Towers.piles
    ldarg_2
    ldelem _$2
    stind_ip
    if
      iif
        ldloc_0
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        ldarg_1
        call TowersDisk_getSize
        ldloc_0
        call TowersDisk_getSize
        clt
        ldc_i4_0
        ceq
      else
        ldc_i4_0
      end
    then
      ldc_i4_0
      ldc_i4_s 81
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Towers.mic"
      call MIC$!assert
    end
    ldarg_1
    ldloc_0
    call TowersDisk_setNext
    ldarg_0
    ldflda Towers.piles
    ldarg_2
    ldelema _$2
    ldarg_1
    stind_ip
  end pushDisk
  type _$14 = pointer to Towers
  type _$15 = pointer to TowersDisk
  type _$16 = pointer to TowersDisk
  procedure popDiskFrom(me: _$14; pile: int32):_$15
  var top: _$16; 
  begin
    ldloca_s 0
    ldarg_0
    ldflda Towers.piles
    ldarg_1
    ldelem _$2
    stind_ip
    if
      ldloc_0
      ldnull
      ceq
    then
      ldc_i4_0
      ldc_i4_s 92
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Towers.mic"
      call MIC$!assert
    end
    ldarg_0
    ldflda Towers.piles
    ldarg_1
    ldelema _$2
    ldloc_0
    call TowersDisk_getNext
    stind_ip
    ldloc_0
    ldnull
    call TowersDisk_setNext
    ldloc_0
    ret
  end popDiskFrom
  type _$17 = pointer to Towers
  procedure moveTopDisk(me: _$17; fromPile: int32; toPile: int32)
  begin
    ldarg_0
    ldarg_0
    ldarg_1
    call popDiskFrom
    ldarg_2
    call pushDisk
    ldarg_0
    ldflda Towers.movesDone
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
  end moveTopDisk
  type _$18 = pointer to Towers
  procedure buildTowerAt(me: _$18; pile: int32; disks: int32)
  var i: int32; _$19: int32; 
  begin
    ldloca_s 0
    ldarg_2
    stind_i4
    ldloca_s 1
    ldc_i4_0
    stind_i4
    while
      ldloc_0
      ldloc_1
      clt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldloc_0
      call TowersDisk_create
      ldarg_1
      call pushDisk
      ldloca_s 0
      ldloc_0
      ldc_i4_m1
      add
      stind_i4
    end
  end buildTowerAt
  type _$20 = pointer to Towers
  procedure moveDisks(me: _$20; disks: int32; fromPile: int32; toPile: int32)
  var otherPile: int32; 
  begin
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      ldarg_0
      ldarg_2
      ldarg_3
      call moveTopDisk
    else
      ldloca_s 0
      ldc_i4_3
      ldarg_2
      sub
      ldarg_3
      sub
      stind_i4
      ldarg_0
      ldarg_1
      ldc_i4_1
      sub
      ldarg_2
      ldloc_0
      call moveDisks
      ldarg_0
      ldarg_2
      ldarg_3
      call moveTopDisk
      ldarg_0
      ldarg_1
      ldc_i4_1
      sub
      ldloc_0
      ldarg_3
      call moveDisks
    end
  end moveDisks
  type _$21 = pointer to Benchmark!Benchmark
  type _$22 = pointer to Towers
  type _$23 = pointer to Towers
  procedure benchmark(b: _$21):int32
  var i: int32; me: _$22; _$24: int32; _$25: int32; 
  begin
    ldloca_s 1
    ldarg_0
    castptr Towers
    stind_ip
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_2
    stind_i4
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_1
      ldflda Towers.piles
      ldloc_0
      ldelema _$2
      ldnull
      stind_ip
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_1
    ldc_i4_0
    ldc_i4_s 13
    call buildTowerAt
    ldloc_1
    ldflda Towers.movesDone
    ldc_i4_0
    stind_i4
    ldloc_1
    ldc_i4_s 13
    ldc_i4_0
    ldc_i4_1
    call moveDisks
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 3
    ldc_i4_2
    stind_i4
    while
      ldloc_0
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldloc_1
        ldflda Towers.piles
        ldloc_0
        ldelem _$2
      then
        ldloc_1
        ldflda Towers.piles
        ldloc_0
        ldelem _$2
        call TowersDisk_dispose
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_1
    ldfld Towers.movesDone
    ret
  end benchmark
  type _$26 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$26; result: int32):bool
  begin
    ldc_i4 8191
    ldarg_1
    ceq
    ret
  end verifyResult
  type _$27 = pointer to Benchmark!Benchmark
  type _$28 = pointer to Towers
  procedure create():_$27
  var t: _$28; 
  begin
    ldloca_s 0
    newobj Towers
    stind_ip
    ldloc_0
    ldflda Towers.base
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Towers.base
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Towers.base
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Towers.base
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Towers

// Generated by MicCompiler  on 2025-04-09T23:21:10

module MathL
  procedure sqrt(x: float64):float64 extern 
  procedure power(x: float64; base: float64):float64 extern 
  procedure exp(x: float64):float64 extern 
  procedure ln(x: float64):float64 extern 
  procedure log(x: float64; base: float64):float64 extern 
  procedure round(x: float64):float64 extern 
  procedure sin(x: float64):float64 extern 
  procedure cos(x: float64):float64 extern 
  procedure tan(x: float64):float64 extern 
  procedure arcsin(x: float64):float64 extern 
  procedure arccos(x: float64):float64 extern 
  procedure arctan(x: float64):float64 extern 
  procedure arctan2(x: float64; y: float64):float64 extern 
  procedure sinh(x: float64):float64 extern 
  procedure cosh(x: float64):float64 extern 
  procedure tanh(x: float64):float64 extern 
  procedure arcsinh(x: float64):float64 extern 
  procedure arccosh(x: float64):float64 extern 
  procedure arctanh(x: float64):float64 extern 
end MathL

// Generated by MicCompiler  on 2025-04-09T23:21:10

module NBody
  import Benchmark
  import MathL
  type Body = struct 
    x: float64
    y: float64
    z: float64
    vx: float64
    vy: float64
    vz: float64
    mass: float64
  end
  type _$1 = array 5 of Body
  type NBodySystem = struct 
    bodies: _$1
  end
  type _$2 = pointer to Body
  procedure Body_getX(me: _$2):float64
  begin
    ldarg_0
    ldfld Body.x
    ret
  end Body_getX
  type _$3 = pointer to Body
  procedure Body_getY(me: _$3):float64
  begin
    ldarg_0
    ldfld Body.y
    ret
  end Body_getY
  type _$4 = pointer to Body
  procedure Body_getZ(me: _$4):float64
  begin
    ldarg_0
    ldfld Body.z
    ret
  end Body_getZ
  type _$5 = pointer to Body
  procedure Body_getVX(me: _$5):float64
  begin
    ldarg_0
    ldfld Body.vx
    ret
  end Body_getVX
  type _$6 = pointer to Body
  procedure Body_getVY(me: _$6):float64
  begin
    ldarg_0
    ldfld Body.vy
    ret
  end Body_getVY
  type _$7 = pointer to Body
  procedure Body_getVZ(me: _$7):float64
  begin
    ldarg_0
    ldfld Body.vz
    ret
  end Body_getVZ
  type _$8 = pointer to Body
  procedure Body_getMass(me: _$8):float64
  begin
    ldarg_0
    ldfld Body.mass
    ret
  end Body_getMass
  type _$9 = pointer to Body
  procedure Body_setX(me: _$9; x: float64)
  begin
    ldarg_0
    ldflda Body.x
    ldarg_1
    stind_r8
  end Body_setX
  type _$10 = pointer to Body
  procedure Body_setY(me: _$10; y: float64)
  begin
    ldarg_0
    ldflda Body.y
    ldarg_1
    stind_r8
  end Body_setY
  type _$11 = pointer to Body
  procedure Body_setZ(me: _$11; z: float64)
  begin
    ldarg_0
    ldflda Body.z
    ldarg_1
    stind_r8
  end Body_setZ
  type _$12 = pointer to Body
  procedure Body_setVX(me: _$12; vx: float64)
  begin
    ldarg_0
    ldflda Body.vx
    ldarg_1
    stind_r8
  end Body_setVX
  type _$13 = pointer to Body
  procedure Body_setVY(me: _$13; vy: float64)
  begin
    ldarg_0
    ldflda Body.vy
    ldarg_1
    stind_r8
  end Body_setVY
  type _$14 = pointer to Body
  procedure Body_setVZ(me: _$14; vz: float64)
  begin
    ldarg_0
    ldflda Body.vz
    ldarg_1
    stind_r8
  end Body_setVZ
  type _$15 = pointer to Body
  procedure Body_offsetMomentum(me: _$15; px: float64; py: float64; pz: float64)
  begin
    ldarg_0
    ldflda Body.vx
    ldc_r8 0
    ldarg_1
    ldc_r8 39.4784176043574
    div
    sub
    stind_r8
    ldarg_0
    ldflda Body.vy
    ldc_r8 0
    ldarg_2
    ldc_r8 39.4784176043574
    div
    sub
    stind_r8
    ldarg_0
    ldflda Body.vz
    ldc_r8 0
    ldarg_3
    ldc_r8 39.4784176043574
    div
    sub
    stind_r8
  end Body_offsetMomentum
  procedure Body_create(x: float64; y: float64; z: float64; vx: float64; vy: float64; vz: float64; mass: float64):Body
  var res: Body; 
  begin
    ldloca_s 0
    ldflda Body.x
    ldarg_0
    stind_r8
    ldloca_s 0
    ldflda Body.y
    ldarg_1
    stind_r8
    ldloca_s 0
    ldflda Body.z
    ldarg_2
    stind_r8
    ldloca_s 0
    ldflda Body.vx
    ldarg_3
    ldc_r8 365.24
    mul
    stind_r8
    ldloca_s 0
    ldflda Body.vy
    ldarg_s 4
    ldc_r8 365.24
    mul
    stind_r8
    ldloca_s 0
    ldflda Body.vz
    ldarg_s 5
    ldc_r8 365.24
    mul
    stind_r8
    ldloca_s 0
    ldflda Body.mass
    ldarg_s 6
    ldc_r8 39.4784176043574
    mul
    stind_r8
    ldloc_0
    ret
  end Body_create
  procedure Body_jupiter():Body
  begin
    ldc_r8 4.84143144246472
    ldc_r8 -1.16032004402743
    ldc_r8 -0.103622044471123
    ldc_r8 0.00166007664274404
    ldc_r8 0.0076990111841974
    ldc_r8 -6.90460016972063e-05
    ldc_r8 0.000954791938424327
    call Body_create
    ret
  end Body_jupiter
  procedure Body_saturn():Body
  begin
    ldc_r8 8.34336671824458
    ldc_r8 4.1247985641243
    ldc_r8 -0.403523417114321
    ldc_r8 -0.00276742510726862
    ldc_r8 0.00499852801234917
    ldc_r8 2.30417297573764e-05
    ldc_r8 0.000285885980666131
    call Body_create
    ret
  end Body_saturn
  procedure Body_uranus():Body
  begin
    ldc_r8 12.8943695621391
    ldc_r8 -15.1111514016986
    ldc_r8 -0.223307578892656
    ldc_r8 0.00296460137564762
    ldc_r8 0.00237847173959481
    ldc_r8 -2.96589568540238e-05
    ldc_r8 4.36624404335156e-05
    call Body_create
    ret
  end Body_uranus
  procedure Body_neptune():Body
  begin
    ldc_r8 15.3796971148509
    ldc_r8 -25.919314609988
    ldc_r8 0.179258772950371
    ldc_r8 0.00268067772490389
    ldc_r8 0.00162824170038242
    ldc_r8 -9.51592254519716e-05
    ldc_r8 5.15138902046611e-05
    call Body_create
    ret
  end Body_neptune
  procedure Body_sun():Body
  begin
    ldc_r4 0
    ldc_r4 0
    ldc_r4 0
    ldc_r4 0
    ldc_r4 0
    ldc_r4 0
    ldc_r4 1
    call Body_create
    ret
  end Body_sun
  type _$16 = pointer to Body
  procedure test(b: _$16)
  begin
    ldarg_0
    ldfld Body.mass
    call MIC$!printF8
    ldc_i4_s 10
    call MIC$!printCh
  end test
  type _$17 = pointer to NBodySystem
  type _$18 = pointer to Body
  type _$20 = pointer to Body
  type _$21 = pointer to Body
  procedure NBodySystem_init(me: _$17)
  var px: float64; py: float64; pz: float64; i: int32; b: _$18; tmp: float64; _$19: int32; 
  begin
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_0
    ldelema Body
    call Body_sun
    stind Body
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_1
    ldelema Body
    call Body_jupiter
    stind Body
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_2
    ldelema Body
    call Body_saturn
    stind Body
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_3
    ldelema Body
    call Body_uranus
    stind Body
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_4
    ldelema Body
    call Body_neptune
    stind Body
    ldloca_s 0
    ldc_r4 0
    conv_r8
    stind_r8
    ldloca_s 1
    ldc_r4 0
    conv_r8
    stind_r8
    ldloca_s 2
    ldc_r4 0
    conv_r8
    stind_r8
    ldloca_s 3
    ldc_i4_0
    stind_i4
    ldloca_s 6
    ldc_i4_4
    stind_i4
    while
      ldloc_3
      ldloc_s 6
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 4
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_3
      ldelema Body
      stind_ip
      ldloca_s 0
      ldloc_0
      ldloc_s 4
      call Body_getVX
      ldloc_s 4
      call Body_getMass
      mul
      add
      stind_r8
      ldloca_s 1
      ldloc_1
      ldloc_s 4
      call Body_getVY
      ldloc_s 4
      call Body_getMass
      mul
      add
      stind_r8
      ldloca_s 2
      ldloc_2
      ldloc_s 4
      call Body_getVZ
      ldloc_s 4
      call Body_getMass
      mul
      add
      stind_r8
      ldloca_s 3
      ldloc_3
      ldc_i4_1
      add
      stind_i4
    end
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_0
    ldelema Body
    ldloc_0
    ldloc_1
    ldloc_2
    call Body_offsetMomentum
  end NBodySystem_init
  type _$22 = pointer to NBodySystem
  type _$23 = pointer to Body
  type _$25 = pointer to Body
  type _$27 = pointer to Body
  type _$29 = pointer to Body
  procedure NBodySystem_advance(me: _$22; dt: float64)
  var i: int32; j: int32; iBody: _$23; jBody: _$23; dx: float64; dy: float64; dz: float64; dSquared: float64; distance: float64; mag: float64; _$24: int32; _$26: int32; _$28: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 10
    ldc_i4_4
    stind_i4
    while
      ldloc_0
      ldloc_s 10
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 2
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_0
      ldelema Body
      stind_ip
      ldloca_s 1
      ldloc_0
      ldc_i4_1
      add
      stind_i4
      ldloca_s 11
      ldc_i4_4
      stind_i4
      while
        ldloc_1
        ldloc_s 11
        cgt
        ldc_i4_0
        ceq
      do
        ldloca_s 3
        ldarg_0
        ldflda NBodySystem.bodies
        ldloc_1
        ldelema Body
        stind_ip
        ldloca_s 4
        ldloc_2
        call Body_getX
        ldloc_3
        call Body_getX
        sub
        stind_r8
        ldloca_s 5
        ldloc_2
        call Body_getY
        ldloc_3
        call Body_getY
        sub
        stind_r8
        ldloca_s 6
        ldloc_2
        call Body_getZ
        ldloc_3
        call Body_getZ
        sub
        stind_r8
        ldloca_s 7
        ldloc_s 4
        ldloc_s 4
        mul
        ldloc_s 5
        ldloc_s 5
        mul
        add
        ldloc_s 6
        ldloc_s 6
        mul
        add
        stind_r8
        ldloca_s 8
        ldloc_s 7
        call MathL!sqrt
        stind_r8
        ldloca_s 9
        ldarg_1
        ldloc_s 7
        ldloc_s 8
        mul
        div
        stind_r8
        ldloc_2
        ldloc_2
        call Body_getVX
        ldloc_s 4
        ldloc_3
        call Body_getMass
        mul
        ldloc_s 9
        mul
        sub
        call Body_setVX
        ldloc_2
        ldloc_2
        call Body_getVY
        ldloc_s 5
        ldloc_3
        call Body_getMass
        mul
        ldloc_s 9
        mul
        sub
        call Body_setVY
        ldloc_2
        ldloc_2
        call Body_getVZ
        ldloc_s 6
        ldloc_3
        call Body_getMass
        mul
        ldloc_s 9
        mul
        sub
        call Body_setVZ
        ldloc_3
        ldloc_3
        call Body_getVX
        ldloc_s 4
        ldloc_2
        call Body_getMass
        mul
        ldloc_s 9
        mul
        add
        call Body_setVX
        ldloc_3
        ldloc_3
        call Body_getVY
        ldloc_s 5
        ldloc_2
        call Body_getMass
        mul
        ldloc_s 9
        mul
        add
        call Body_setVY
        ldloc_3
        ldloc_3
        call Body_getVZ
        ldloc_s 6
        ldloc_2
        call Body_getMass
        mul
        ldloc_s 9
        mul
        add
        call Body_setVZ
        ldloca_s 1
        ldloc_1
        ldc_i4_1
        add
        stind_i4
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 12
    ldc_i4_4
    stind_i4
    while
      ldloc_0
      ldloc_s 12
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 2
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_0
      ldelema Body
      stind_ip
      ldloc_2
      ldloc_2
      call Body_getX
      ldarg_1
      ldloc_2
      call Body_getVX
      mul
      add
      call Body_setX
      ldloc_2
      ldloc_2
      call Body_getY
      ldarg_1
      ldloc_2
      call Body_getVY
      mul
      add
      call Body_setY
      ldloc_2
      ldloc_2
      call Body_getZ
      ldarg_1
      ldloc_2
      call Body_getVZ
      mul
      add
      call Body_setZ
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
  end NBodySystem_advance
  type _$30 = pointer to NBodySystem
  type _$31 = pointer to Body
  type _$33 = pointer to Body
  type _$35 = pointer to Body
  procedure NBodySystem_energy(me: _$30):float64
  var e: float64; i: int32; j: int32; iBody: _$31; jBody: _$31; dx: float64; dy: float64; dz: float64; distance: float64; _$32: int32; _$34: int32; 
  begin
    ldloca_s 0
    ldc_r4 0
    conv_r8
    stind_r8
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 9
    ldc_i4_4
    stind_i4
    while
      ldloc_1
      ldloc_s 9
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 3
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_1
      ldelema Body
      stind_ip
      ldloca_s 0
      ldloc_0
      ldc_r8 0.5
      ldloc_3
      call Body_getMass
      mul
      ldloc_3
      call Body_getVX
      ldloc_3
      call Body_getVX
      mul
      ldloc_3
      call Body_getVY
      ldloc_3
      call Body_getVY
      mul
      add
      ldloc_3
      call Body_getVZ
      ldloc_3
      call Body_getVZ
      mul
      add
      mul
      add
      stind_r8
      ldloca_s 2
      ldloc_1
      ldc_i4_1
      add
      stind_i4
      ldloca_s 10
      ldc_i4_4
      stind_i4
      while
        ldloc_2
        ldloc_s 10
        cgt
        ldc_i4_0
        ceq
      do
        ldloca_s 4
        ldarg_0
        ldflda NBodySystem.bodies
        ldloc_2
        ldelema Body
        stind_ip
        ldloca_s 5
        ldloc_3
        call Body_getX
        ldloc_s 4
        call Body_getX
        sub
        stind_r8
        ldloca_s 6
        ldloc_3
        call Body_getY
        ldloc_s 4
        call Body_getY
        sub
        stind_r8
        ldloca_s 7
        ldloc_3
        call Body_getZ
        ldloc_s 4
        call Body_getZ
        sub
        stind_r8
        ldloca_s 8
        ldloc_s 5
        ldloc_s 5
        mul
        ldloc_s 6
        ldloc_s 6
        mul
        add
        ldloc_s 7
        ldloc_s 7
        mul
        add
        call MathL!sqrt
        stind_r8
        ldloca_s 0
        ldloc_0
        ldloc_3
        call Body_getMass
        ldloc_s 4
        call Body_getMass
        mul
        ldloc_s 8
        div
        sub
        stind_r8
        ldloca_s 2
        ldloc_2
        ldc_i4_1
        add
        stind_i4
      end
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end NBodySystem_energy
  procedure verifyResult2(resultValue: float64; innerIterations: int32):bool
  begin
    if
      ldarg_1
      ldc_i4 250000
      ceq
    then
      ldarg_0
      dup
      ldc_r8 0
      cgt
      ifgoto ABS$4
      neg
      label ABS$4
      ldc_r8 0.169085988990931
      sub
      ldc_r8 5.0e-14
      clt
      ret
    end
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      ldarg_0
      dup
      ldc_r8 0
      cgt
      ifgoto ABS$5
      neg
      label ABS$5
      ldc_r8 0.169074954025067
      sub
      ldc_r8 5.0e-14
      clt
      ret
    end
    ldstr "No verification result for "
    call MIC$!printStr
    ldarg_1
    conv_i8
    call MIC$!printI8
    ldstr " found"
    call MIC$!printStr
    ldc_i4_s 10
    call MIC$!printCh
    ldstr "Result is: "
    call MIC$!printStr
    ldarg_0
    call MIC$!printF8
    ldc_i4_s 10
    call MIC$!printCh
    ldc_i4_0
    ret
  end verifyResult2
  type _$36 = pointer to Benchmark!Benchmark
  type _$37 = pointer to NBodySystem
  type _$39 = pointer to NBodySystem
  type _$40 = pointer to NBodySystem
  procedure innerBenchmarkLoop(me: _$36; innerIterations: int32):bool
  var system: NBodySystem; i: int32; _$38: int32; 
  begin
    ldloca_s 0
    call NBodySystem_init
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldarg_1
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_1
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 0
      ldc_r4 0.00999999977648258
      call NBodySystem_advance
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloca_s 0
    call NBodySystem_energy
    ldarg_1
    call verifyResult2
    ret
  end innerBenchmarkLoop
  type _$41 = pointer to Benchmark!Benchmark
  procedure benchmark(me: _$41):int32
  begin
    ldc_i4_0
    ldc_i4 295
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/NBody.mic"
    call MIC$!assert
    ldc_i4_0
    ret
  end benchmark
  type _$42 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$42; resultVal: int32):bool
  begin
    ldc_i4_0
    ldc_i4 301
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/NBody.mic"
    call MIC$!assert
    ldc_i4_0
    ret
  end verifyResult
  type _$43 = pointer to Benchmark!Benchmark
  type _$44 = pointer to Benchmark!Benchmark
  procedure create():_$43
  var bench: _$44; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldproc innerBenchmarkLoop
    stind_ip
    ldloc_0
    ret
  end create
end NBody

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Richards
  import Benchmark
  type _$1 = pointer to RBObject
  type RBObject = struct 
    next: _$1
  end
  type PacketData = array 4 of int32
  type _$2 = pointer to Packet
  type Packet = struct 
    base: RBObject
    link: _$2
    identity: int32
    kind: int32
    datum: int32
    data: PacketData
  end
  type TaskState = struct 
    base: RBObject
    packetPending: bool
    taskWaiting: bool
    taskHolding: bool
  end
  type _$3 = pointer to TaskControlBlock
  type _$4 = pointer to Packet
  type _$5 = pointer to ProcessFunction
  type _$6 = pointer to RBObject
  type TaskControlBlock = struct 
    base: TaskState
    link: _$3
    identity: int32
    priority: int32
    input: _$4
    procedure_: _$5
    handle: _$6
  end
  type _$7 = pointer to ProcessFunction
  type _$8 = pointer to Packet
  type _$9 = pointer to RBObject
  type _$10 = pointer to TaskControlBlock
  type _$11 = proc(me: _$7; work: _$8; word: _$9):_$10
  type ProcessFunction = struct 
    base: RBObject
    apply: _$11
  end
  type _$12 = pointer to Packet
  type DeviceTaskDataRecord = struct 
    base: RBObject
    pending: _$12
  end
  type _$13 = pointer to Packet
  type _$14 = pointer to Packet
  type HandlerTaskDataRecord = struct 
    base: RBObject
    workIn: _$13
    deviceIn: _$14
  end
  type IdleTaskDataRecord = struct 
    base: RBObject
    control: int32
    count: int32
  end
  type WorkerTaskDataRecord = struct 
    base: RBObject
    destination: int32
    count: int32
  end
  type _$15 = pointer to TaskControlBlock
  type _$16 = pointer to TaskControlBlock
  type _$17 = pointer to TaskControlBlock
  type _$18 = array 6 of _$17
  type Scheduler = struct 
    base: RBObject
    taskList: _$15
    currentTask: _$16
    currentTaskIdentity: int32
    taskTable: _$18
    queuePacketCount: int32
    holdCount: int32
    layout: int32
  end
  type _$19 = pointer to Scheduler
  type FP = struct 
    base: ProcessFunction
    s: _$19
  end
  type _$20 = pointer to Packet
  var NO_WORK: _$20
  type _$21 = pointer to TaskControlBlock
  var NO_TASK: _$21
  type _$22 = pointer to RBObject
  var toDelete: _$22
  var TRACING: bool
  type _$23 = pointer to Scheduler
  type _$24 = pointer to TaskControlBlock
  procedure Scheduler_markWaiting(me: _$23):_$24 forward 
  type _$25 = pointer to Scheduler
  type _$26 = pointer to Packet
  type _$27 = pointer to TaskControlBlock
  procedure Scheduler_queuePacket(me: _$25; packet: _$26):_$27 forward 
  type _$28 = pointer to Scheduler
  procedure Scheduler_trace(me: _$28; id: int32) forward 
  type _$29 = pointer to Scheduler
  type _$30 = pointer to TaskControlBlock
  procedure Scheduler_holdSelf(me: _$29):_$30 forward 
  type _$31 = pointer to Scheduler
  type _$32 = pointer to TaskControlBlock
  procedure Scheduler_release(me: _$31; identity: int32):_$32 forward 
  type _$33 = pointer to Scheduler
  procedure Scheduler_schedule(me: _$33) forward 
  type _$34 = pointer to RBObject
  procedure RBObject_init(o: _$34)
  begin
    ldarg_0
    ldflda RBObject.next
    ldvar toDelete
    stind_ip
    ldvara toDelete
    ldarg_0
    stind_ip
  end RBObject_init
  type _$35 = pointer to RBObject
  procedure RBObject_delete(o: _$35)
  begin
    if
      ldarg_0
      ldfld RBObject.next
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldfld RBObject.next
      call RBObject_delete
    end
    ldarg_0
    free
  end RBObject_delete
  type _$36 = pointer to Packet
  type _$37 = pointer to Packet
  type _$38 = pointer to Packet
  type _$39 = pointer to RBObject
  procedure Packet_create(link: _$36; identity: int32; kind: int32):_$37
  var me: _$38; i: int32; _$40: int32; 
  begin
    ldloca_s 0
    newobj Packet
    stind_ip
    ldloc_0
    ldflda Packet.base
    call RBObject_init
    ldloc_0
    ldflda Packet.link
    ldarg_0
    stind_ip
    ldloc_0
    ldflda Packet.identity
    ldarg_1
    stind_i4
    ldloc_0
    ldflda Packet.kind
    ldarg_2
    stind_i4
    ldloc_0
    ldflda Packet.datum
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldc_i4_3
    stind_i4
    while
      ldloc_1
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_0
      ldflda Packet.data
      ldloc_1
      ldelema int32
      ldc_i4_0
      stind_i4
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end Packet_create
  type _$41 = pointer to Packet
  type _$42 = pointer to PacketData
  type _$43 = pointer to PacketData
  procedure Packet_getData(me: _$41):_$42
  begin
    ldarg_0
    ldflda Packet.data
    ret
  end Packet_getData
  type _$44 = pointer to Packet
  procedure Packet_getDatum(me: _$44):int32
  begin
    ldarg_0
    ldfld Packet.datum
    ret
  end Packet_getDatum
  type _$45 = pointer to Packet
  procedure Packet_setDatum(me: _$45; someData: int32)
  begin
    ldarg_0
    ldflda Packet.datum
    ldarg_1
    stind_i4
  end Packet_setDatum
  type _$46 = pointer to Packet
  procedure Packet_getIdentity(me: _$46):int32
  begin
    ldarg_0
    ldfld Packet.identity
    ret
  end Packet_getIdentity
  type _$47 = pointer to Packet
  procedure Packet_setIdentity(me: _$47; anIdentity: int32)
  begin
    ldarg_0
    ldflda Packet.identity
    ldarg_1
    stind_i4
  end Packet_setIdentity
  type _$48 = pointer to Packet
  procedure Packet_getKind(me: _$48):int32
  begin
    ldarg_0
    ldfld Packet.kind
    ret
  end Packet_getKind
  type _$49 = pointer to Packet
  type _$50 = pointer to Packet
  procedure Packet_getLink(me: _$49):_$50
  begin
    ldarg_0
    ldfld Packet.link
    ret
  end Packet_getLink
  type _$51 = pointer to Packet
  type _$52 = pointer to Packet
  procedure Packet_setLink(me: _$51; aLink: _$52)
  begin
    ldarg_0
    ldflda Packet.link
    ldarg_1
    stind_ip
  end Packet_setLink
  type _$53 = pointer to Packet
  type _$54 = pointer to Packet
  type _$55 = pointer to Packet
  procedure RBObject_append(packet: _$53; queueHead: _$53):_$54
  var mouse: _$55; link: _$55; 
  begin
    ldarg_0
    ldvar NO_WORK
    call Packet_setLink
    if
      ldarg_1
      ldvar NO_WORK
      ceq
    then
      ldarg_0
      ret
    end
    ldloca_s 0
    ldarg_1
    stind_ip
    ldloca_s 1
    ldloc_0
    call Packet_getLink
    stind_ip
    while
      ldvar NO_WORK
      ldloc_1
      ceq
      ldc_i4_0
      ceq
    do
      ldloca_s 0
      ldloc_1
      stind_ip
      ldloca_s 1
      ldloc_0
      call Packet_getLink
      stind_ip
    end
    ldloc_0
    ldarg_0
    call Packet_setLink
    ldarg_1
    ret
  end RBObject_append
  type _$56 = pointer to TaskState
  type _$57 = pointer to RBObject
  procedure TaskState_init(me: _$56)
  begin
    ldarg_0
    ldflda TaskState.base
    call RBObject_init
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
  end TaskState_init
  type _$58 = pointer to TaskState
  type _$59 = pointer to TaskState
  procedure TaskState_create():_$58
  var me: _$59; 
  begin
    ldloca_s 0
    newobj TaskState
    stind_ip
    ldloc_0
    call TaskState_init
    ldloc_0
    ret
  end TaskState_create
  type _$60 = pointer to TaskState
  procedure TaskState_isPacketPending(me: _$60):bool
  begin
    ldarg_0
    ldfld TaskState.packetPending
    ret
  end TaskState_isPacketPending
  type _$61 = pointer to TaskState
  procedure TaskState_isTaskHolding(me: _$61):bool
  begin
    ldarg_0
    ldfld TaskState.taskHolding
    ret
  end TaskState_isTaskHolding
  type _$62 = pointer to TaskState
  procedure TaskState_isTaskWaiting(me: _$62):bool
  begin
    ldarg_0
    ldfld TaskState.taskWaiting
    ret
  end TaskState_isTaskWaiting
  type _$63 = pointer to TaskState
  procedure TaskState_setTaskHolding(me: _$63; b: bool)
  begin
    ldarg_0
    ldflda TaskState.taskHolding
    ldarg_1
    stind_i1
  end TaskState_setTaskHolding
  type _$64 = pointer to TaskState
  procedure TaskState_setTaskWaiting(me: _$64; b: bool)
  begin
    ldarg_0
    ldflda TaskState.taskWaiting
    ldarg_1
    stind_i1
  end TaskState_setTaskWaiting
  type _$65 = pointer to TaskState
  procedure TaskState_setPacketPending(me: _$65; b: bool)
  begin
    ldarg_0
    ldflda TaskState.packetPending
    ldarg_1
    stind_i1
  end TaskState_setPacketPending
  type _$66 = pointer to TaskState
  procedure TaskState_packetPending(me: _$66)
  begin
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_1
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
  end TaskState_packetPending
  type _$67 = pointer to TaskState
  procedure TaskState_running(me: _$67)
  begin
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
  end TaskState_running
  type _$68 = pointer to TaskState
  procedure TaskState_waiting(me: _$68)
  begin
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_1
    stind_i1
  end TaskState_waiting
  type _$69 = pointer to TaskState
  procedure TaskState_waitingWithPacket(me: _$69)
  begin
    ldarg_0
    ldflda TaskState.taskHolding
    ldc_i4_0
    stind_i1
    ldarg_0
    ldflda TaskState.taskWaiting
    ldc_i4_1
    stind_i1
    ldarg_0
    ldflda TaskState.packetPending
    ldc_i4_1
    stind_i1
  end TaskState_waitingWithPacket
  type _$70 = pointer to TaskState
  procedure TaskState_isRunning(me: _$70):bool
  begin
    iif
      iif
        ldarg_0
        ldfld TaskState.packetPending
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld TaskState.taskWaiting
        ldc_i4_0
        ceq
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld TaskState.taskHolding
      ldc_i4_0
      ceq
    else
      ldc_i4_0
    end
    ret
  end TaskState_isRunning
  type _$71 = pointer to TaskState
  procedure TaskState_isTaskHoldingOrWaiting(me: _$71):bool
  begin
    iif
      ldarg_0
      ldfld TaskState.taskHolding
    then
      ldc_i4_1
    else
      iif
        ldarg_0
        ldfld TaskState.packetPending
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld TaskState.taskWaiting
      else
        ldc_i4_0
      end
    end
    ret
  end TaskState_isTaskHoldingOrWaiting
  type _$72 = pointer to TaskState
  procedure TaskState_isWaiting(me: _$72):bool
  begin
    iif
      iif
        ldarg_0
        ldfld TaskState.packetPending
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld TaskState.taskWaiting
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld TaskState.taskHolding
      ldc_i4_0
      ceq
    else
      ldc_i4_0
    end
    ret
  end TaskState_isWaiting
  type _$73 = pointer to TaskState
  procedure TaskState_isWaitingWithPacket(me: _$73):bool
  begin
    iif
      iif
        ldarg_0
        ldfld TaskState.packetPending
      then
        ldarg_0
        ldfld TaskState.taskWaiting
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld TaskState.taskHolding
      ldc_i4_0
      ceq
    else
      ldc_i4_0
    end
    ret
  end TaskState_isWaitingWithPacket
  type _$74 = pointer to TaskState
  type _$75 = pointer to TaskState
  procedure TaskState_createPacketPending():_$74
  var t: _$75; 
  begin
    ldloca_s 0
    call TaskState_create
    stind_ip
    ldloc_0
    call TaskState_packetPending
    ldloc_0
    ret
  end TaskState_createPacketPending
  type _$76 = pointer to TaskState
  type _$77 = pointer to TaskState
  procedure TaskState_createRunning():_$76
  var t: _$77; 
  begin
    ldloca_s 0
    call TaskState_create
    stind_ip
    ldloc_0
    call TaskState_running
    ldloc_0
    ret
  end TaskState_createRunning
  type _$78 = pointer to TaskState
  type _$79 = pointer to TaskState
  procedure TaskState_createWaiting():_$78
  var t: _$79; 
  begin
    ldloca_s 0
    call TaskState_create
    stind_ip
    ldloc_0
    call TaskState_waiting
    ldloc_0
    ret
  end TaskState_createWaiting
  type _$80 = pointer to TaskState
  type _$81 = pointer to TaskState
  procedure TaskState_createWaitingWithPacket():_$80
  var t: _$81; 
  begin
    ldloca_s 0
    call TaskState_create
    stind_ip
    ldloc_0
    call TaskState_waitingWithPacket
    ldloc_0
    ret
  end TaskState_createWaitingWithPacket
  type _$82 = pointer to TaskControlBlock
  type _$83 = pointer to Packet
  type _$84 = pointer to TaskState
  type _$85 = pointer to ProcessFunction
  type _$86 = pointer to RBObject
  type _$87 = pointer to TaskControlBlock
  type _$88 = pointer to TaskControlBlock
  type _$89 = pointer to TaskState
  type _$90 = pointer to TaskState
  type _$91* = pointer to TaskState
  type _$92 = pointer to TaskState
  procedure TaskControlBlock_create(aLink: _$82; anIdentity: int32; aPriority: int32; anInitialWorkQueue: _$83; anInitialState: _$84; aBlock: _$85; aPrivateData: _$86):_$87
  var me: _$88; 
  begin
    ldloca_s 0
    newobj TaskControlBlock
    stind_ip
    ldloc_0
    ldflda TaskControlBlock.base
    call TaskState_init
    ldloc_0
    ldflda TaskControlBlock.link
    ldarg_0
    stind_ip
    ldloc_0
    ldflda TaskControlBlock.identity
    ldarg_1
    stind_i4
    ldloc_0
    ldflda TaskControlBlock.priority
    ldarg_2
    stind_i4
    ldloc_0
    ldflda TaskControlBlock.input
    ldarg_3
    stind_ip
    ldloc_0
    ldflda TaskControlBlock.base
    ldarg_s 4
    call TaskState_isPacketPending
    call TaskState_setPacketPending
    ldloc_0
    ldflda TaskControlBlock.base
    ldarg_s 4
    call TaskState_isTaskWaiting
    call TaskState_setTaskWaiting
    ldloc_0
    ldflda TaskControlBlock.base
    ldarg_s 4
    call TaskState_isTaskHolding
    call TaskState_setTaskHolding
    ldloc_0
    ldflda TaskControlBlock.procedure_
    ldarg_s 5
    stind_ip
    ldloc_0
    ldflda TaskControlBlock.handle
    ldarg_s 6
    stind_ip
    ldloc_0
    ret
  end TaskControlBlock_create
  type _$93 = pointer to TaskControlBlock
  procedure TaskControlBlock_getIdentity(me: _$93):int32
  begin
    ldarg_0
    ldfld TaskControlBlock.identity
    ret
  end TaskControlBlock_getIdentity
  type _$94 = pointer to TaskControlBlock
  type _$95 = pointer to TaskControlBlock
  procedure TaskControlBlock_getLink(me: _$94):_$95
  begin
    ldarg_0
    ldfld TaskControlBlock.link
    ret
  end TaskControlBlock_getLink
  type _$96 = pointer to TaskControlBlock
  procedure TaskControlBlock_getPriority(me: _$96):int32
  begin
    ldarg_0
    ldfld TaskControlBlock.priority
    ret
  end TaskControlBlock_getPriority
  type _$97 = pointer to TaskControlBlock
  type _$98 = pointer to Packet
  type _$99 = pointer to TaskControlBlock
  type _$100 = pointer to TaskControlBlock
  type _$101 = pointer to TaskState
  procedure TaskControlBlock_addInputAndCheckPriority(me: _$97; packet: _$98; oldTask: _$99):_$100
  begin
    if
      ldarg_0
      ldfld TaskControlBlock.input
      ldvar NO_WORK
      ceq
    then
      ldarg_0
      ldflda TaskControlBlock.input
      ldarg_1
      stind_ip
      ldarg_0
      ldflda TaskControlBlock.base
      ldc_i4_1
      call TaskState_setPacketPending
      if
        ldarg_0
        ldfld TaskControlBlock.priority
        ldarg_2
        call TaskControlBlock_getPriority
        cgt
      then
        ldarg_0
        ret
      end
    else
      ldarg_0
      ldflda TaskControlBlock.input
      ldarg_1
      ldarg_0
      ldfld TaskControlBlock.input
      call RBObject_append
      stind_ip
    end
    ldarg_2
    ret
  end TaskControlBlock_addInputAndCheckPriority
  type _$102 = pointer to TaskControlBlock
  type _$103 = pointer to TaskControlBlock
  type _$104 = pointer to Packet
  type _$105 = pointer to TaskState
  type _$106 = pointer to TaskState
  type _$107 = pointer to TaskState
  procedure TaskControlBlock_runTask(me: _$102):_$103
  var message: _$104; 
  begin
    if
      ldarg_0
      ldflda TaskControlBlock.base
      call TaskState_isWaitingWithPacket
    then
      ldloca_s 0
      ldarg_0
      ldfld TaskControlBlock.input
      stind_ip
      ldarg_0
      ldflda TaskControlBlock.input
      ldloc_0
      call Packet_getLink
      stind_ip
      if
        ldarg_0
        ldfld TaskControlBlock.input
        ldvar NO_WORK
        ceq
      then
        ldarg_0
        ldflda TaskControlBlock.base
        call TaskState_running
      else
        ldarg_0
        ldflda TaskControlBlock.base
        call TaskState_packetPending
      end
    else
      ldloca_s 0
      ldvar NO_WORK
      stind_ip
    end
    ldarg_0
    ldfld TaskControlBlock.procedure_
    ldloc_0
    ldarg_0
    ldfld TaskControlBlock.handle
    ldarg_0
    ldfld TaskControlBlock.procedure_
    ldfld ProcessFunction.apply
    calli _$11
    ret
  end TaskControlBlock_runTask
  type _$108 = pointer to DeviceTaskDataRecord
  type _$109 = pointer to DeviceTaskDataRecord
  type _$110 = pointer to RBObject
  procedure DeviceTaskDataRecord_create():_$108
  var me: _$109; 
  begin
    ldloca_s 0
    newobj DeviceTaskDataRecord
    stind_ip
    ldloc_0
    ldflda DeviceTaskDataRecord.base
    call RBObject_init
    ldloc_0
    ldflda DeviceTaskDataRecord.pending
    ldvar NO_WORK
    stind_ip
    ldloc_0
    ret
  end DeviceTaskDataRecord_create
  type _$111 = pointer to DeviceTaskDataRecord
  type _$112 = pointer to Packet
  procedure DeviceTaskDataRecord_getPending(me: _$111):_$112
  begin
    ldarg_0
    ldfld DeviceTaskDataRecord.pending
    ret
  end DeviceTaskDataRecord_getPending
  type _$113 = pointer to DeviceTaskDataRecord
  type _$114 = pointer to Packet
  procedure DeviceTaskDataRecord_setPending(me: _$113; packet: _$114)
  begin
    ldarg_0
    ldflda DeviceTaskDataRecord.pending
    ldarg_1
    stind_ip
  end DeviceTaskDataRecord_setPending
  type _$115 = pointer to HandlerTaskDataRecord
  type _$116 = pointer to HandlerTaskDataRecord
  type _$117 = pointer to RBObject
  procedure HandlerTaskDataRecord_create():_$115
  var me: _$116; 
  begin
    ldloca_s 0
    newobj HandlerTaskDataRecord
    stind_ip
    ldloc_0
    ldflda HandlerTaskDataRecord.base
    call RBObject_init
    ldloc_0
    ldflda HandlerTaskDataRecord.workIn
    ldvar NO_WORK
    stind_ip
    ldloc_0
    ldflda HandlerTaskDataRecord.deviceIn
    ldvar NO_WORK
    stind_ip
    ldloc_0
    ret
  end HandlerTaskDataRecord_create
  type _$118 = pointer to HandlerTaskDataRecord
  type _$119 = pointer to Packet
  procedure HandlerTaskDataRecord_deviceIn(me: _$118):_$119
  begin
    ldarg_0
    ldfld HandlerTaskDataRecord.deviceIn
    ret
  end HandlerTaskDataRecord_deviceIn
  type _$120 = pointer to HandlerTaskDataRecord
  type _$121 = pointer to Packet
  procedure HandlerTaskDataRecord_setDeviceIn(me: _$120; aPacket: _$121)
  begin
    ldarg_0
    ldflda HandlerTaskDataRecord.deviceIn
    ldarg_1
    stind_ip
  end HandlerTaskDataRecord_setDeviceIn
  type _$122 = pointer to HandlerTaskDataRecord
  type _$123 = pointer to Packet
  procedure HandlerTaskDataRecord_deviceInAdd(me: _$122; packet: _$123)
  begin
    ldarg_0
    ldflda HandlerTaskDataRecord.deviceIn
    ldarg_1
    ldarg_0
    ldfld HandlerTaskDataRecord.deviceIn
    call RBObject_append
    stind_ip
  end HandlerTaskDataRecord_deviceInAdd
  type _$124 = pointer to HandlerTaskDataRecord
  type _$125 = pointer to Packet
  procedure HandlerTaskDataRecord_workIn(me: _$124):_$125
  begin
    ldarg_0
    ldfld HandlerTaskDataRecord.workIn
    ret
  end HandlerTaskDataRecord_workIn
  type _$126 = pointer to HandlerTaskDataRecord
  type _$127 = pointer to Packet
  procedure HandlerTaskDataRecord_setWorkIn(me: _$126; aWorkQueue: _$127)
  begin
    ldarg_0
    ldflda HandlerTaskDataRecord.workIn
    ldarg_1
    stind_ip
  end HandlerTaskDataRecord_setWorkIn
  type _$128 = pointer to HandlerTaskDataRecord
  type _$129 = pointer to Packet
  procedure HandlerTaskDataRecord_workInAdd(me: _$128; packet: _$129)
  begin
    ldarg_0
    ldflda HandlerTaskDataRecord.workIn
    ldarg_1
    ldarg_0
    ldfld HandlerTaskDataRecord.workIn
    call RBObject_append
    stind_ip
  end HandlerTaskDataRecord_workInAdd
  type _$130 = pointer to IdleTaskDataRecord
  type _$131 = pointer to IdleTaskDataRecord
  type _$132 = pointer to RBObject
  procedure IdleTaskDataRecord_create():_$130
  var me: _$131; 
  begin
    ldloca_s 0
    newobj IdleTaskDataRecord
    stind_ip
    ldloc_0
    ldflda IdleTaskDataRecord.base
    call RBObject_init
    ldloc_0
    ldflda IdleTaskDataRecord.control
    ldc_i4_1
    stind_i4
    ldloc_0
    ldflda IdleTaskDataRecord.count
    ldc_i4 10000
    stind_i4
    ldloc_0
    ret
  end IdleTaskDataRecord_create
  type _$133 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_getControl(me: _$133):int32
  begin
    ldarg_0
    ldfld IdleTaskDataRecord.control
    ret
  end IdleTaskDataRecord_getControl
  type _$134 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_setControl(me: _$134; aNumber: int32)
  begin
    ldarg_0
    ldflda IdleTaskDataRecord.control
    ldarg_1
    stind_i4
  end IdleTaskDataRecord_setControl
  type _$135 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_getCount(me: _$135):int32
  begin
    ldarg_0
    ldfld IdleTaskDataRecord.count
    ret
  end IdleTaskDataRecord_getCount
  type _$136 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_setCount(me: _$136; aCount: int32)
  begin
    ldarg_0
    ldflda IdleTaskDataRecord.count
    ldarg_1
    stind_i4
  end IdleTaskDataRecord_setCount
  type _$137 = pointer to WorkerTaskDataRecord
  type _$138 = pointer to WorkerTaskDataRecord
  type _$139 = pointer to RBObject
  procedure WorkerTaskDataRecord_create():_$137
  var me: _$138; 
  begin
    ldloca_s 0
    newobj WorkerTaskDataRecord
    stind_ip
    ldloc_0
    ldflda WorkerTaskDataRecord.base
    call RBObject_init
    ldloc_0
    ldflda WorkerTaskDataRecord.destination
    ldc_i4_2
    stind_i4
    ldloc_0
    ldflda WorkerTaskDataRecord.count
    ldc_i4_0
    stind_i4
    ldloc_0
    ret
  end WorkerTaskDataRecord_create
  type _$140 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_getCount(me: _$140):int32
  begin
    ldarg_0
    ldfld WorkerTaskDataRecord.count
    ret
  end WorkerTaskDataRecord_getCount
  type _$141 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_setCount(me: _$141; aCount: int32)
  begin
    ldarg_0
    ldflda WorkerTaskDataRecord.count
    ldarg_1
    stind_i4
  end WorkerTaskDataRecord_setCount
  type _$142 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_getDestination(me: _$142):int32
  begin
    ldarg_0
    ldfld WorkerTaskDataRecord.destination
    ret
  end WorkerTaskDataRecord_getDestination
  type _$143 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_setDestination(me: _$143; aHandler: int32)
  begin
    ldarg_0
    ldflda WorkerTaskDataRecord.destination
    ldarg_1
    stind_i4
  end WorkerTaskDataRecord_setDestination
  type _$144 = pointer to Scheduler
  procedure Scheduler_init(me: _$144)
  var i: int32; _$145: int32; 
  begin
    ldarg_0
    ldflda Scheduler.layout
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Scheduler.currentTask
    ldnull
    stind_ip
    ldarg_0
    ldflda Scheduler.currentTaskIdentity
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Scheduler.queuePacketCount
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Scheduler.holdCount
    ldc_i4_0
    stind_i4
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldc_i4_5
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldflda Scheduler.taskTable
      ldloc_0
      ldelema _$17
      ldvar NO_TASK
      stind_ip
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldarg_0
    ldflda Scheduler.taskList
    ldvar NO_TASK
    stind_ip
  end Scheduler_init
  type _$146 = pointer to Scheduler
  type _$147 = pointer to ProcessFunction
  type _$148 = pointer to Packet
  type _$149 = pointer to RBObject
  type _$150 = pointer to TaskControlBlock
  type _$151 = proc(me: _$147; work: _$148; word: _$149):_$150
  type _$152 = pointer to FP
  type _$153 = pointer to FP
  type _$154 = pointer to ProcessFunction
  procedure FP_create(s: _$146; apply: _$151):_$152
  var me: _$153; 
  begin
    ldloca_s 0
    newobj FP
    stind_ip
    ldloc_0
    ldflda FP.base
    call RBObject_init
    ldloc_0
    ldflda FP.s
    ldarg_0
    stind_ip
    ldloc_0
    ldflda FP.base
    ldflda ProcessFunction.apply
    ldarg_1
    stind_ip
    ldloc_0
    ret
  end FP_create
  type _$155 = pointer to ProcessFunction
  type _$156 = pointer to Packet
  type _$157 = pointer to RBObject
  type _$158 = pointer to TaskControlBlock
  type _$159 = pointer to DeviceTaskDataRecord
  type _$160 = pointer to FP
  type _$161 = pointer to Packet
  type _$162 = pointer to DeviceTaskDataRecord
  type _$163 = pointer to FP
  procedure createDevice_apply(me: _$155; workArg: _$156; wordArg: _$157):_$158
  var dataRecord: _$159; fp: _$160; functionWork: _$161; 
  begin
    ldloca_s 0
    ldarg_2
    castptr DeviceTaskDataRecord
    stind_ip
    ldloca_s 1
    ldarg_0
    castptr FP
    stind_ip
    ldloca_s 2
    ldarg_1
    stind_ip
    if
      ldloc_2
      ldvar NO_WORK
      ceq
    then
      ldloca_s 2
      ldloc_0
      call DeviceTaskDataRecord_getPending
      stind_ip
      if
        ldvar NO_WORK
        ldloc_2
        ceq
      then
        ldloc_1
        ldfld FP.s
        call Scheduler_markWaiting
        ret
      else
        ldloc_0
        ldvar NO_WORK
        call DeviceTaskDataRecord_setPending
        ldloc_1
        ldfld FP.s
        ldloc_2
        call Scheduler_queuePacket
        ret
      end
    else
      ldloc_0
      ldloc_2
      call DeviceTaskDataRecord_setPending
      if
        ldvar TRACING
      then
        ldloc_1
        ldfld FP.s
        ldloc_2
        call Packet_getDatum
        call Scheduler_trace
      end
      ldloc_1
      ldfld FP.s
      call Scheduler_holdSelf
      ret
    end
  end createDevice_apply
  type _$164 = pointer to Scheduler
  type _$165 = pointer to Packet
  type _$166 = pointer to TaskState
  type _$167 = pointer to ProcessFunction
  type _$168 = pointer to RBObject
  type _$169 = pointer to TaskControlBlock
  procedure Scheduler_createTask(me: _$164; identity: int32; priority: int32; work: _$165; state: _$166; aBlock: _$167; data: _$168)
  var t: _$169; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld Scheduler.taskList
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldarg_s 5
    ldarg_s 6
    call TaskControlBlock_create
    stind_ip
    ldarg_0
    ldflda Scheduler.taskList
    ldloc_0
    stind_ip
    ldarg_0
    ldflda Scheduler.taskTable
    ldarg_1
    ldelema _$17
    ldloc_0
    stind_ip
  end Scheduler_createTask
  type _$170 = pointer to Scheduler
  type _$171 = pointer to Packet
  type _$172 = pointer to TaskState
  type _$173 = pointer to DeviceTaskDataRecord
  type _$174 = pointer to FP
  type _$175 = pointer to ProcessFunction
  procedure Scheduler_createDevice(me: _$170; identity: int32; priority: int32; workPacket: _$171; state: _$172)
  var data: _$173; fp: _$174; 
  begin
    ldloca_s 0
    call DeviceTaskDataRecord_create
    stind_ip
    ldloca_s 1
    ldarg_0
    ldproc createDevice_apply
    call FP_create
    stind_ip
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
  end Scheduler_createDevice
  type _$176 = pointer to ProcessFunction
  type _$177 = pointer to Packet
  type _$178 = pointer to RBObject
  type _$179 = pointer to TaskControlBlock
  type _$180 = pointer to HandlerTaskDataRecord
  type _$181 = pointer to FP
  type _$182 = pointer to Packet
  type _$183 = pointer to HandlerTaskDataRecord
  type _$184 = pointer to FP
  procedure createHandler_apply(me: _$176; work: _$177; word: _$178):_$179
  var dataRecord: _$180; fp: _$181; workPacket: _$182; devicePacket: _$182; count: int32; 
  begin
    ldloca_s 0
    ldarg_2
    castptr HandlerTaskDataRecord
    stind_ip
    ldloca_s 1
    ldarg_0
    castptr FP
    stind_ip
    if
      ldarg_1
      ldvar NO_WORK
      ceq
      ldc_i4_0
      ceq
    then
      if
        ldarg_1
        call Packet_getKind
        ldc_i4_1
        ceq
      then
        ldloc_0
        ldarg_1
        call HandlerTaskDataRecord_workInAdd
      else
        ldloc_0
        ldarg_1
        call HandlerTaskDataRecord_deviceInAdd
      end
    end
    ldloca_s 2
    ldloc_0
    call HandlerTaskDataRecord_workIn
    stind_ip
    if
      ldloc_2
      ldvar NO_WORK
      ceq
    then
      ldloc_1
      ldfld FP.s
      call Scheduler_markWaiting
      ret
    else
      ldloca_s 4
      ldloc_2
      call Packet_getDatum
      stind_i4
      if
        ldloc_s 4
        ldc_i4_4
        clt
        ldc_i4_0
        ceq
      then
        ldloc_0
        ldloc_2
        call Packet_getLink
        call HandlerTaskDataRecord_setWorkIn
        ldloc_1
        ldfld FP.s
        ldloc_2
        call Scheduler_queuePacket
        ret
      else
        ldloca_s 3
        ldloc_0
        call HandlerTaskDataRecord_deviceIn
        stind_ip
        if
          ldloc_3
          ldvar NO_WORK
          ceq
        then
          ldloc_1
          ldfld FP.s
          call Scheduler_markWaiting
          ret
        else
          ldloc_0
          ldloc_3
          call Packet_getLink
          call HandlerTaskDataRecord_setDeviceIn
          ldloc_3
          ldloc_2
          call Packet_getData
          ldloc_s 4
          ldelema int32
          call Packet_setDatum
          ldloc_2
          ldloc_s 4
          ldc_i4_1
          add
          call Packet_setDatum
          ldloc_1
          ldfld FP.s
          ldloc_3
          call Scheduler_queuePacket
          ret
        end
      end
    end
  end createHandler_apply
  type _$185 = pointer to Scheduler
  type _$186 = pointer to Packet
  type _$187 = pointer to TaskState
  type _$188 = pointer to HandlerTaskDataRecord
  type _$189 = pointer to FP
  type _$190 = pointer to ProcessFunction
  procedure Scheduler_createHandler(me: _$185; identity: int32; priority: int32; workPacket: _$186; state: _$187)
  var data: _$188; fp: _$189; 
  begin
    ldloca_s 0
    call HandlerTaskDataRecord_create
    stind_ip
    ldloca_s 1
    ldarg_0
    ldproc createHandler_apply
    call FP_create
    stind_ip
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
  end Scheduler_createHandler
  type _$191 = pointer to ProcessFunction
  type _$192 = pointer to Packet
  type _$193 = pointer to RBObject
  type _$194 = pointer to TaskControlBlock
  type _$195 = pointer to IdleTaskDataRecord
  type _$196 = pointer to FP
  type _$197 = pointer to IdleTaskDataRecord
  type _$198 = pointer to FP
  procedure createIdler_apply(me: _$191; workArg: _$192; wordArg: _$193):_$194
  var dataRecord: _$195; fp: _$196; 
  begin
    ldloca_s 0
    ldarg_2
    castptr IdleTaskDataRecord
    stind_ip
    ldloca_s 1
    ldarg_0
    castptr FP
    stind_ip
    ldloc_0
    ldloc_0
    call IdleTaskDataRecord_getCount
    ldc_i4_1
    sub
    call IdleTaskDataRecord_setCount
    if
      ldloc_0
      call IdleTaskDataRecord_getCount
      ldc_i4_0
      ceq
    then
      ldloc_1
      ldfld FP.s
      call Scheduler_holdSelf
      ret
    else
      if
        ldloc_0
        call IdleTaskDataRecord_getControl
        conv_u4
        ldc_i4_1
        and
        ldc_i4_0
        ceq
      then
        ldloc_0
        ldloc_0
        call IdleTaskDataRecord_getControl
        ldc_i4_2
        div
        call IdleTaskDataRecord_setControl
        ldloc_1
        ldfld FP.s
        ldc_i4_4
        call Scheduler_release
        ret
      else
        ldloc_0
        ldloc_0
        call IdleTaskDataRecord_getControl
        conv_u4
        ldc_i4_2
        div_un
        ldc_i4 53256
        xor
        conv_i4
        call IdleTaskDataRecord_setControl
        ldloc_1
        ldfld FP.s
        ldc_i4_5
        call Scheduler_release
        ret
      end
    end
  end createIdler_apply
  type _$199 = pointer to Scheduler
  type _$200 = pointer to Packet
  type _$201 = pointer to TaskState
  type _$202 = pointer to IdleTaskDataRecord
  type _$203 = pointer to FP
  type _$204 = pointer to ProcessFunction
  procedure Scheduler_createIdler(me: _$199; identity: int32; priority: int32; work: _$200; state: _$201)
  var data: _$202; fp: _$203; 
  begin
    ldloca_s 0
    call IdleTaskDataRecord_create
    stind_ip
    ldloca_s 1
    ldarg_0
    ldproc createIdler_apply
    call FP_create
    stind_ip
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
  end Scheduler_createIdler
  type _$205 = pointer to Scheduler
  type _$206 = pointer to Packet
  type _$207 = pointer to Packet
  procedure Scheduler_createPacket(me: _$205; link: _$206; identity: int32; kind: int32):_$207
  begin
    ldarg_1
    ldarg_2
    ldarg_3
    call Packet_create
    ret
  end Scheduler_createPacket
  type _$208 = pointer to ProcessFunction
  type _$209 = pointer to Packet
  type _$210 = pointer to RBObject
  type _$211 = pointer to TaskControlBlock
  type _$212 = pointer to WorkerTaskDataRecord
  type _$213 = pointer to FP
  type _$214 = pointer to WorkerTaskDataRecord
  type _$215 = pointer to FP
  procedure createWorker_apply(me: _$208; work: _$209; word: _$210):_$211
  var data: _$212; fp: _$213; i: int32; _$216: int32; 
  begin
    ldloca_s 0
    ldarg_2
    castptr WorkerTaskDataRecord
    stind_ip
    ldloca_s 1
    ldarg_0
    castptr FP
    stind_ip
    if
      ldarg_1
      ldvar NO_WORK
      ceq
    then
      ldloc_1
      ldfld FP.s
      call Scheduler_markWaiting
      ret
    else
      if
        ldloc_0
        call WorkerTaskDataRecord_getDestination
        ldc_i4_2
        ceq
      then
        ldloc_0
        ldc_i4_3
        call WorkerTaskDataRecord_setDestination
      else
        ldloc_0
        ldc_i4_2
        call WorkerTaskDataRecord_setDestination
      end
      ldarg_1
      ldloc_0
      call WorkerTaskDataRecord_getDestination
      call Packet_setIdentity
      ldarg_1
      ldc_i4_0
      call Packet_setDatum
      ldloca_s 2
      ldc_i4_0
      stind_i4
      ldloca_s 3
      ldc_i4_3
      stind_i4
      while
        ldloc_2
        ldloc_3
        cgt
        ldc_i4_0
        ceq
      do
        ldloc_0
        ldloc_0
        call WorkerTaskDataRecord_getCount
        ldc_i4_1
        add
        call WorkerTaskDataRecord_setCount
        if
          ldloc_0
          call WorkerTaskDataRecord_getCount
          ldc_i4_s 26
          cgt
        then
          ldloc_0
          ldc_i4_1
          call WorkerTaskDataRecord_setCount
        end
        ldarg_1
        call Packet_getData
        ldloc_2
        ldelema int32
        ldc_i4_s 65
        ldloc_0
        call WorkerTaskDataRecord_getCount
        add
        ldc_i4_1
        sub
        stind_i4
        ldloca_s 2
        ldloc_2
        ldc_i4_1
        add
        stind_i4
      end
      ldloc_1
      ldfld FP.s
      ldarg_1
      call Scheduler_queuePacket
      ret
    end
  end createWorker_apply
  type _$217 = pointer to Scheduler
  type _$218 = pointer to Packet
  type _$219 = pointer to TaskState
  type _$220 = pointer to WorkerTaskDataRecord
  type _$221 = pointer to FP
  type _$222 = pointer to ProcessFunction
  procedure Scheduler_createWorker(me: _$217; identity: int32; priority: int32; workPacket: _$218; state: _$219)
  var dataRecord: _$220; fp: _$221; 
  begin
    ldloca_s 0
    call WorkerTaskDataRecord_create
    stind_ip
    ldloca_s 1
    ldarg_0
    ldproc createWorker_apply
    call FP_create
    stind_ip
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
  end Scheduler_createWorker
  type _$223 = pointer to Scheduler
  type _$224 = pointer to Packet
  procedure Scheduler_start(me: _$223):bool
  var workQ: _$224; 
  begin
    ldloca_s 0
    ldnull
    stind_ip
    ldarg_0
    ldc_i4_0
    ldc_i4_0
    ldvar NO_WORK
    call TaskState_createRunning
    call Scheduler_createIdler
    ldloca_s 0
    ldarg_0
    ldvar NO_WORK
    ldc_i4_1
    ldc_i4_1
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_1
    ldc_i4_1
    call Scheduler_createPacket
    stind_ip
    ldarg_0
    ldc_i4_1
    ldc_i4 1000
    ldloc_0
    call TaskState_createWaitingWithPacket
    call Scheduler_createWorker
    ldloca_s 0
    ldarg_0
    ldvar NO_WORK
    ldc_i4_4
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_4
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_4
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldarg_0
    ldc_i4_2
    ldc_i4 2000
    ldloc_0
    call TaskState_createWaitingWithPacket
    call Scheduler_createHandler
    ldloca_s 0
    ldarg_0
    ldvar NO_WORK
    ldc_i4_5
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_5
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldloca_s 0
    ldarg_0
    ldloc_0
    ldc_i4_5
    ldc_i4_0
    call Scheduler_createPacket
    stind_ip
    ldarg_0
    ldc_i4_3
    ldc_i4 3000
    ldloc_0
    call TaskState_createWaitingWithPacket
    call Scheduler_createHandler
    ldarg_0
    ldc_i4_4
    ldc_i4 4000
    ldvar NO_WORK
    call TaskState_createWaiting
    call Scheduler_createDevice
    ldarg_0
    ldc_i4_5
    ldc_i4 5000
    ldvar NO_WORK
    call TaskState_createWaiting
    call Scheduler_createDevice
    ldarg_0
    call Scheduler_schedule
    iif
      ldarg_0
      ldfld Scheduler.queuePacketCount
      ldc_i4 23246
      ceq
    then
      ldarg_0
      ldfld Scheduler.holdCount
      ldc_i4 9297
      ceq
    else
      ldc_i4_0
    end
    ret
  end Scheduler_start
  type _$225 = pointer to Scheduler
  type _$226 = pointer to TaskControlBlock
  type _$227 = pointer to TaskControlBlock
  procedure Scheduler_findTask(me: _$225; identity: int32):_$226
  var t: _$227; 
  begin
    ldloca_s 0
    ldarg_0
    ldflda Scheduler.taskTable
    ldarg_1
    ldelem _$17
    stind_ip
    if
      ldloc_0
      ldvar NO_TASK
      ceq
    then
      ldc_i4_0
      ldc_i4 759
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Richards.mic"
      call MIC$!assert
    end
    ldloc_0
    ret
  end Scheduler_findTask
  type _$228 = pointer to Scheduler
  type _$229 = pointer to TaskControlBlock
  type _$230 = pointer to TaskState
  procedure Scheduler_holdSelf(me: _$228):_$229
  begin
    ldarg_0
    ldflda Scheduler.holdCount
    ldarg_0
    ldfld Scheduler.holdCount
    ldc_i4_1
    add
    stind_i4
    ldarg_0
    ldfld Scheduler.currentTask
    ldflda TaskControlBlock.base
    ldc_i4_1
    call TaskState_setTaskHolding
    ldarg_0
    ldfld Scheduler.currentTask
    call TaskControlBlock_getLink
    ret
  end Scheduler_holdSelf
  type _$231 = pointer to Scheduler
  type _$232 = pointer to Packet
  type _$233 = pointer to TaskControlBlock
  type _$234 = pointer to TaskControlBlock
  procedure Scheduler_queuePacket(me: _$231; packet: _$232):_$233
  var t: _$234; 
  begin
    ldloca_s 0
    ldarg_0
    ldarg_1
    call Packet_getIdentity
    call Scheduler_findTask
    stind_ip
    if
      ldloc_0
      ldvar NO_TASK
      ceq
    then
      ldvar NO_TASK
      ret
    end
    ldarg_0
    ldflda Scheduler.queuePacketCount
    ldarg_0
    ldfld Scheduler.queuePacketCount
    ldc_i4_1
    add
    stind_i4
    ldarg_1
    ldvar NO_WORK
    call Packet_setLink
    ldarg_1
    ldarg_0
    ldfld Scheduler.currentTaskIdentity
    call Packet_setIdentity
    ldloc_0
    ldarg_1
    ldarg_0
    ldfld Scheduler.currentTask
    call TaskControlBlock_addInputAndCheckPriority
    ret
  end Scheduler_queuePacket
  type _$235 = pointer to Scheduler
  type _$236 = pointer to TaskControlBlock
  type _$237 = pointer to TaskControlBlock
  type _$238 = pointer to TaskState
  procedure Scheduler_release(me: _$235; identity: int32):_$236
  var t: _$237; 
  begin
    ldloca_s 0
    ldarg_0
    ldarg_1
    call Scheduler_findTask
    stind_ip
    if
      ldloc_0
      ldvar NO_TASK
      ceq
    then
      ldvar NO_TASK
      ret
    end
    ldloc_0
    ldflda TaskControlBlock.base
    ldc_i4_0
    call TaskState_setTaskHolding
    if
      ldloc_0
      call TaskControlBlock_getPriority
      ldarg_0
      ldfld Scheduler.currentTask
      call TaskControlBlock_getPriority
      cgt
    then
      ldloc_0
      ret
    else
      ldarg_0
      ldfld Scheduler.currentTask
      ret
    end
  end Scheduler_release
  type _$239 = pointer to Scheduler
  procedure Scheduler_trace(me: _$239; id: int32)
  begin
    ldarg_0
    ldflda Scheduler.layout
    ldarg_0
    ldfld Scheduler.layout
    ldc_i4_1
    sub
    stind_i4
    if
      ldarg_0
      ldfld Scheduler.layout
      ldc_i4_0
      cgt
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldflda Scheduler.layout
      ldc_i4_s 50
      stind_i4
    end
    ldarg_1
    conv_i8
    call MIC$!printI8
  end Scheduler_trace
  type _$240 = pointer to Scheduler
  type _$241 = pointer to TaskControlBlock
  type _$242 = pointer to TaskState
  procedure Scheduler_markWaiting(me: _$240):_$241
  begin
    ldarg_0
    ldfld Scheduler.currentTask
    ldflda TaskControlBlock.base
    ldc_i4_1
    call TaskState_setTaskWaiting
    ldarg_0
    ldfld Scheduler.currentTask
    ret
  end Scheduler_markWaiting
  type _$243 = pointer to Scheduler
  type _$244 = pointer to TaskControlBlock
  type _$245 = pointer to TaskState
  procedure Scheduler_schedule(me: _$243)
  var tmp: _$244; 
  begin
    ldarg_0
    ldflda Scheduler.currentTask
    ldarg_0
    ldfld Scheduler.taskList
    stind_ip
    while
      ldarg_0
      ldfld Scheduler.currentTask
      ldvar NO_TASK
      ceq
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldfld Scheduler.currentTask
        ldflda TaskControlBlock.base
        call TaskState_isTaskHoldingOrWaiting
      then
        ldloca_s 0
        ldarg_0
        ldfld Scheduler.currentTask
        call TaskControlBlock_getLink
        stind_ip
        ldarg_0
        ldflda Scheduler.currentTask
        ldloc_0
        stind_ip
      else
        ldarg_0
        ldflda Scheduler.currentTaskIdentity
        ldarg_0
        ldfld Scheduler.currentTask
        call TaskControlBlock_getIdentity
        stind_i4
        if
          ldvar TRACING
        then
          ldarg_0
          ldarg_0
          ldfld Scheduler.currentTaskIdentity
          call Scheduler_trace
        end
        ldloca_s 0
        ldarg_0
        ldfld Scheduler.currentTask
        call TaskControlBlock_runTask
        stind_ip
        ldarg_0
        ldflda Scheduler.currentTask
        ldloc_0
        stind_ip
      end
    end
  end Scheduler_schedule
  type _$246 = pointer to Benchmark!Benchmark
  type _$247 = pointer to Scheduler
  type _$248 = pointer to Scheduler
  procedure benchmark(me: _$246):int32
  var s: Scheduler; res: bool; 
  begin
    ldloca_s 1
    ldc_i4_0
    stind_i1
    ldloca_s 0
    call Scheduler_init
    ldloca_s 1
    ldloca_s 0
    call Scheduler_start
    stind_i1
    ldvar toDelete
    call RBObject_delete
    ldvara toDelete
    ldnull
    stind_ip
    if
      ldloc_1
    then
      ldc_i4_1
      ret
    else
      ldc_i4_0
      ret
    end
  end benchmark
  type _$249 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$249; result: int32):bool
  begin
    ldarg_1
    ldc_i4_0
    ceq
    ldc_i4_0
    ceq
    ret
  end verifyResult
  type _$250 = pointer to Benchmark!Benchmark
  type _$251 = pointer to Benchmark!Benchmark
  procedure create():_$250
  var bench: _$251; 
  begin
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.benchmark
    ldproc benchmark
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.verifyResult
    ldproc verifyResult
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.dispose
    ldnull
    stind_ip
    ldloc_0
    ldflda Benchmark!Benchmark.innerBenchmarkLoop
    ldnull
    stind_ip
    ldloc_0
    ret
  end create
end Richards

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Run
  import Benchmark
  import Input
  import Out
  import Bounce
  import Mandelbrot
  import Permute
  import List
  import Queens
  import Sieve
  import Storage
  import Towers
  import NBody
  import Richards
  type _$1 = array of char
  type _$2 = pointer to _$1
  type _$3 = pointer to Benchmark!Benchmark
  type Run* = struct 
    name*: _$2
    benchmarkSuite*: _$3
    numIterations*: int32
    innerIterations*: int32
    total*: int32
  end
  type _$4 = array of char
  type _$5 = pointer to _$4
  type _$6 = pointer to Benchmark!Benchmark
  procedure getSuiteFromName(name: _$5):_$6
  begin
    if
      ldarg_0
      ldstr "Bounce"
      ldc_i4_1
      call MIC$!relop1
    then
      call Bounce!create
      ret
    else
      if
        ldarg_0
        ldstr "Mandelbrot"
        ldc_i4_1
        call MIC$!relop1
      then
        call Mandelbrot!create
        ret
      else
        if
          ldarg_0
          ldstr "Permute"
          ldc_i4_1
          call MIC$!relop1
        then
          call Permute!create
          ret
        else
          if
            ldarg_0
            ldstr "List"
            ldc_i4_1
            call MIC$!relop1
          then
            call List!create
            ret
          else
            if
              ldarg_0
              ldstr "Queens"
              ldc_i4_1
              call MIC$!relop1
            then
              call Queens!create
              ret
            else
              if
                ldarg_0
                ldstr "Sieve"
                ldc_i4_1
                call MIC$!relop1
              then
                call Sieve!create
                ret
              else
                if
                  ldarg_0
                  ldstr "Storage"
                  ldc_i4_1
                  call MIC$!relop1
                then
                  call Storage!create
                  ret
                else
                  if
                    ldarg_0
                    ldstr "Towers"
                    ldc_i4_1
                    call MIC$!relop1
                  then
                    call Towers!create
                    ret
                  else
                    if
                      ldarg_0
                      ldstr "NBody"
                      ldc_i4_1
                      call MIC$!relop1
                    then
                      call NBody!create
                      ret
                    else
                      if
                        ldarg_0
                        ldstr "Richards"
                        ldc_i4_1
                        call MIC$!relop1
                      then
                        call Richards!create
                        ret
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    ldnull
    ret
  end getSuiteFromName
  type _$7 = pointer to Run
  type _$8 = array of char
  type _$9 = pointer to _$8
  procedure init(me: _$7; name: _$9)
  begin
    ldarg_0
    ldflda Run.numIterations
    ldc_i4_1
    stind_i4
    ldarg_0
    ldflda Run.innerIterations
    ldc_i4_1
    stind_i4
    ldarg_0
    ldflda Run.total
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda Run.name
    ldarg_1
    stind_ip
    ldarg_0
    ldflda Run.benchmarkSuite
    ldarg_1
    call getSuiteFromName
    stind_ip
  end init
  type _$10 = pointer to Run
  procedure deinit(me: _$10)
  begin
    if
      ldarg_0
      ldfld Run.benchmarkSuite
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      if
        ldarg_0
        ldfld Run.benchmarkSuite
        ldfld Benchmark!Benchmark.dispose
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld Run.benchmarkSuite
        ldarg_0
        ldfld Run.benchmarkSuite
        ldfld Benchmark!Benchmark.dispose
        calli Benchmark!_$2
      end
      ldarg_0
      ldfld Run.benchmarkSuite
      free
    end
  end deinit
  type _$11 = pointer to Run
  procedure printResult(me: _$11; runTime: int32)
  begin
    ret
    ldarg_0
    ldfld Run.name
    call Out!String
    ldstr ": iterations=1 runtime: "
    call Out!String
    ldarg_1
    ldc_i4_0
    call Out!Int
    ldstr "us"
    call Out!String
    call Out!Ln
  end printResult
  type _$12 = pointer to Run
  procedure printTotal(me: _$12)
  begin
    ret
    ldstr "Total Runtime: "
    call Out!String
    ldarg_0
    ldfld Run.total
    ldc_i4_0
    call Out!Int
    ldstr "us"
    call Out!String
    call Out!Ln
  end printTotal
  type _$13 = pointer to Run
  type _$14 = pointer to Benchmark!Benchmark
  type _$15 = pointer to Benchmark!Benchmark
  type _$16 = proc(me: _$15; innerIterations: int32):bool
  procedure measure(me: _$13; bench: _$14):bool
  var startTime: int32; endTime: int32; runTime: int32; innerBenchmarkLoop: _$16; 
  begin
    ldloca_s 0
    call Input!Time
    stind_i4
    ldloca_s 3
    ldarg_1
    ldfld Benchmark!Benchmark.innerBenchmarkLoop
    stind_ip
    if
      ldloc_3
      ldnull
      ceq
    then
      ldloca_s 3
      ldproc Benchmark!innerBenchmarkLoop
      stind_ip
    end
    if
      ldarg_1
      ldarg_0
      ldfld Run.innerIterations
      ldloc_3
      calli _$16
      ldc_i4_0
      ceq
    then
      ldc_i4_0
      ret
    end
    ldloca_s 1
    call Input!Time
    stind_i4
    ldloca_s 2
    ldloc_1
    ldloc_0
    sub
    stind_i4
    ldarg_0
    ldloc_2
    call printResult
    ldarg_0
    ldflda Run.total
    ldarg_0
    ldfld Run.total
    ldloc_2
    add
    stind_i4
    ldc_i4_1
    ret
  end measure
  type _$17 = pointer to Run
  type _$18 = pointer to Benchmark!Benchmark
  procedure doRuns(me: _$17; bench: _$18):bool
  var i: int32; _$19: int32; 
  begin
    ldloca_s 0
    ldc_i4_0
    stind_i4
    ldloca_s 1
    ldarg_0
    ldfld Run.numIterations
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldarg_1
        call measure
        ldc_i4_0
        ceq
      then
        ldc_i4_0
        ret
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldc_i4_1
    ret
  end doRuns
  type _$20 = pointer to Run
  procedure reportBenchmark(me: _$20)
  begin
    ldarg_0
    ldfld Run.name
    call Out!String
    ldstr ": iterations="
    call Out!String
    ldarg_0
    ldfld Run.numIterations
    ldc_i4_0
    call Out!Int
    ldstr " average: "
    call Out!String
    ldarg_0
    ldfld Run.total
    ldarg_0
    ldfld Run.numIterations
    div
    ldc_i4_0
    call Out!Int
    ldstr "us total: "
    call Out!String
    ldarg_0
    ldfld Run.total
    ldc_i4_0
    call Out!Int
    ldstr "us"
    call Out!String
    call Out!Ln
  end reportBenchmark
  type _$21 = pointer to Run
  procedure runBenchmark(me: _$21)
  begin
    ldstr "Starting "
    call Out!String
    ldarg_0
    ldfld Run.name
    call Out!String
    ldstr " benchmark ..."
    call Out!String
    call Out!Ln
    if
      ldarg_0
      ldfld Run.benchmarkSuite
      ldnull
      ceq
    then
      ldstr "ERROR unknown benchmark "
      call Out!String
      ldarg_0
      ldfld Run.name
      call Out!String
      call Out!Ln
      ret
    end
    if
      ldarg_0
      ldarg_0
      ldfld Run.benchmarkSuite
      call doRuns
      ldc_i4_0
      ceq
    then
      ldstr "ERROR"
      call Out!String
      call Out!Ln
      ret
    end
    ldarg_0
    call reportBenchmark
    call Out!Ln
  end runBenchmark
  type _$22 = pointer to Run
  procedure setNumIterations(me: _$22; numIterations: int32)
  begin
    ldarg_0
    ldflda Run.numIterations
    ldarg_1
    stind_i4
  end setNumIterations
  type _$23 = pointer to Run
  procedure setInnerIterations(me: _$23; innerIterations: int32)
  begin
    ldarg_0
    ldflda Run.innerIterations
    ldarg_1
    stind_i4
  end setInnerIterations
end Run

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Interfaces$20
  type T = int32
  type Data = pointer to any
  type _$1 = pointer to int32
  type ValueIterator* = proc(value: _$1; data: Data)
  type _$2 = pointer to int32
  type TestIterator* = proc(value: _$2; data: Data):bool
  type _$3 = pointer to int32
  type CompareIterator* = proc(lhs: _$3; rhs: _$3; data: Data):int32
end Interfaces$20

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Vector$19
  type T = int32
  import Interfaces$20
  type _$1 = pointer to int32
  type Equal* = proc(lhs: _$1; rhs: _$1):bool
  type _$2 = array of int32
  type _$3 = pointer to _$2
  type _$4 = struct 
    firstIdx: int32
    lastIdx: int32
    length: int32
    storage: _$3
  end
  type Vector* = pointer to _$4
  type _$5 = array of int32
  type _$6 = pointer to _$5
  procedure expand(me: Vector; newLength: int32)
  var i: int32; old: _$6; _$7: int32; 
  begin
    if
      ldarg_1
      ldarg_0
      ldfld _$4.length
      cgt
      ldc_i4_0
      ceq
    then
      ret
    end
    if
      ldarg_1
      ldc_i4_0
      cgt
    then
      ldloca_s 1
      ldarg_0
      ldfld _$4.storage
      stind_ip
      ldarg_0
      ldflda _$4.storage
      ldarg_1
      newarr int32
      stind_ip
      if
        ldloc_1
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        ldloca_s 0
        ldc_i4_0
        stind_i4
        ldloca_s 2
        ldarg_0
        ldfld _$4.length
        ldc_i4_1
        sub
        stind_i4
        while
          ldloc_0
          ldloc_2
          cgt
          ldc_i4_0
          ceq
        do
          ldarg_0
          ldfld _$4.storage
          ldloc_0
          ldelema int32
          ldloc_1
          ldloc_0
          ldelem_i4
          stind_i4
          ldloca_s 0
          ldloc_0
          ldc_i4_1
          add
          stind_i4
        end
      end
    end
    ldarg_0
    ldflda _$4.length
    ldarg_1
    stind_i4
  end expand
  procedure enlarge(me: Vector; idx: int32)
  var newLength: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld _$4.length
    stind_i4
    while
      ldloc_0
      ldarg_1
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 0
      ldloc_0
      ldc_i4_2
      mul
      stind_i4
      ldloca_s 0
      ldloc_0
      ldc_i4_s 50
      add
      stind_i4
    end
    ldarg_0
    ldloc_0
    call expand
  end enlarge
  type _$8 = pointer to int32
  type _$9 = pointer to int32
  procedure at(me: Vector; idx: int32):_$8
  begin
    if
      iif
        ldarg_1
        ldc_i4_0
        clt
      then
        ldc_i4_1
      else
        ldarg_1
        ldarg_0
        ldfld _$4.length
        clt
        ldc_i4_0
        ceq
      end
    then
      ldc_i4_0
      ldc_i4_s 68
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
      call MIC$!assert
    end
    ldarg_0
    ldfld _$4.storage
    ldarg_1
    ldelema int32
    ret
  end at
  type _$10 = pointer to int32
  procedure atPut(me: Vector; idx: int32; val: _$10)
  begin
    if
      ldarg_1
      ldarg_0
      ldfld _$4.length
      clt
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldarg_1
      call enlarge
    end
    ldarg_0
    ldfld _$4.storage
    ldarg_1
    ldelema int32
    ldarg_2
    stind_i4
    if
      ldarg_0
      ldfld _$4.lastIdx
      ldarg_1
      ldc_i4_1
      add
      clt
    then
      ldarg_0
      ldflda _$4.lastIdx
      ldarg_1
      ldc_i4_1
      add
      stind_i4
    end
  end atPut
  type _$12 = pointer to int32
  procedure forEach(me: Vector; iter: Interfaces$20!ValueIterator; data: Interfaces$20!Data)
  var i: int32; _$11: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld _$4.firstIdx
    stind_i4
    ldloca_s 1
    ldarg_0
    ldfld _$4.lastIdx
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldfld _$4.storage
      ldloc_0
      ldelema int32
      ldarg_2
      ldarg_1
      calli Interfaces$20!ValueIterator
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
  end forEach
  type _$14 = pointer to int32
  procedure hasSome(me: Vector; iter: Interfaces$20!TestIterator; data: Interfaces$20!Data):bool
  var i: int32; _$13: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld _$4.firstIdx
    stind_i4
    ldloca_s 1
    ldarg_0
    ldfld _$4.lastIdx
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      if
        ldarg_0
        ldfld _$4.storage
        ldloc_0
        ldelema int32
        ldarg_2
        ldarg_1
        calli Interfaces$20!TestIterator
      then
        ldc_i4_1
        ret
      end
      ldloca_s 0
      ldloc_0
      ldc_i4_1
      add
      stind_i4
    end
    ldc_i4_0
    ret
  end hasSome
  type _$15 = array of int32
  type _$16 = pointer to _$15
  type _$17 = pointer to int32
  type Remove_Iterator = struct 
    newArray: _$16
    newLast: int32
    obj: _$17
    found: bool
    eq: Equal
  end
  type _$18 = pointer to int32
  type _$19 = pointer to Remove_Iterator
  type _$20 = pointer to Remove_Iterator
  procedure remove_iter(value: _$18; data: Interfaces$20!Data)
  var me: _$19; 
  begin
    ldloca_s 0
    ldarg_1
    castptr Remove_Iterator
    stind_ip
    if
      ldarg_0
      ldloc_0
      ldfld Remove_Iterator.obj
      ldloc_0
      ldfld Remove_Iterator.eq
      calli Equal
    then
      ldloc_0
      ldflda Remove_Iterator.found
      ldc_i4_1
      stind_i1
    else
      ldloc_0
      ldfld Remove_Iterator.newArray
      ldloc_0
      ldfld Remove_Iterator.newLast
      ldelema int32
      ldarg_0
      stind_i4
      ldloc_0
      ldflda Remove_Iterator.newLast
      dup
      ldind_i4
      ldc_i4_1
      add
      stind_i4
    end
  end remove_iter
  type _$21 = pointer to int32
  type _$22 = pointer to Remove_Iterator
  procedure remove(me: Vector; obj: _$21; eq: Equal):bool
  var iter: Remove_Iterator; 
  begin
    if
      ldarg_0
      ldfld _$4.length
      ldc_i4_0
      ceq
    then
      ldc_i4_0
      ret
    end
    ldloca_s 0
    ldflda Remove_Iterator.newArray
    ldarg_0
    ldfld _$4.length
    newarr int32
    stind_ip
    ldloca_s 0
    ldflda Remove_Iterator.found
    ldc_i4_0
    stind_i1
    ldloca_s 0
    ldflda Remove_Iterator.obj
    ldarg_1
    stind_ip
    ldloca_s 0
    ldflda Remove_Iterator.newLast
    ldc_i4_0
    stind_i4
    ldloca_s 0
    ldflda Remove_Iterator.eq
    ldarg_2
    stind_ip
    ldarg_0
    ldproc remove_iter
    ldloca_s 0
    call forEach
    ldarg_0
    ldfld _$4.storage
    free
    ldarg_0
    ldflda _$4.storage
    ldloca_s 0
    ldfld Remove_Iterator.newArray
    stind_ip
    ldarg_0
    ldflda _$4.lastIdx
    ldloca_s 0
    ldfld Remove_Iterator.newLast
    stind_i4
    ldarg_0
    ldflda _$4.firstIdx
    ldc_i4_0
    stind_i4
    ldloca_s 0
    ldfld Remove_Iterator.found
    ret
  end remove
  type _$23 = pointer to int32
  procedure append(me: Vector; elem: _$23)
  begin
    if
      ldarg_0
      ldfld _$4.lastIdx
      ldarg_0
      ldfld _$4.length
      clt
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldarg_0
      ldfld _$4.lastIdx
      call enlarge
    end
    ldarg_0
    ldfld _$4.storage
    ldarg_0
    ldfld _$4.lastIdx
    ldelema int32
    ldarg_1
    stind_i4
    ldarg_0
    ldflda _$4.lastIdx
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
  end append
  procedure isEmpty(me: Vector):bool
  begin
    ldarg_0
    ldfld _$4.lastIdx
    ldarg_0
    ldfld _$4.firstIdx
    ceq
    ret
  end isEmpty
  type _$24 = pointer to int32
  type _$25 = pointer to int32
  procedure removeFirst(me: Vector):_$24
  begin
    if
      ldarg_0
      call isEmpty
    then
      ldc_i4_0
      ldc_i4 164
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
      call MIC$!assert
    end
    ldarg_0
    ldflda _$4.firstIdx
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    ldarg_0
    ldfld _$4.storage
    ldarg_0
    ldfld _$4.firstIdx
    ldc_i4_1
    sub
    ldelema int32
    ret
  end removeFirst
  procedure removeAll(me: Vector)
  begin
    ldarg_0
    ldflda _$4.firstIdx
    ldc_i4_0
    stind_i4
    ldarg_0
    ldflda _$4.lastIdx
    ldc_i4_0
    stind_i4
  end removeAll
  procedure size(me: Vector):int32
  begin
    ldarg_0
    ldfld _$4.lastIdx
    ldarg_0
    ldfld _$4.firstIdx
    sub
    ret
  end size
  procedure capacity(me: Vector):int32
  begin
    ldarg_0
    ldfld _$4.length
    ret
  end capacity
  procedure create(len: int32):Vector
  var v: Vector; 
  begin
    ldloca_s 0
    newobj _$4
    stind_ip
    ldloc_0
    ldflda _$4.firstIdx
    ldc_i4_0
    stind_i4
    ldloc_0
    ldflda _$4.lastIdx
    ldc_i4_0
    stind_i4
    ldloc_0
    ldflda _$4.length
    ldc_i4_0
    stind_i4
    ldloc_0
    ldflda _$4.storage
    ldnull
    stind_ip
    ldloc_0
    ldarg_0
    call expand
    ldloc_0
    ret
  end create
  procedure createDefault():Vector
  begin
    ldc_i4_0
    call create
    ret
  end createDefault
  procedure copy(in_: Vector):Vector
  var me: Vector; i: int32; _$26: int32; 
  begin
    ldloca_s 0
    ldarg_0
    ldfld _$4.length
    call create
    stind_ip
    ldloc_0
    ldflda _$4.firstIdx
    ldarg_0
    ldfld _$4.firstIdx
    stind_i4
    ldloc_0
    ldflda _$4.lastIdx
    ldarg_0
    ldfld _$4.lastIdx
    stind_i4
    ldloca_s 1
    ldc_i4_0
    stind_i4
    ldloca_s 2
    ldarg_0
    ldfld _$4.length
    ldc_i4_1
    sub
    stind_i4
    while
      ldloc_1
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_0
      ldfld _$4.storage
      ldloc_1
      ldelema int32
      ldarg_0
      ldfld _$4.storage
      ldloc_1
      ldelem_i4
      stind_i4
      ldloca_s 1
      ldloc_1
      ldc_i4_1
      add
      stind_i4
    end
    ldloc_0
    ret
  end copy
  procedure free(me: Vector)
  begin
    if
      ldarg_0
      ldnull
      ceq
    then
      ret
    end
    if
      ldarg_0
      ldfld _$4.storage
    then
      ldarg_0
      ldfld _$4.storage
      free
    end
    ldarg_0
    free
  end free
  type _$27 = array of int32
  type _$28 = pointer to _$27
  procedure swap(storage: _$28; i: int32; j: int32) inline 
  begin
    ldc_i4_0
    ldc_i4 228
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
    call MIC$!assert
  end swap
  type _$29 = pointer to int32
  type _$30 = pointer to int32
  type _$31 = pointer to int32
  type _$32 = pointer to int32
  type _$33 = pointer to int32
  type _$34 = pointer to int32
  procedure sort_imp(me: Vector; i: int32; j: int32; c: Interfaces$20!CompareIterator; data: Interfaces$20!Data)
  var n: int32; ij: int32; k: int32; l: int32; di: _$29; dj: _$29; tt: _$29; dij: _$29; 
  begin
    ldloca_s 0
    ldarg_2
    ldc_i4_1
    add
    ldarg_1
    sub
    stind_i4
    if
      ldloc_0
      ldc_i4_1
      cgt
      ldc_i4_0
      ceq
    then
      ret
    end
    ldloca_s 4
    ldarg_0
    ldfld _$4.storage
    ldarg_1
    ldelema int32
    stind_ip
    ldloca_s 5
    ldarg_0
    ldfld _$4.storage
    ldarg_2
    ldelema int32
    stind_ip
    if
      ldloc_s 4
      ldloc_s 5
      ldarg_s 4
      ldarg_3
      calli Interfaces$20!CompareIterator
      ldc_i4_0
      cgt
    then
      ldarg_0
      ldfld _$4.storage
      ldarg_1
      ldarg_2
      call swap
      ldloca_s 6
      ldloc_s 4
      stind_ip
      ldloca_s 4
      ldloc_s 5
      stind_ip
      ldloca_s 5
      ldloc_s 6
      stind_ip
    end
    if
      ldloc_0
      ldc_i4_2
      cgt
    then
      ldloca_s 1
      ldarg_1
      ldarg_2
      add
      ldc_i4_2
      div
      stind_i4
      ldloca_s 7
      ldarg_0
      ldfld _$4.storage
      ldloc_1
      ldelema int32
      stind_ip
      if
        ldloc_s 4
        ldloc_s 7
        ldarg_s 4
        ldarg_3
        calli Interfaces$20!CompareIterator
        ldc_i4_0
        cgt
        ldc_i4_0
        ceq
      then
        if
          ldloc_s 7
          ldloc_s 5
          ldarg_s 4
          ldarg_3
          calli Interfaces$20!CompareIterator
          ldc_i4_0
          cgt
        then
          ldarg_0
          ldfld _$4.storage
          ldarg_2
          ldloc_1
          call swap
          ldloca_s 7
          ldloc_s 5
          stind_ip
        end
      else
        ldarg_0
        ldfld _$4.storage
        ldarg_1
        ldloc_1
        call swap
        ldloca_s 7
        ldloc_s 4
        stind_ip
      end
      if
        ldloc_0
        ldc_i4_3
        cgt
      then
        ldloca_s 2
        ldarg_1
        stind_i4
        ldloca_s 3
        ldarg_2
        ldc_i4_1
        sub
        stind_i4
        loop
          while
            iif
              ldloc_2
              ldloc_3
              cgt
              ldc_i4_0
              ceq
            then
              ldloc_s 7
              ldarg_0
              ldfld _$4.storage
              ldloc_3
              ldelema int32
              ldarg_s 4
              ldarg_3
              calli Interfaces$20!CompareIterator
              ldc_i4_0
              cgt
              ldc_i4_0
              ceq
            else
              ldc_i4_0
            end
          do
            ldloca_s 3
            dup
            ldind_i4
            ldc_i4_1
            sub
            stind_i4
          end
          ldloca_s 2
          dup
          ldind_i4
          ldc_i4_1
          add
          stind_i4
          while
            iif
              ldloc_2
              ldloc_3
              cgt
              ldc_i4_0
              ceq
            then
              ldarg_0
              ldfld _$4.storage
              ldloc_2
              ldelema int32
              ldloc_s 7
              ldarg_s 4
              ldarg_3
              calli Interfaces$20!CompareIterator
              ldc_i4_0
              cgt
              ldc_i4_0
              ceq
            else
              ldc_i4_0
            end
          do
            ldloca_s 2
            dup
            ldind_i4
            ldc_i4_1
            add
            stind_i4
          end
          if
            ldloc_2
            ldloc_3
            cgt
          then
            exit
          end
          ldarg_0
          ldfld _$4.storage
          ldloc_2
          ldloc_3
          call swap
        end
        ldarg_0
        ldarg_1
        ldloc_3
        ldarg_3
        ldarg_s 4
        call sort_imp
        ldarg_0
        ldloc_2
        ldarg_2
        ldarg_3
        ldarg_s 4
        call sort_imp
      end
    end
  end sort_imp
  procedure sort(me: Vector; c: Interfaces$20!CompareIterator; data: Interfaces$20!Data)
  begin
    if
      ldarg_0
      call size
      ldc_i4_0
      cgt
    then
      ldarg_0
      ldarg_0
      ldfld _$4.firstIdx
      ldarg_0
      ldfld _$4.lastIdx
      ldc_i4_1
      sub
      ldarg_1
      ldarg_2
      call sort_imp
    end
  end sort
end Vector$19

// Generated by MicCompiler  on 2025-04-09T23:21:10

module Main
  import Run
  import Vector$19
  type _$1 = array of char
  type _$2 = pointer to _$1
  type _$3 = pointer to Run!Run
  type _$4 = pointer to Run!Run
  type _$5 = pointer to Run!Run
  type _$6 = pointer to Run!Run
  type _$7 = pointer to Run!Run
  type _$8 = pointer to Run!Run
  procedure run(what: _$2; numIterations: int32; innerIterations: int32)
  var r: Run!Run; 
  begin
    ldloca_s 0
    ldarg_0
    call Run!init
    ldloca_s 0
    ldarg_1
    call Run!setNumIterations
    ldloca_s 0
    ldarg_2
    call Run!setInnerIterations
    ldloca_s 0
    call Run!runBenchmark
    ldloca_s 0
    call Run!printTotal
    ldloca_s 0
    call Run!deinit
  end run
  procedure runAll()
  begin
    ldstr "DeltaBlue"
    ldc_i4 12000
    ldc_i4_1
    call run
    ldstr "Richards"
    ldc_i4_s 100
    ldc_i4_1
    call run
    ldstr "Json"
    ldc_i4_s 100
    ldc_i4_1
    call run
    ldstr "Havlak"
    ldc_i4_s 10
    ldc_i4_1
    call run
    ldstr "CD"
    ldc_i4 250
    ldc_i4_2
    call run
    ldstr "Bounce"
    ldc_i4 1500
    ldc_i4_1
    call run
    ldstr "List"
    ldc_i4 1500
    ldc_i4_1
    call run
    ldstr "Mandelbrot"
    ldc_i4 500
    ldc_i4_1
    call run
    ldstr "NBody"
    ldc_i4 250000
    ldc_i4_1
    call run
    ldstr "Permute"
    ldc_i4 1000
    ldc_i4_1
    call run
    ldstr "Queens"
    ldc_i4 1000
    ldc_i4_1
    call run
    ldstr "Sieve"
    ldc_i4 3000
    ldc_i4_1
    call run
    ldstr "Storage"
    ldc_i4 1000
    ldc_i4_1
    call run
    ldstr "Towers"
    ldc_i4 600
    ldc_i4_1
    call run
  end runAll
  procedure runOnce()
  begin
    ldstr "DeltaBlue"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "Richards"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "Json"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "Havlak"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "CD"
    ldc_i4_1
    ldc_i4_2
    call run
    ldstr "Bounce"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "List"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "Mandelbrot"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "NBody"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "Permute"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "Queens"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "Sieve"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "Storage"
    ldc_i4_1
    ldc_i4_1
    call run
    ldstr "Towers"
    ldc_i4_1
    ldc_i4_1
    call run
  end runOnce
  procedure begin$() init 
  begin
    call runOnce
  end begin$
end Main
