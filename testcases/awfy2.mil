// Generated by compiler  on 2025-06-02T23:11:10

module Benchmark
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Benchmark.mic"
  type line 28 _$1 = pointer to Benchmark
  type _$2 = proc(me: _$1)
  type line 29 _$3 = pointer to Benchmark
  type _$4 = proc(me: _$3):int32
  type line 30 _$5 = pointer to Benchmark
  type _$6 = proc(me: _$5; result: int32):bool
  type line 31 _$7 = pointer to Benchmark
  type _$8 = proc(me: _$7; innerIterations: int32):bool
  type line 27 Benchmark* = struct 
    line 28 dispose: _$2
    line 29 benchmark: _$4
    line 30 verifyResult: _$6
    line 31 innerBenchmarkLoop: _$8
  end
  type line 34 _$9 = pointer to Benchmark
  procedure innerBenchmarkLoop(me: _$9; innerIterations: int32):bool
  var line 35 i: int32; _$10: int32; 
  begin
    line 37
    ldc_i4_0
    stloc_0
    ldarg_1
    ldc_i4_1
    sub
    stloc_1
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      line 38
      if
        ldarg_0
        ldarg_0
        ldarg_0
        ldfld Benchmark.benchmark
        calli _$4
        ldarg_0
        ldfld Benchmark.verifyResult
        calli _$6
        ldc_i4_0
        ceq
      then
        line 39
        ldc_i4_0
        ret
        line 40
      end
      line 37
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 41
    end
    line 42
    ldc_i4_1
    ret
    line 43
  end innerBenchmarkLoop
end line 45 Benchmark

// Generated by compiler  on 2025-06-02T23:11:10

module Input
  source "/home/me/Entwicklung/Modules/Micron/oakwood/Input.mic"
  procedure line 5 Available():int32 extern 
  type line 6 _$1 = pointer to char
  procedure Read(ch: _$1) extern 
  type line 7 _$2 = pointer to uint32
  type _$3 = pointer to int32
  procedure Mouse(keys: _$2; x: _$3; y: _$3) extern 
  procedure line 8 SetMouseLimits(w: int32; h: int32) extern 
  procedure line 9 Time():int32 extern 
end line 10 Input

// Generated by compiler  on 2025-06-02T23:11:10

module Out
  source "/home/me/Entwicklung/Modules/Micron/oakwood/Out.mic"
  procedure line 3 Open() extern 
  procedure line 4 Char(ch: char) extern 
  type line 5 _$1 = array of char
  type _$2 = pointer to _$1
  procedure String(str: _$2) extern 
  procedure line 6 Int(i: int64; n: int32) extern 
  procedure line 7 Real(x: float32; n: int32) extern 
  procedure line 8 LongReal(x: float64; n: int32) extern 
  procedure line 9 Ln() extern 
end line 10 Out

// Generated by compiler  on 2025-06-02T23:11:10

module Random
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Random.mic"
  var line 30 seed: uint32
  procedure line 32 reset()
  begin
    line 34
    ldc_i4 74755
    stvar seed
    line 35
  end reset
  procedure line 37 next():uint32
  begin
    line 39
    ldvar seed
    ldc_i4 1309
    mul
    ldc_i4 13849
    add
    ldc_i4 65535
    and
    stvar seed
    line 40
    ldvar seed
    ret
    line 41
  end next
  procedure line 43 begin$() init 
  begin
    line 44
    ldc_i4 74755
    stvar seed
    line 46
  end begin$
end line 43 Random

// Generated by compiler  on 2025-06-02T23:11:10

module Bounce
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Bounce.mic"
  import line 26 Random
  import Benchmark
  type line 29 Ball = struct 
    line 30 x: int32
    y: int32
    xVel: int32
    yVel: int32
  end
  type line 33 _$1 = pointer to Ball
  procedure Ball_init(me: _$1)
  begin
    line 35
    ldarg_0
    ldc_i4_0
    stfld Ball.x
    ldarg_0
    ldc_i4_0
    stfld Ball.y
    ldarg_0
    ldc_i4_0
    stfld Ball.xVel
    ldarg_0
    ldc_i4_0
    stfld Ball.yVel
    line 36
    ldarg_0
    call Random!next
    ldc_i4 500
    rem_un
    conv_i4
    stfld Ball.x
    line 37
    ldarg_0
    call Random!next
    ldc_i4 500
    rem_un
    conv_i4
    stfld Ball.y
    line 38
    ldarg_0
    call Random!next
    ldc_i4 300
    rem_un
    conv_i4
    ldc_i4 150
    sub
    stfld Ball.xVel
    line 39
    ldarg_0
    call Random!next
    ldc_i4 300
    rem_un
    conv_i4
    ldc_i4 150
    sub
    stfld Ball.yVel
    line 40
  end Ball_init
  type line 42 _$2 = pointer to Ball
  procedure Ball_bounce(me: _$2):bool
  var line 44 bounced: bool; 
  begin
    line 46
    ldc_i4_0
    stloc_0
    line 47
    ldarg_0
    ldarg_0
    ldfld Ball.x
    ldarg_0
    ldfld Ball.xVel
    add
    stfld Ball.x
    line 48
    ldarg_0
    ldarg_0
    ldfld Ball.y
    ldarg_0
    ldfld Ball.yVel
    add
    stfld Ball.y
    line 49
    if
      ldarg_0
      ldfld Ball.x
      ldc_i4 500
      cgt
    then
      ldarg_0
      ldc_i4 500
      stfld Ball.x
      ldarg_0
      ldc_i4_0
      ldarg_0
      ldfld Ball.xVel
      abs
      sub
      stfld Ball.xVel
      ldc_i4_1
      stloc_0
    end
    line 50
    if
      ldarg_0
      ldfld Ball.x
      ldc_i4_0
      clt
    then
      ldarg_0
      ldc_i4_0
      stfld Ball.x
      ldarg_0
      ldarg_0
      ldfld Ball.xVel
      abs
      stfld Ball.xVel
      ldc_i4_1
      stloc_0
    end
    line 51
    if
      ldarg_0
      ldfld Ball.y
      ldc_i4 500
      cgt
    then
      ldarg_0
      ldc_i4 500
      stfld Ball.y
      ldarg_0
      ldc_i4_0
      ldarg_0
      ldfld Ball.yVel
      abs
      sub
      stfld Ball.yVel
      ldc_i4_1
      stloc_0
    end
    line 52
    if
      ldarg_0
      ldfld Ball.y
      ldc_i4_0
      clt
    then
      ldarg_0
      ldc_i4_0
      stfld Ball.y
      ldarg_0
      ldarg_0
      ldfld Ball.yVel
      abs
      stfld Ball.yVel
      ldc_i4_1
      stloc_0
    end
    line 53
    ldloc_0
    ret
    line 54
  end Ball_bounce
  type line 56 _$3 = pointer to Benchmark!Benchmark
  type line 61 _$4 = array of Ball
  type _$5 = pointer to _$4
  type line 68 _$7 = pointer to Ball
  type _$10 = pointer to Ball
  procedure benchmark(me: _$3):int32
  var line 60 bounces: int32; i: int32; j: int32; balls: _$5; _$6: int32; _$8: int32; _$9: int32; 
  begin
    line 63
    call Random!reset
    line 64
    ldc_i4_0
    stloc_0
    line 66
    ldloca_s 3
    ldc_i4_s 100
    newarr Ball
    stind_ip
    line 67
    ldc_i4_0
    stloc_1
    ldc_i4_s 99
    stloc_s 4
    while
      ldloc_1
      ldloc_s 4
      cgt
      ldc_i4_0
      ceq
    do
      ldloc_3
      ldloc_1
      ldelema Ball
      call Ball_init
      ldloc_1
      ldc_i4_1
      add
      stloc_1
      line 69
    end
    line 71
    ldc_i4_0
    stloc_1
    ldc_i4_s 49
    stloc_s 5
    while
      ldloc_1
      ldloc_s 5
      cgt
      ldc_i4_0
      ceq
    do
      line 72
      ldc_i4_0
      stloc_2
      ldc_i4_s 99
      stloc_s 6
      while
        ldloc_2
        ldloc_s 6
        cgt
        ldc_i4_0
        ceq
      do
        line 73
        if
          ldloc_3
          ldloc_2
          ldelema Ball
          call Ball_bounce
        then
          line 74
          ldloca_s 0
          dup
          ldind_i4
          ldc_i4_1
          add
          stind_i4
          line 75
        end
        line 72
        ldloc_2
        ldc_i4_1
        add
        stloc_2
        line 76
      end
      line 71
      ldloc_1
      ldc_i4_1
      add
      stloc_1
      line 77
    end
    line 78
    ldloc_3
    free
    line 79
    ldloc_0
    ret
    line 80
  end benchmark
  type line 82 _$11 = pointer to Benchmark!Benchmark
  procedure verifyResult(bench: _$11; result: int32):bool
  begin
    line 84
    ldc_i4 1331
    ldarg_1
    ceq
    ret
    line 85
  end verifyResult
  type line 27 _$12 = pointer to Benchmark!Benchmark
  type line 89 _$13 = pointer to Benchmark!Benchmark
  procedure line 87 create():_$12
  var bench: _$13; 
  begin
    line 91
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    line 92
    ldloc_0
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 93
    ldloc_0
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 94
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 95
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 96
    ldloc_0
    ret
    line 97
  end create
end line 99 Bounce

// Generated by compiler  on 2025-06-02T23:11:10

module Mandelbrot
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Mandelbrot.mic"
  import line 47 Out
  import Benchmark
  procedure line 49 verifyResult2(result: int32; innerIterations: int32):bool
  begin
    line 51
    if
      ldarg_1
      ldc_i4 500
      ceq
    then
      line 52
      ldarg_0
      ldc_i4 191
      ceq
      ret
      line 53
    end
    line 54
    if
      ldarg_1
      ldc_i4 750
      ceq
    then
      line 55
      ldarg_0
      ldc_i4_s 50
      ceq
      ret
      line 56
    end
    line 57
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      line 58
      ldarg_0
      ldc_i4 128
      ceq
      ret
      line 59
    end
    line 62
    ldstr "No verification result for "
    call Out!String
    ldarg_1
    conv_i8
    ldc_i4_0
    call Out!Int
    ldstr " found"
    call Out!String
    call Out!Ln
    line 63
    ldstr "Result is: "
    call Out!String
    ldarg_0
    conv_i8
    ldc_i4_0
    call Out!Int
    call Out!Ln
    line 65
    ldc_i4_0
    ret
    line 66
  end verifyResult2
  procedure line 68 mandelbrot(size: int32):int32
  var line 69 sum: int32; byteAcc: int32; bitNum: int32; y: int32; z: int32; x: int32; escape: int32; line 70 ci: float64; zr: float64; zrzr: float64; zi: float64; zizi: float64; cr: float64; line 71 notDone: bool; 
  begin
    line 73
    ldc_i4_0
    stloc_0
    line 74
    ldc_i4_0
    stloc_1
    line 75
    ldc_i4_0
    stloc_2
    line 76
    ldc_i4_0
    stloc_3
    line 77
    while
      ldloc_3
      ldarg_0
      clt
    do
      line 78
      ldc_r4 2
      ldloc_3
      ldarg_0
      div
      conv_r4
      mul
      ldc_r4 1
      sub
      conv_r8
      stloc_s 7
      line 79
      ldc_i4_0
      stloc_s 5
      line 80
      while
        ldloc_s 5
        ldarg_0
        clt
      do
        line 81
        ldc_r4 0
        conv_r8
        stloc_s 8
        line 82
        ldc_r4 0
        conv_r8
        stloc_s 9
        line 83
        ldc_r4 0
        conv_r8
        stloc_s 10
        line 84
        ldc_r4 0
        conv_r8
        stloc_s 11
        line 85
        ldc_r4 2
        ldloc_s 5
        ldarg_0
        div
        conv_r4
        mul
        ldc_r4 1.5
        sub
        conv_r8
        stloc_s 12
        line 87
        ldc_i4_0
        stloc_s 4
        line 88
        ldc_i4_1
        stloc_s 13
        line 89
        ldc_i4_0
        stloc_s 6
        line 90
        while
          iif
            ldloc_s 13
          then
            ldloc_s 4
            ldc_i4_s 50
            clt
          else
            ldc_i4_0
          end
        do
          line 91
          ldloc_s 9
          ldloc_s 11
          sub
          ldloc_s 12
          add
          stloc_s 8
          line 92
          ldc_r8 2
          ldloc_s 8
          mul
          ldloc_s 10
          mul
          ldloc_s 7
          add
          stloc_s 10
          line 95
          ldloc_s 8
          ldloc_s 8
          mul
          stloc_s 9
          line 96
          ldloc_s 10
          ldloc_s 10
          mul
          stloc_s 11
          line 98
          if
            ldloc_s 9
            ldloc_s 11
            add
            ldc_r8 4
            cgt
          then
            line 99
            ldc_i4_0
            stloc_s 13
            line 100
            ldc_i4_1
            stloc_s 6
            line 101
          end
          line 102
          ldloca_s 4
          dup
          ldind_i4
          ldc_i4_1
          add
          stind_i4
          line 103
        end
        line 105
        ldloc_1
        conv_u4
        ldc_i4_1
        shl
        conv_i4
        ldloc_s 6
        add
        stloc_1
        line 106
        ldloca_s 2
        dup
        ldind_i4
        ldc_i4_1
        add
        stind_i4
        line 110
        if
          ldloc_2
          ldc_i4_8
          ceq
        then
          line 111
          ldloc_0
          conv_u4
          ldloc_1
          conv_u4
          xor
          conv_i4
          stloc_0
          line 112
          ldc_i4_0
          stloc_1
          line 113
          ldc_i4_0
          stloc_2
          line 114
        else
          if
            ldloc_s 5
            ldarg_0
            ldc_i4_1
            sub
            ceq
          then
            line 115
            ldloc_1
            conv_u4
            ldc_i4_8
            ldloc_2
            sub
            conv_u4
            shl
            conv_i4
            stloc_1
            line 116
            ldloc_0
            conv_u4
            ldloc_1
            conv_u4
            xor
            conv_i4
            stloc_0
            line 117
            ldc_i4_0
            stloc_1
            line 118
            ldc_i4_0
            stloc_2
          end
          line 119
        end
        line 120
        ldloca_s 5
        dup
        ldind_i4
        ldc_i4_1
        add
        stind_i4
        line 121
      end
      line 122
      ldloca_s 3
      dup
      ldind_i4
      ldc_i4_1
      add
      stind_i4
      line 123
    end
    line 124
    ldloc_0
    ret
    line 125
  end mandelbrot
  type line 127 _$1 = pointer to Benchmark!Benchmark
  procedure innerBenchmarkLoop(bench: _$1; innerIterations: int32):bool
  begin
    line 129
    ldarg_1
    call mandelbrot
    ldarg_1
    call verifyResult2
    ret
    line 130
  end innerBenchmarkLoop
  type line 132 _$2 = pointer to Benchmark!Benchmark
  procedure benchmark(bench: _$2):int32
  begin
    line 134
    ldc_i4_0
    ldc_i4 134
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Mandelbrot.mic"
    call MIC$!assert
    line 135
  end benchmark
  type line 137 _$3 = pointer to Benchmark!Benchmark
  procedure verifyResult(bench: _$3; result: int32):bool
  begin
    line 139
    ldc_i4_0
    ldc_i4 139
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Mandelbrot.mic"
    call MIC$!assert
    line 140
  end verifyResult
  type line 27 _$4 = pointer to Benchmark!Benchmark
  type line 144 _$5 = pointer to Benchmark!Benchmark
  procedure line 143 create():_$4
  var bench: _$5; 
  begin
    line 146
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    line 147
    ldloc_0
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 148
    ldloc_0
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 149
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 150
    ldloc_0
    ldproc innerBenchmarkLoop
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 151
    ldloc_0
    ret
    line 152
  end create
end line 154 Mandelbrot

// Generated by compiler  on 2025-06-02T23:11:10

module Permute
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Permute.mic"
  import line 26 Benchmark
  type line 32 _$1 = array of int32
  type _$2 = pointer to _$1
  type line 29 Permute = struct 
    line 30 base: Benchmark!Benchmark
    line 31 count: int32
    line 32 v: _$2
  end
  type line 35 _$3 = pointer to Permute
  procedure swap(me: _$3; i: int32; j: int32)
  var line 36 tmp: int32; 
  begin
    line 38
    ldarg_0
    ldfld Permute.v
    ldarg_1
    ldelem_i4
    stloc_0
    line 39
    ldarg_0
    ldfld Permute.v
    ldarg_1
    ldarg_0
    ldfld Permute.v
    ldarg_2
    ldelem_i4
    stelem_i4
    line 40
    ldarg_0
    ldfld Permute.v
    ldarg_2
    ldloc_0
    stelem_i4
    line 41
  end swap
  type line 43 _$4 = pointer to Permute
  procedure permute(me: _$4; n: int32)
  var line 44 n1: int32; i: int32; _$5: int32; 
  begin
    line 46
    ldarg_0
    ldflda Permute.count
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    line 47
    if
      ldarg_1
      ldc_i4_0
      ceq
      ldc_i4_0
      ceq
    then
      line 48
      ldarg_1
      ldc_i4_1
      sub
      stloc_0
      line 49
      ldarg_0
      ldloc_0
      call permute
      line 50
      ldloc_0
      stloc_1
      ldc_i4_0
      stloc_2
      while
        ldloc_1
        ldloc_2
        clt
        ldc_i4_0
        ceq
      do
        line 51
        ldarg_0
        ldloc_0
        ldloc_1
        call swap
        line 52
        ldarg_0
        ldloc_0
        call permute
        line 53
        ldarg_0
        ldloc_0
        ldloc_1
        call swap
        line 50
        ldloc_1
        ldc_i4_m1
        add
        stloc_1
        line 54
      end
      line 55
    end
    line 56
  end permute
  type line 58 _$6 = pointer to Benchmark!Benchmark
  type line 59 _$7 = pointer to Permute
  type line 61 _$8 = pointer to Permute
  procedure benchmark(me: _$6):int32
  var p: _$7; i: int32; 
  begin
    ldarg_0
    castptr Permute
    stloc_0
    line 62
    ldloc_0
    ldc_i4_0
    stfld Permute.count
    line 63
    ldloc_0
    ldflda Permute.v
    ldc_i4_6
    newarr int32
    stind_ip
    line 64
    ldloc_0
    ldc_i4_6
    call permute
    line 65
    ldloc_0
    ldfld Permute.v
    free
    line 66
    ldloc_0
    ldfld Permute.count
    ret
    line 67
  end benchmark
  type line 69 _$9 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$9; result: int32):bool
  begin
    line 71
    ldarg_1
    ldc_i4 8660
    ceq
    ret
    line 72
  end verifyResult
  type line 27 _$10 = pointer to Benchmark!Benchmark
  type line 75 _$11 = pointer to Permute
  procedure line 74 create():_$10
  var per: _$11; 
  begin
    line 77
    ldloca_s 0
    newobj Permute
    stind_ip
    line 78
    ldloc_0
    ldflda Permute.base
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 79
    ldloc_0
    ldflda Permute.base
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 80
    ldloc_0
    ldflda Permute.base
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 81
    ldloc_0
    ldflda Permute.base
    ldnull
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 82
    ldloc_0
    ret
    line 83
  end create
end line 85 Permute

// Generated by compiler  on 2025-06-02T23:11:10

module Object
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Object.mic"
  type line 26 _$1 = pointer to Object
  type _$2 = proc(obj: _$1)
  type line 25 Object* = struct 
    line 26 deinit: _$2
    line 27 refCount: int32
  end
  type line 30 _$3 = pointer to Object
  type _$4 = pointer to Object
  type _$5 = proc(obj: _$4)
  procedure init(obj: _$3; deinitProc: _$5)
  begin
    line 32
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      line 33
      ldarg_0
      ldarg_1
      stfld Object.deinit
      line 34
      ldarg_0
      ldc_i4_0
      stfld Object.refCount
      line 35
    end
    line 36
  end init
  type line 38 _$6 = pointer to Object
  procedure addRef(obj: _$6)
  begin
    line 40
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      line 41
      ldarg_0
      ldflda Object.refCount
      dup
      ldind_i4
      ldc_i4_1
      add
      stind_i4
      line 42
    end
    line 43
  end addRef
  type line 45 _$7 = pointer to Object
  procedure release(obj: _$7)
  begin
    line 47
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      line 48
      ldarg_0
      ldflda Object.refCount
      dup
      ldind_i4
      ldc_i4_1
      sub
      stind_i4
      line 49
      if
        ldarg_0
        ldfld Object.refCount
        ldc_i4_0
        ceq
      then
        line 50
        if
          ldarg_0
          ldfld Object.deinit
          ldnull
          ceq
          ldc_i4_0
          ceq
        then
          line 51
          ldarg_0
          ldarg_0
          ldfld Object.deinit
          calli _$2
          line 52
        end
        line 53
        ldarg_0
        free
        line 54
      end
      line 55
    end
    line 56
  end release
end line 58 Object

// Generated by compiler  on 2025-06-02T23:11:10

module List
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/List.mic"
  import line 25 Object
  import Benchmark
  type line 31 _$1 = pointer to Element
  type line 28 Element = struct 
    line 29 base: Object!Object
    line 30 val: int32
    line 31 next: _$1
  end
  type line 41 _$2 = pointer to Element
  type _$3 = pointer to Element
  procedure Element_setNext(me: _$2; e: _$3)
  begin
    line 44
    if
      ldarg_0
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      line 45
      ldarg_0
      ldfld Element.next
      call Object!release
      line 46
    end
    line 47
    ldarg_0
    ldarg_1
    stfld Element.next
    line 48
  end Element_setNext
  type line 50 _$4 = pointer to Object!Object
  type line 52 _$5 = pointer to Element
  type line 55 _$6 = pointer to Element
  procedure Element_deinit(me: _$4)
  var elem: _$5; 
  begin
    ldarg_0
    castptr Element
    stloc_0
    line 56
    ldloc_0
    ldnull
    call Element_setNext
    line 57
  end Element_deinit
  type line 28 _$7 = pointer to Element
  type line 60 _$8 = pointer to Element
  type line 64 _$9 = pointer to Object!Object
  type line 65 _$10 = pointer to Object!Object
  procedure line 59 Element_create(v: int32):_$7
  var e: _$8; 
  begin
    line 63
    ldloca_s 0
    newobj Element
    stind_ip
    ldloc_0
    ldflda Element.base
    ldproc Element_deinit
    call Object!init
    ldloc_0
    ldflda Element.base
    call Object!addRef
    line 66
    ldloc_0
    ldarg_0
    stfld Element.val
    line 67
    ldloc_0
    ldnull
    stfld Element.next
    line 68
    ldloc_0
    ret
    line 69
  end Element_create
  type line 71 _$11 = pointer to Element
  procedure Element_length(me: _$11):int32
  begin
    line 73
    if
      ldarg_0
      ldfld Element.next
      ldnull
      ceq
    then
      line 74
      ldc_i4_1
      ret
      line 75
    else
      line 76
      ldc_i4_1
      ldarg_0
      ldfld Element.next
      call Element_length
      add
      ret
      line 77
    end
    line 78
  end Element_length
  type line 80 _$12 = pointer to Element
  type line 28 _$13 = pointer to Element
  procedure line 80 Element_getNext(me: _$12):_$13
  begin
    line 82
    ldarg_0
    ldfld Element.next
    ret
    line 83
  end Element_getNext
  type line 85 _$14 = pointer to Element
  procedure Element_setVal(me: _$14; v: int32)
  begin
    line 87
    ldarg_0
    ldarg_1
    stfld Element.val
    line 88
  end Element_setVal
  type line 90 _$15 = pointer to Element
  procedure Element_getVal(me: _$15):int32
  begin
    line 92
    ldarg_0
    ldfld Element.val
    ret
    line 93
  end Element_getVal
  type line 28 _$16 = pointer to Element
  type line 96 _$17 = pointer to Element
  procedure line 95 makeList(length: int32):_$16
  var e: _$17; 
  begin
    line 99
    if
      ldarg_0
      ldc_i4_0
      ceq
    then
      line 100
      ldnull
      ret
      line 101
    else
      line 102
      ldarg_0
      call Element_create
      stloc_0
      line 103
      ldloc_0
      ldarg_0
      ldc_i4_1
      sub
      call makeList
      call Element_setNext
      line 104
      ldloc_0
      ret
      line 105
    end
    line 106
  end makeList
  type line 108 _$18 = pointer to Element
  type line 110 _$19 = pointer to Element
  procedure isShorterThan(x: _$18; y: _$18):bool
  var xTail: _$19; yTail: _$19; 
  begin
    line 112
    ldarg_0
    stloc_0
    line 113
    ldarg_1
    stloc_1
    line 114
    while
      ldloc_1
      ldnull
      ceq
      ldc_i4_0
      ceq
    do
      line 115
      if
        ldloc_0
        ldnull
        ceq
      then
        line 116
        ldc_i4_1
        ret
        line 117
      end
      line 118
      ldloc_0
      call Element_getNext
      stloc_0
      line 119
      ldloc_1
      call Element_getNext
      stloc_1
      line 120
    end
    line 121
    ldc_i4_0
    ret
    line 122
  end isShorterThan
  type line 124 _$20 = pointer to Element
  type line 28 _$21 = pointer to Element
  type line 126 _$22 = pointer to Element
  type line 134 _$23 = pointer to Object!Object
  type line 135 _$24 = pointer to Object!Object
  type line 136 _$25 = pointer to Object!Object
  type line 139 _$26 = pointer to Object!Object
  procedure line 124 tail(x: _$20; y: _$20; z: _$20):_$21
  var xx: _$22; yy: _$22; zz: _$22; res: _$22; 
  begin
    line 129
    if
      ldarg_1
      ldarg_0
      call isShorterThan
    then
      line 130
      ldarg_0
      call Element_getNext
      ldarg_1
      ldarg_2
      call tail
      stloc_0
      line 131
      ldarg_1
      call Element_getNext
      ldarg_2
      ldarg_0
      call tail
      stloc_1
      line 132
      ldarg_2
      call Element_getNext
      ldarg_0
      ldarg_1
      call tail
      stloc_2
      line 133
      ldloc_0
      ldloc_1
      ldloc_2
      call tail
      stloc_3
      ldloc_0
      ldflda Element.base
      call Object!release
      ldloc_1
      ldflda Element.base
      call Object!release
      ldloc_2
      ldflda Element.base
      call Object!release
      line 137
    else
      line 138
      ldarg_2
      stloc_3
      ldarg_2
      ldflda Element.base
      call Object!addRef
      line 140
    end
    line 141
    ldloc_3
    ret
    line 142
  end tail
  type line 144 _$27 = pointer to Benchmark!Benchmark
  type line 146 _$28 = pointer to Element
  type line 153 _$29 = pointer to Object!Object
  type line 154 _$30 = pointer to Object!Object
  type line 155 _$31 = pointer to Object!Object
  type line 156 _$32 = pointer to Object!Object
  procedure benchmark(bench: _$27):int32
  var x: _$28; y: _$28; z: _$28; resultElem: _$28; res: int32; 
  begin
    line 148
    ldc_i4_s 15
    call makeList
    stloc_0
    line 149
    ldc_i4_s 10
    call makeList
    stloc_1
    line 150
    ldc_i4_6
    call makeList
    stloc_2
    line 151
    ldloc_0
    ldloc_1
    ldloc_2
    call tail
    stloc_3
    line 152
    ldloc_3
    call Element_length
    stloc_s 4
    ldloc_3
    ldflda Element.base
    call Object!release
    ldloc_0
    ldflda Element.base
    call Object!release
    ldloc_1
    ldflda Element.base
    call Object!release
    ldloc_2
    ldflda Element.base
    call Object!release
    line 157
    ldloc_s 4
    ret
    line 158
  end benchmark
  type line 160 _$33 = pointer to Benchmark!Benchmark
  procedure verifyResult(bench: _$33; result: int32):bool
  begin
    line 162
    ldc_i4_s 10
    ldarg_1
    ceq
    ret
    line 163
  end verifyResult
  type line 27 _$34 = pointer to Benchmark!Benchmark
  type line 167 _$35 = pointer to Benchmark!Benchmark
  procedure line 165 create():_$34
  var bench: _$35; 
  begin
    line 169
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    line 170
    ldloc_0
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 171
    ldloc_0
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 172
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 173
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 174
    ldloc_0
    ret
    line 175
  end create
end line 177 List

// Generated by compiler  on 2025-06-02T23:11:10

module Queens
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Queens.mic"
  import line 26 Benchmark
  type line 29 _$1 = array of bool
  type BoolArray = pointer to _$1
  type line 30 _$2 = array of int32
  type IntArray = pointer to _$2
  type line 32 Queens = struct 
    line 33 base: Benchmark!Benchmark
    line 34 freeMaxs: BoolArray
    line 35 freeRows: BoolArray
    line 36 freeMins: BoolArray
    line 37 queenRows: IntArray
  end
  type line 40 _$3 = pointer to Queens
  procedure getRowColumn(me: _$3; r: int32; c: int32):bool
  begin
    line 42
    iif
      iif
        ldarg_0
        ldfld Queens.freeRows
        ldarg_1
        ldelem_u1
      then
        ldarg_0
        ldfld Queens.freeMaxs
        ldarg_2
        ldarg_1
        add
        ldelem_u1
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld Queens.freeMins
      ldarg_2
      ldarg_1
      sub
      ldc_i4_7
      add
      ldelem_u1
    else
      ldc_i4_0
    end
    ret
    line 43
  end getRowColumn
  type line 45 _$4 = pointer to Queens
  procedure setRowColumn(me: _$4; r: int32; c: int32; v: bool)
  begin
    line 47
    ldarg_0
    ldfld Queens.freeRows
    ldarg_1
    ldarg_3
    stelem_i1
    line 48
    ldarg_0
    ldfld Queens.freeMaxs
    ldarg_2
    ldarg_1
    add
    ldarg_3
    stelem_i1
    line 49
    ldarg_0
    ldfld Queens.freeMins
    ldarg_2
    ldarg_1
    sub
    ldc_i4_7
    add
    ldarg_3
    stelem_i1
    line 50
  end setRowColumn
  type line 52 _$5 = pointer to Queens
  procedure placeQueen(me: _$5; c: int32):bool
  var line 54 r: int32; _$6: int32; 
  begin
    line 56
    ldc_i4_0
    stloc_0
    ldc_i4_7
    stloc_1
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      line 57
      if
        ldarg_0
        ldloc_0
        ldarg_1
        call getRowColumn
      then
        line 58
        ldarg_0
        ldfld Queens.queenRows
        ldloc_0
        ldarg_1
        stelem_i4
        line 59
        ldarg_0
        ldloc_0
        ldarg_1
        ldc_i4_0
        call setRowColumn
        line 60
        if
          ldarg_1
          ldc_i4_7
          ceq
        then
          line 61
          ldc_i4_1
          ret
          line 62
        end
        line 63
        if
          ldarg_0
          ldarg_1
          ldc_i4_1
          add
          call placeQueen
        then
          line 64
          ldc_i4_1
          ret
          line 65
        end
        line 66
        ldarg_0
        ldloc_0
        ldarg_1
        ldc_i4_1
        call setRowColumn
        line 67
      end
      line 56
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 68
    end
    line 69
    ldc_i4_0
    ret
    line 70
  end placeQueen
  type line 72 _$7 = pointer to Queens
  procedure queens(me: _$7):bool
  var line 74 i: int32; line 75 res: bool; _$8: int32; _$9: int32; 
  begin
    line 78
    ldarg_0
    ldflda Queens.freeRows
    ldc_i4_8
    newarr bool
    stind_ip
    line 79
    ldarg_0
    ldflda Queens.freeMaxs
    ldc_i4_s 16
    newarr bool
    stind_ip
    line 80
    ldarg_0
    ldflda Queens.freeMins
    ldc_i4_s 16
    newarr bool
    stind_ip
    line 81
    ldarg_0
    ldflda Queens.queenRows
    ldc_i4_8
    newarr int32
    stind_ip
    line 83
    ldc_i4_0
    stloc_0
    ldc_i4_7
    stloc_2
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      line 84
      ldarg_0
      ldfld Queens.freeRows
      ldloc_0
      ldc_i4_1
      stelem_i1
      line 85
      ldarg_0
      ldfld Queens.queenRows
      ldloc_0
      ldc_i4_m1
      stelem_i4
      line 83
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 86
    end
    line 88
    ldc_i4_0
    stloc_0
    ldc_i4_s 15
    stloc_3
    while
      ldloc_0
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      line 89
      ldarg_0
      ldfld Queens.freeMaxs
      ldloc_0
      ldc_i4_1
      stelem_i1
      line 90
      ldarg_0
      ldfld Queens.freeMins
      ldloc_0
      ldc_i4_1
      stelem_i1
      line 88
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 91
    end
    line 93
    ldarg_0
    ldc_i4_0
    call placeQueen
    stloc_1
    line 95
    ldarg_0
    ldfld Queens.freeRows
    free
    line 96
    ldarg_0
    ldfld Queens.freeMaxs
    free
    line 97
    ldarg_0
    ldfld Queens.freeMins
    free
    line 98
    ldarg_0
    ldfld Queens.queenRows
    free
    line 100
    ldloc_1
    ret
    line 101
  end queens
  type line 103 _$10 = pointer to Benchmark!Benchmark
  type line 110 _$12 = pointer to Queens
  procedure benchmark(me: _$10):int32
  var line 105 i: int32; line 106 resultBool: bool; _$11: int32; 
  begin
    line 108
    ldc_i4_1
    stloc_1
    line 109
    ldc_i4_0
    stloc_0
    ldc_i4_s 9
    stloc_2
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      iif
        ldloc_1
      then
        ldarg_0
        castptr Queens
        call queens
      else
        ldc_i4_0
      end
      stloc_1
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 111
    end
    line 112
    if
      ldloc_1
    then
      ldc_i4_1
      ret
    else
      ldc_i4_0
      ret
    end
    line 113
  end benchmark
  type line 115 _$13 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$13; result: int32):bool
  begin
    line 117
    ldarg_1
    ldc_i4_0
    ceq
    ldc_i4_0
    ceq
    ret
    line 118
  end verifyResult
  type line 32 _$14 = pointer to Queens
  type line 122 _$15 = pointer to Queens
  procedure line 120 create():_$14
  var q: _$15; 
  begin
    line 124
    ldloca_s 0
    newobj Queens
    stind_ip
    line 125
    ldloc_0
    ldflda Queens.base
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 126
    ldloc_0
    ldflda Queens.base
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 127
    ldloc_0
    ldflda Queens.base
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 128
    ldloc_0
    ldflda Queens.base
    ldnull
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 129
    ldloc_0
    ret
    line 130
  end create
end line 132 Queens

// Generated by compiler  on 2025-06-02T23:11:10

module Sieve
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Sieve.mic"
  import line 26 Benchmark
  type line 28 _$1 = array of bool
  type _$2 = pointer to _$1
  procedure sieve(flags: _$2; size: int32):int32
  var line 29 primeCount: int32; i: int32; k: int32; _$3: int32; 
  begin
    line 31
    ldc_i4_0
    stloc_0
    line 33
    ldc_i4_2
    stloc_1
    ldarg_1
    stloc_3
    while
      ldloc_1
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      line 34
      if
        ldarg_0
        ldloc_1
        ldc_i4_1
        sub
        ldelem_u1
      then
        line 35
        ldloca_s 0
        dup
        ldind_i4
        ldc_i4_1
        add
        stind_i4
        line 36
        ldloc_1
        ldloc_1
        add
        stloc_2
        line 37
        while
          ldloc_2
          ldarg_1
          cgt
          ldc_i4_0
          ceq
        do
          line 38
          ldarg_0
          ldloc_2
          ldc_i4_1
          sub
          ldc_i4_0
          stelem_i1
          line 39
          ldloc_2
          ldloc_1
          add
          stloc_2
          line 40
        end
        line 41
      end
      line 33
      ldloc_1
      ldc_i4_1
      add
      stloc_1
      line 42
    end
    line 43
    ldloc_0
    ret
    line 44
  end sieve
  type line 46 _$4 = pointer to Benchmark!Benchmark
  type line 49 _$5 = array of bool
  type _$6 = pointer to _$5
  procedure benchmark(me: _$4):int32
  var line 48 i: int32; res: int32; flags: _$6; _$7: int32; 
  begin
    line 51
    ldloca_s 2
    ldc_i4 5000
    newarr bool
    stind_ip
    line 52
    ldc_i4_0
    stloc_0
    ldc_i4 4999
    stloc_3
    while
      ldloc_0
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      line 53
      ldloc_2
      ldloc_0
      ldc_i4_1
      stelem_i1
      line 52
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 54
    end
    line 55
    ldloc_2
    ldc_i4 5000
    call sieve
    stloc_1
    line 56
    ldloc_2
    free
    line 57
    ldloc_1
    ret
    line 58
  end benchmark
  type line 60 _$8 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$8; result: int32):bool
  begin
    line 62
    ldc_i4 669
    ldarg_1
    ceq
    ret
    line 63
  end verifyResult
  type line 27 _$9 = pointer to Benchmark!Benchmark
  type line 66 _$10 = pointer to Benchmark!Benchmark
  procedure line 65 create():_$9
  var bench: _$10; 
  begin
    line 68
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    line 69
    ldloc_0
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 70
    ldloc_0
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 71
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 72
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 73
    ldloc_0
    ret
    line 74
  end create
end line 76 Sieve

// Generated by compiler  on 2025-06-02T23:11:10

module Storage
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Storage.mic"
  import line 26 Random
  import Benchmark
  type line 29 Storage = struct 
    line 30 base: Benchmark!Benchmark
    line 31 count: int32
  end
  type line 35 _$1 = pointer to TreeArrayArray
  type line 34 TreeArray = struct 
    line 35 arr: _$1
    line 36 len: uint32
  end
  type line 39 TreeArrayArray = array of TreeArray
  type line 41 _$2 = pointer to TreeArray
  type line 46 _$4 = pointer to TreeArray
  procedure freeTree(ta: _$2)
  var line 42 i: int32; t: TreeArray; _$3: int32; 
  begin
    line 44
    ldc_i4_0
    stloc_0
    ldarg_0
    ldfld TreeArray.len
    ldc_i4_1
    sub
    stloc_2
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      line 45
      ldarg_0
      ldfld TreeArray.arr
      ldloc_0
      ldelem TreeArray
      stloc_1
      ldloca_s 1
      call freeTree
      line 44
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 47
    end
    line 48
    if
      ldarg_0
      ldfld TreeArray.arr
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      ldarg_0
      ldfld TreeArray.arr
      free
    end
    line 49
    ldarg_0
    ldc_i4_0
    stfld TreeArray.len
    line 50
    ldarg_0
    ldnull
    stfld TreeArray.arr
    line 51
  end freeTree
  type line 53 _$5 = pointer to Storage
  procedure buildTreeDepth(me: _$5; depth: int32):TreeArray
  var line 54 res: TreeArray; i: int32; _$6: int32; _$7: int32; 
  begin
    line 56
    ldarg_0
    ldflda Storage.count
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    line 57
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      line 58
      ldloca_s 0
      call Random!next
      ldc_i4_s 10
      rem_un
      ldc_i4_1
      add
      stfld TreeArray.len
      line 59
      ldloca_s 0
      ldflda TreeArray.arr
      ldloca_s 0
      ldfld TreeArray.len
      newarr TreeArray
      stind_ip
      line 60
      ldc_i4_0
      stloc_1
      ldloca_s 0
      ldfld TreeArray.len
      ldc_i4_1
      sub
      stloc_2
      while
        ldloc_1
        ldloc_2
        cgt
        ldc_i4_0
        ceq
      do
        line 61
        ldloca_s 0
        ldfld TreeArray.arr
        ldloc_1
        ldelema TreeArray
        ldc_i4_0
        stfld TreeArray.len
        line 62
        ldloca_s 0
        ldfld TreeArray.arr
        ldloc_1
        ldelema TreeArray
        ldnull
        stfld TreeArray.arr
        line 60
        ldloc_1
        ldc_i4_1
        add
        stloc_1
        line 63
      end
      line 64
      ldloc_0
      ret
      line 65
    else
      line 66
      ldloca_s 0
      ldc_i4_4
      stfld TreeArray.len
      line 67
      ldloca_s 0
      ldflda TreeArray.arr
      ldloca_s 0
      ldfld TreeArray.len
      newarr TreeArray
      stind_ip
      line 68
      ldc_i4_0
      stloc_1
      ldloca_s 0
      ldfld TreeArray.len
      ldc_i4_1
      sub
      stloc_3
      while
        ldloc_1
        ldloc_3
        cgt
        ldc_i4_0
        ceq
      do
        line 69
        ldloca_s 0
        ldfld TreeArray.arr
        ldloc_1
        ldarg_0
        ldarg_1
        ldc_i4_1
        sub
        call buildTreeDepth
        stelem TreeArray
        line 68
        ldloc_1
        ldc_i4_1
        add
        stloc_1
        line 70
      end
      line 71
      ldloc_0
      ret
      line 72
    end
    line 73
  end buildTreeDepth
  type line 75 _$8 = pointer to Benchmark!Benchmark
  type line 76 _$9 = pointer to Storage
  type line 78 _$10 = pointer to Storage
  type line 82 _$11 = pointer to TreeArray
  procedure benchmark(me: _$8):int32
  var s: _$9; arr: TreeArray; 
  begin
    ldarg_0
    castptr Storage
    stloc_0
    line 79
    call Random!reset
    line 80
    ldloc_0
    ldc_i4_0
    stfld Storage.count
    line 81
    ldloc_0
    ldc_i4_7
    call buildTreeDepth
    stloc_1
    ldloca_s 1
    call freeTree
    line 83
    ldloc_0
    ldfld Storage.count
    ret
    line 84
  end benchmark
  type line 86 _$12 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$12; result: int32):bool
  begin
    line 88
    ldc_i4 5461
    ldarg_1
    ceq
    ret
    line 89
  end verifyResult
  type line 27 _$13 = pointer to Benchmark!Benchmark
  type line 92 _$14 = pointer to Storage
  procedure line 91 create():_$13
  var s: _$14; 
  begin
    line 94
    ldloca_s 0
    newobj Storage
    stind_ip
    line 95
    ldloc_0
    ldflda Storage.base
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 96
    ldloc_0
    ldflda Storage.base
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 97
    ldloc_0
    ldflda Storage.base
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 98
    ldloc_0
    ldflda Storage.base
    ldnull
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 99
    ldloc_0
    ret
    line 100
  end create
end line 102 Storage

// Generated by compiler  on 2025-06-02T23:11:10

module Towers
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Towers.mic"
  import line 26 Benchmark
  type line 34 _$1 = pointer to TowersDisk
  type line 32 TowersDisk = struct 
    line 33 size: int32
    line 34 next: _$1
  end
  type line 39 _$2 = pointer to TowersDisk
  type _$3 = array 3 of _$2
  type line 37 Towers = struct 
    line 38 base: Benchmark!Benchmark
    line 39 piles: _$3
    line 40 movesDone: int32
  end
  type line 43 _$4 = pointer to TowersDisk
  procedure TowersDisk_dispose(me: _$4)
  begin
    line 45
    if
      ldarg_0
      ldfld TowersDisk.next
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      line 46
      ldarg_0
      ldfld TowersDisk.next
      call TowersDisk_dispose
      line 47
    end
    line 48
    ldarg_0
    free
    line 49
  end TowersDisk_dispose
  type line 32 _$5 = pointer to TowersDisk
  type line 52 _$6 = pointer to TowersDisk
  procedure line 51 TowersDisk_create(size: int32):_$5
  var d: _$6; 
  begin
    line 54
    ldloca_s 0
    newobj TowersDisk
    stind_ip
    line 55
    ldloc_0
    ldnull
    stfld TowersDisk.next
    line 56
    ldloc_0
    ldarg_0
    stfld TowersDisk.size
    line 57
    ldloc_0
    ret
    line 58
  end TowersDisk_create
  type line 60 _$7 = pointer to TowersDisk
  procedure TowersDisk_getSize(me: _$7):int32
  begin
    line 62
    ldarg_0
    ldfld TowersDisk.size
    ret
    line 63
  end TowersDisk_getSize
  type line 65 _$8 = pointer to TowersDisk
  type line 32 _$9 = pointer to TowersDisk
  procedure line 65 TowersDisk_getNext(me: _$8):_$9
  begin
    line 67
    ldarg_0
    ldfld TowersDisk.next
    ret
    line 68
  end TowersDisk_getNext
  type line 70 _$10 = pointer to TowersDisk
  procedure TowersDisk_setNext(me: _$10; value: _$10)
  begin
    line 72
    ldarg_0
    ldarg_1
    stfld TowersDisk.next
    line 73
  end TowersDisk_setNext
  type line 76 _$11 = pointer to Towers
  type _$12 = pointer to TowersDisk
  type line 77 _$13 = pointer to TowersDisk
  procedure pushDisk(me: _$11; disk: _$12; pile: int32)
  var top: _$13; 
  begin
    line 79
    ldarg_0
    ldflda Towers.piles
    ldarg_2
    ldelem _$2
    stloc_0
    line 80
    if
      iif
        ldloc_0
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        ldarg_1
        call TowersDisk_getSize
        ldloc_0
        call TowersDisk_getSize
        clt
        ldc_i4_0
        ceq
      else
        ldc_i4_0
      end
    then
      line 81
      ldc_i4_0
      ldc_i4_s 81
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Towers.mic"
      call MIC$!assert
      line 82
    end
    line 83
    ldarg_1
    ldloc_0
    call TowersDisk_setNext
    line 84
    ldarg_0
    ldflda Towers.piles
    ldarg_2
    ldarg_1
    stelem _$2
    line 85
  end pushDisk
  type line 87 _$14 = pointer to Towers
  type line 32 _$15 = pointer to TowersDisk
  type line 88 _$16 = pointer to TowersDisk
  procedure line 87 popDiskFrom(me: _$14; pile: int32):_$15
  var top: _$16; 
  begin
    line 90
    ldarg_0
    ldflda Towers.piles
    ldarg_1
    ldelem _$2
    stloc_0
    line 91
    if
      ldloc_0
      ldnull
      ceq
    then
      line 92
      ldc_i4_0
      ldc_i4_s 92
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Towers.mic"
      call MIC$!assert
      line 93
    end
    line 94
    ldarg_0
    ldflda Towers.piles
    ldarg_1
    ldloc_0
    call TowersDisk_getNext
    stelem _$2
    line 95
    ldloc_0
    ldnull
    call TowersDisk_setNext
    line 96
    ldloc_0
    ret
    line 97
  end popDiskFrom
  type line 99 _$17 = pointer to Towers
  procedure moveTopDisk(me: _$17; fromPile: int32; toPile: int32)
  begin
    line 101
    ldarg_0
    ldarg_0
    ldarg_1
    call popDiskFrom
    ldarg_2
    call pushDisk
    line 102
    ldarg_0
    ldflda Towers.movesDone
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    line 103
  end moveTopDisk
  type line 105 _$18 = pointer to Towers
  procedure buildTowerAt(me: _$18; pile: int32; disks: int32)
  var line 106 i: int32; _$19: int32; 
  begin
    line 108
    ldarg_2
    stloc_0
    ldc_i4_0
    stloc_1
    while
      ldloc_0
      ldloc_1
      clt
      ldc_i4_0
      ceq
    do
      line 109
      ldarg_0
      ldloc_0
      call TowersDisk_create
      ldarg_1
      call pushDisk
      line 108
      ldloc_0
      ldc_i4_m1
      add
      stloc_0
      line 110
    end
    line 111
  end buildTowerAt
  type line 113 _$20 = pointer to Towers
  procedure moveDisks(me: _$20; disks: int32; fromPile: int32; toPile: int32)
  var line 114 otherPile: int32; 
  begin
    line 116
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      line 117
      ldarg_0
      ldarg_2
      ldarg_3
      call moveTopDisk
      line 118
    else
      line 119
      ldc_i4_3
      ldarg_2
      sub
      ldarg_3
      sub
      stloc_0
      line 120
      ldarg_0
      ldarg_1
      ldc_i4_1
      sub
      ldarg_2
      ldloc_0
      call moveDisks
      line 121
      ldarg_0
      ldarg_2
      ldarg_3
      call moveTopDisk
      line 122
      ldarg_0
      ldarg_1
      ldc_i4_1
      sub
      ldloc_0
      ldarg_3
      call moveDisks
      line 123
    end
    line 124
  end moveDisks
  type line 126 _$21 = pointer to Benchmark!Benchmark
  type _$22 = pointer to Towers
  type line 129 _$23 = pointer to Towers
  procedure benchmark(b: _$21):int32
  var line 127 i: int32; me: _$22; _$24: int32; _$25: int32; 
  begin
    ldarg_0
    castptr Towers
    stloc_1
    line 130
    ldc_i4_0
    stloc_0
    ldc_i4_2
    stloc_2
    while
      ldloc_0
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      line 131
      ldloc_1
      ldflda Towers.piles
      ldloc_0
      ldnull
      stelem _$2
      line 130
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 132
    end
    line 133
    ldloc_1
    ldc_i4_0
    ldc_i4_s 13
    call buildTowerAt
    line 134
    ldloc_1
    ldc_i4_0
    stfld Towers.movesDone
    line 135
    ldloc_1
    ldc_i4_s 13
    ldc_i4_0
    ldc_i4_1
    call moveDisks
    line 136
    ldc_i4_0
    stloc_0
    ldc_i4_2
    stloc_3
    while
      ldloc_0
      ldloc_3
      cgt
      ldc_i4_0
      ceq
    do
      line 137
      if
        ldloc_1
        ldflda Towers.piles
        ldloc_0
        ldelem _$2
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        line 138
        ldloc_1
        ldflda Towers.piles
        ldloc_0
        ldelem _$2
        call TowersDisk_dispose
        line 139
      end
      line 136
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 140
    end
    line 141
    ldloc_1
    ldfld Towers.movesDone
    ret
    line 142
  end benchmark
  type line 144 _$26 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$26; result: int32):bool
  begin
    line 146
    ldc_i4 8191
    ldarg_1
    ceq
    ret
    line 147
  end verifyResult
  type line 27 _$27 = pointer to Benchmark!Benchmark
  type line 150 _$28 = pointer to Towers
  procedure line 149 create():_$27
  var t: _$28; 
  begin
    line 152
    ldloca_s 0
    newobj Towers
    stind_ip
    line 153
    ldloc_0
    ldflda Towers.base
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 154
    ldloc_0
    ldflda Towers.base
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 155
    ldloc_0
    ldflda Towers.base
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 156
    ldloc_0
    ldflda Towers.base
    ldnull
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 157
    ldloc_0
    ret
    line 158
  end create
end line 160 Towers

// Generated by compiler  on 2025-06-02T23:11:10

module MathL
  source "/home/me/Entwicklung/Modules/Micron/oakwood/MathL.mic"
  procedure line 6 sqrt(x: float64):float64 extern 
  procedure line 7 power(x: float64; base: float64):float64 extern 
  procedure line 8 exp(x: float64):float64 extern 
  procedure line 9 ln(x: float64):float64 extern 
  procedure line 10 log(x: float64; base: float64):float64 extern 
  procedure line 11 round(x: float64):float64 extern 
  procedure line 12 sin(x: float64):float64 extern 
  procedure line 13 cos(x: float64):float64 extern 
  procedure line 14 tan(x: float64):float64 extern 
  procedure line 15 arcsin(x: float64):float64 extern 
  procedure line 16 arccos(x: float64):float64 extern 
  procedure line 17 arctan(x: float64):float64 extern 
  procedure line 18 arctan2(x: float64; y: float64):float64 extern 
  procedure line 19 sinh(x: float64):float64 extern 
  procedure line 20 cosh(x: float64):float64 extern 
  procedure line 21 tanh(x: float64):float64 extern 
  procedure line 22 arcsinh(x: float64):float64 extern 
  procedure line 23 arccosh(x: float64):float64 extern 
  procedure line 24 arctanh(x: float64):float64 extern 
end line 25 MathL

// Generated by compiler  on 2025-06-02T23:11:10

module NBody
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/NBody.mic"
  import line 10 Benchmark
  import MathL
  type line 19 Body = struct 
    line 20 x: float64
    y: float64
    z: float64
    line 21 vx: float64
    vy: float64
    vz: float64
    line 22 mass: float64
  end
  type line 26 _$1 = array 5 of Body
  type line 25 NBodySystem = struct 
    line 26 bodies: _$1
  end
  type line 29 _$2 = pointer to Body
  procedure Body_getX(me: _$2):float64
  begin
    line 31
    ldarg_0
    ldfld Body.x
    ret
    line 32
  end Body_getX
  type line 34 _$3 = pointer to Body
  procedure Body_getY(me: _$3):float64
  begin
    line 36
    ldarg_0
    ldfld Body.y
    ret
    line 37
  end Body_getY
  type line 39 _$4 = pointer to Body
  procedure Body_getZ(me: _$4):float64
  begin
    line 41
    ldarg_0
    ldfld Body.z
    ret
    line 42
  end Body_getZ
  type line 44 _$5 = pointer to Body
  procedure Body_getVX(me: _$5):float64
  begin
    line 46
    ldarg_0
    ldfld Body.vx
    ret
    line 47
  end Body_getVX
  type line 49 _$6 = pointer to Body
  procedure Body_getVY(me: _$6):float64
  begin
    line 51
    ldarg_0
    ldfld Body.vy
    ret
    line 52
  end Body_getVY
  type line 54 _$7 = pointer to Body
  procedure Body_getVZ(me: _$7):float64
  begin
    line 56
    ldarg_0
    ldfld Body.vz
    ret
    line 57
  end Body_getVZ
  type line 59 _$8 = pointer to Body
  procedure Body_getMass(me: _$8):float64
  begin
    line 61
    ldarg_0
    ldfld Body.mass
    ret
    line 62
  end Body_getMass
  type line 64 _$9 = pointer to Body
  procedure Body_setX(me: _$9; x: float64)
  begin
    line 66
    ldarg_0
    ldarg_1
    stfld Body.x
    line 67
  end Body_setX
  type line 69 _$10 = pointer to Body
  procedure Body_setY(me: _$10; y: float64)
  begin
    line 71
    ldarg_0
    ldarg_1
    stfld Body.y
    line 72
  end Body_setY
  type line 74 _$11 = pointer to Body
  procedure Body_setZ(me: _$11; z: float64)
  begin
    line 76
    ldarg_0
    ldarg_1
    stfld Body.z
    line 77
  end Body_setZ
  type line 79 _$12 = pointer to Body
  procedure Body_setVX(me: _$12; vx: float64)
  begin
    line 81
    ldarg_0
    ldarg_1
    stfld Body.vx
    line 82
  end Body_setVX
  type line 84 _$13 = pointer to Body
  procedure Body_setVY(me: _$13; vy: float64)
  begin
    line 86
    ldarg_0
    ldarg_1
    stfld Body.vy
    line 87
  end Body_setVY
  type line 89 _$14 = pointer to Body
  procedure Body_setVZ(me: _$14; vz: float64)
  begin
    line 91
    ldarg_0
    ldarg_1
    stfld Body.vz
    line 92
  end Body_setVZ
  type line 94 _$15 = pointer to Body
  procedure Body_offsetMomentum(me: _$15; px: float64; py: float64; pz: float64)
  begin
    line 96
    ldarg_0
    ldc_r8 0
    ldarg_1
    ldc_r8 39.478417604357432
    div
    sub
    stfld Body.vx
    line 97
    ldarg_0
    ldc_r8 0
    ldarg_2
    ldc_r8 39.478417604357432
    div
    sub
    stfld Body.vy
    line 98
    ldarg_0
    ldc_r8 0
    ldarg_3
    ldc_r8 39.478417604357432
    div
    sub
    stfld Body.vz
    line 99
  end Body_offsetMomentum
  procedure line 101 Body_create(x: float64; y: float64; z: float64; vx: float64; vy: float64; vz: float64; mass: float64):Body
  var line 103 res: Body; 
  begin
    line 105
    ldloca_s 0
    ldarg_0
    stfld Body.x
    line 106
    ldloca_s 0
    ldarg_1
    stfld Body.y
    line 107
    ldloca_s 0
    ldarg_2
    stfld Body.z
    line 108
    ldloca_s 0
    ldarg_3
    ldc_r8 365.24000000000001
    mul
    stfld Body.vx
    line 109
    ldloca_s 0
    ldarg_s 4
    ldc_r8 365.24000000000001
    mul
    stfld Body.vy
    line 110
    ldloca_s 0
    ldarg_s 5
    ldc_r8 365.24000000000001
    mul
    stfld Body.vz
    line 111
    ldloca_s 0
    ldarg_s 6
    ldc_r8 39.478417604357432
    mul
    stfld Body.mass
    line 112
    ldloc_0
    ret
    line 113
  end Body_create
  procedure line 115 Body_jupiter():Body
  begin
    line 118
    ldc_r8 4.8414314424647209
    line 119
    ldc_r8 -1.1603200440274284
    line 120
    ldc_r8 -0.10362204447112311
    line 121
    ldc_r8 0.0016600766427440369
    line 122
    ldc_r8 0.0076990111841974043
    line 123
    ldc_r8 -6.9046001697206302e-05
    line 124
    ldc_r8 0.00095479193842432661
    line 117
    call Body_create
    ret
    line 125
  end Body_jupiter
  procedure line 127 Body_saturn():Body
  begin
    line 130
    ldc_r8 8.3433667182445799
    line 131
    ldc_r8 4.1247985641243048
    line 132
    ldc_r8 -0.40352341711432138
    line 133
    ldc_r8 -0.0027674251072686241
    line 134
    ldc_r8 0.0049985280123491724
    line 135
    ldc_r8 2.3041729757376393e-05
    line 136
    ldc_r8 0.00028588598066613081
    line 129
    call Body_create
    ret
    line 137
  end Body_saturn
  procedure line 139 Body_uranus():Body
  begin
    line 142
    ldc_r8 12.894369562139131
    line 143
    ldc_r8 -15.111151401698631
    line 144
    ldc_r8 -0.22330757889265573
    line 145
    ldc_r8 0.0029646013756476162
    line 146
    ldc_r8 0.0023784717395948095
    line 147
    ldc_r8 -2.9658956854023756e-05
    line 148
    ldc_r8 4.366244043351563e-05
    line 141
    call Body_create
    ret
    line 149
  end Body_uranus
  procedure line 151 Body_neptune():Body
  begin
    line 154
    ldc_r8 15.379697114850917
    line 155
    ldc_r8 -25.919314609987964
    line 156
    ldc_r8 0.17925877295037118
    line 157
    ldc_r8 0.0026806777249038932
    line 158
    ldc_r8 0.001628241700382423
    line 159
    ldc_r8 -9.5159225451971587e-05
    line 160
    ldc_r8 5.1513890204661145e-05
    line 153
    call Body_create
    ret
    line 161
  end Body_neptune
  procedure line 163 Body_sun():Body
  begin
    line 165
    ldc_r4 0
    conv_r8
    ldc_r4 0
    conv_r8
    ldc_r4 0
    conv_r8
    ldc_r4 0
    conv_r8
    ldc_r4 0
    conv_r8
    ldc_r4 0
    conv_r8
    ldc_r4 1
    conv_r8
    call Body_create
    ret
    line 166
  end Body_sun
  type line 168 _$16 = pointer to Body
  procedure test(b: _$16)
  begin
    line 170
    ldarg_0
    ldfld Body.mass
    call MIC$!printF8
    ldc_i4_s 10
    call MIC$!printCh
    line 171
  end test
  type line 173 _$17 = pointer to NBodySystem
  type line 177 _$18 = pointer to Body
  type line 191 _$20 = pointer to Body
  type line 197 _$21 = pointer to Body
  procedure NBodySystem_init(me: _$17)
  var line 175 px: float64; py: float64; pz: float64; line 176 i: int32; b: _$18; line 178 tmp: float64; _$19: int32; 
  begin
    line 180
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_0
    call Body_sun
    stelem Body
    line 181
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_1
    call Body_jupiter
    stelem Body
    line 182
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_2
    call Body_saturn
    stelem Body
    line 183
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_3
    call Body_uranus
    stelem Body
    line 184
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_4
    call Body_neptune
    stelem Body
    line 186
    ldc_r4 0
    conv_r8
    stloc_0
    line 187
    ldc_r4 0
    conv_r8
    stloc_1
    line 188
    ldc_r4 0
    conv_r8
    stloc_2
    line 190
    ldc_i4_0
    stloc_3
    ldc_i4_4
    stloc_s 6
    while
      ldloc_3
      ldloc_s 6
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_3
      ldelema Body
      stloc_s 4
      line 192
      ldloc_0
      ldloc_s 4
      call Body_getVX
      ldloc_s 4
      call Body_getMass
      mul
      add
      stloc_0
      line 193
      ldloc_1
      ldloc_s 4
      call Body_getVY
      ldloc_s 4
      call Body_getMass
      mul
      add
      stloc_1
      line 194
      ldloc_2
      ldloc_s 4
      call Body_getVZ
      ldloc_s 4
      call Body_getMass
      mul
      add
      stloc_2
      line 190
      ldloc_3
      ldc_i4_1
      add
      stloc_3
      line 195
    end
    ldarg_0
    ldflda NBodySystem.bodies
    ldc_i4_0
    ldelema Body
    ldloc_0
    ldloc_1
    ldloc_2
    call Body_offsetMomentum
    line 198
  end NBodySystem_init
  type line 200 _$22 = pointer to NBodySystem
  type line 203 _$23 = pointer to Body
  type line 208 _$25 = pointer to Body
  type line 210 _$27 = pointer to Body
  type line 230 _$29 = pointer to Body
  procedure NBodySystem_advance(me: _$22; dt: float64)
  var line 202 i: int32; j: int32; iBody: _$23; jBody: _$23; line 204 dx: float64; dy: float64; dz: float64; line 205 dSquared: float64; distance: float64; mag: float64; _$24: int32; _$26: int32; _$28: int32; 
  begin
    line 207
    ldc_i4_0
    stloc_0
    ldc_i4_4
    stloc_s 10
    while
      ldloc_0
      ldloc_s 10
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_0
      ldelema Body
      stloc_2
      line 209
      ldloc_0
      ldc_i4_1
      add
      stloc_1
      ldc_i4_4
      stloc_s 11
      while
        ldloc_1
        ldloc_s 11
        cgt
        ldc_i4_0
        ceq
      do
        ldarg_0
        ldflda NBodySystem.bodies
        ldloc_1
        ldelema Body
        stloc_3
        line 211
        ldloc_2
        call Body_getX
        ldloc_3
        call Body_getX
        sub
        stloc_s 4
        line 212
        ldloc_2
        call Body_getY
        ldloc_3
        call Body_getY
        sub
        stloc_s 5
        line 213
        ldloc_2
        call Body_getZ
        ldloc_3
        call Body_getZ
        sub
        stloc_s 6
        line 215
        ldloc_s 4
        ldloc_s 4
        mul
        ldloc_s 5
        ldloc_s 5
        mul
        add
        ldloc_s 6
        ldloc_s 6
        mul
        add
        stloc_s 7
        line 216
        ldloc_s 7
        call MathL!sqrt
        stloc_s 8
        line 217
        ldarg_1
        ldloc_s 7
        ldloc_s 8
        mul
        div
        stloc_s 9
        line 219
        ldloc_2
        ldloc_2
        call Body_getVX
        ldloc_s 4
        ldloc_3
        call Body_getMass
        mul
        ldloc_s 9
        mul
        sub
        call Body_setVX
        line 220
        ldloc_2
        ldloc_2
        call Body_getVY
        ldloc_s 5
        ldloc_3
        call Body_getMass
        mul
        ldloc_s 9
        mul
        sub
        call Body_setVY
        line 221
        ldloc_2
        ldloc_2
        call Body_getVZ
        ldloc_s 6
        ldloc_3
        call Body_getMass
        mul
        ldloc_s 9
        mul
        sub
        call Body_setVZ
        line 223
        ldloc_3
        ldloc_3
        call Body_getVX
        ldloc_s 4
        ldloc_2
        call Body_getMass
        mul
        ldloc_s 9
        mul
        add
        call Body_setVX
        line 224
        ldloc_3
        ldloc_3
        call Body_getVY
        ldloc_s 5
        ldloc_2
        call Body_getMass
        mul
        ldloc_s 9
        mul
        add
        call Body_setVY
        line 225
        ldloc_3
        ldloc_3
        call Body_getVZ
        ldloc_s 6
        ldloc_2
        call Body_getMass
        mul
        ldloc_s 9
        mul
        add
        call Body_setVZ
        line 209
        ldloc_1
        ldc_i4_1
        add
        stloc_1
        line 226
      end
      line 207
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 227
    end
    line 229
    ldc_i4_0
    stloc_0
    ldc_i4_4
    stloc_s 12
    while
      ldloc_0
      ldloc_s 12
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_0
      ldelema Body
      stloc_2
      line 231
      ldloc_2
      ldloc_2
      call Body_getX
      ldarg_1
      ldloc_2
      call Body_getVX
      mul
      add
      call Body_setX
      line 232
      ldloc_2
      ldloc_2
      call Body_getY
      ldarg_1
      ldloc_2
      call Body_getVY
      mul
      add
      call Body_setY
      line 233
      ldloc_2
      ldloc_2
      call Body_getZ
      ldarg_1
      ldloc_2
      call Body_getVZ
      mul
      add
      call Body_setZ
      line 229
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 234
    end
    line 235
  end NBodySystem_advance
  type line 237 _$30 = pointer to NBodySystem
  type line 241 _$31 = pointer to Body
  type line 246 _$33 = pointer to Body
  type line 252 _$35 = pointer to Body
  procedure NBodySystem_energy(me: _$30):float64
  var line 239 e: float64; line 240 i: int32; j: int32; iBody: _$31; jBody: _$31; line 242 dx: float64; dy: float64; dz: float64; distance: float64; _$32: int32; _$34: int32; 
  begin
    line 244
    ldc_r4 0
    conv_r8
    stloc_0
    line 245
    ldc_i4_0
    stloc_1
    ldc_i4_4
    stloc_s 9
    while
      ldloc_1
      ldloc_s 9
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldflda NBodySystem.bodies
      ldloc_1
      ldelema Body
      stloc_3
      line 247
      ldloc_0
      ldc_r8 0.5
      ldloc_3
      call Body_getMass
      mul
      line 248
      ldloc_3
      call Body_getVX
      ldloc_3
      call Body_getVX
      mul
      line 249
      ldloc_3
      call Body_getVY
      ldloc_3
      call Body_getVY
      mul
      line 248
      add
      line 250
      ldloc_3
      call Body_getVZ
      ldloc_3
      call Body_getVZ
      mul
      line 249
      add
      line 248
      mul
      line 247
      add
      stloc_0
      line 251
      ldloc_1
      ldc_i4_1
      add
      stloc_2
      ldc_i4_4
      stloc_s 10
      while
        ldloc_2
        ldloc_s 10
        cgt
        ldc_i4_0
        ceq
      do
        ldarg_0
        ldflda NBodySystem.bodies
        ldloc_2
        ldelema Body
        stloc_s 4
        line 253
        ldloc_3
        call Body_getX
        ldloc_s 4
        call Body_getX
        sub
        stloc_s 5
        line 254
        ldloc_3
        call Body_getY
        ldloc_s 4
        call Body_getY
        sub
        stloc_s 6
        line 255
        ldloc_3
        call Body_getZ
        ldloc_s 4
        call Body_getZ
        sub
        stloc_s 7
        line 256
        ldloc_s 5
        ldloc_s 5
        mul
        ldloc_s 6
        ldloc_s 6
        mul
        add
        ldloc_s 7
        ldloc_s 7
        mul
        add
        call MathL!sqrt
        stloc_s 8
        line 257
        ldloc_0
        ldloc_3
        call Body_getMass
        ldloc_s 4
        call Body_getMass
        mul
        ldloc_s 8
        div
        sub
        stloc_0
        line 251
        ldloc_2
        ldc_i4_1
        add
        stloc_2
        line 258
      end
      line 245
      ldloc_1
      ldc_i4_1
      add
      stloc_1
      line 259
    end
    line 260
    ldloc_0
    ret
    line 261
  end NBodySystem_energy
  procedure line 263 verifyResult2(resultValue: float64; innerIterations: int32):bool
  begin
    line 267
    if
      ldarg_1
      ldc_i4 250000
      ceq
    then
      line 268
      ldarg_0
      abs
      ldc_r8 0.1690859889909308
      sub
      ldc_r8 5.0000000000000002e-14
      clt
      ret
      line 269
    end
    line 270
    if
      ldarg_1
      ldc_i4_1
      ceq
    then
      line 271
      ldarg_0
      abs
      ldc_r8 0.16907495402506745
      sub
      ldc_r8 5.0000000000000002e-14
      clt
      ret
      line 272
    end
    line 275
    ldstr "No verification result for "
    call MIC$!printStr
    ldarg_1
    conv_i8
    call MIC$!printI8
    ldstr " found"
    call MIC$!printStr
    ldc_i4_s 10
    call MIC$!printCh
    line 276
    ldstr "Result is: "
    call MIC$!printStr
    ldarg_0
    call MIC$!printF8
    ldc_i4_s 10
    call MIC$!printCh
    line 278
    ldc_i4_0
    ret
    line 279
  end verifyResult2
  type line 281 _$36 = pointer to Benchmark!Benchmark
  type line 286 _$37 = pointer to NBodySystem
  type line 288 _$39 = pointer to NBodySystem
  type line 290 _$40 = pointer to NBodySystem
  procedure innerBenchmarkLoop(me: _$36; innerIterations: int32):bool
  var line 283 system: NBodySystem; line 284 i: int32; _$38: int32; 
  begin
    ldloca_s 0
    call NBodySystem_init
    line 287
    ldc_i4_0
    stloc_1
    ldarg_1
    ldc_i4_1
    sub
    stloc_2
    while
      ldloc_1
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      ldloca_s 0
      ldc_r4 0.0099999997764825821
      conv_r8
      call NBodySystem_advance
      ldloc_1
      ldc_i4_1
      add
      stloc_1
      line 289
    end
    ldloca_s 0
    call NBodySystem_energy
    ldarg_1
    call verifyResult2
    ret
    line 291
  end innerBenchmarkLoop
  type line 293 _$41 = pointer to Benchmark!Benchmark
  procedure benchmark(me: _$41):int32
  begin
    line 295
    ldc_i4_0
    ldc_i4 295
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/NBody.mic"
    call MIC$!assert
    line 296
    ldc_i4_0
    ret
    line 297
  end benchmark
  type line 299 _$42 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$42; resultVal: int32):bool
  begin
    line 301
    ldc_i4_0
    ldc_i4 301
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/NBody.mic"
    call MIC$!assert
    line 302
    ldc_i4_0
    ret
    line 303
  end verifyResult
  type line 27 _$43 = pointer to Benchmark!Benchmark
  type line 307 _$44 = pointer to Benchmark!Benchmark
  procedure line 305 create():_$43
  var bench: _$44; 
  begin
    line 309
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    line 310
    ldloc_0
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 311
    ldloc_0
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 312
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 313
    ldloc_0
    ldproc innerBenchmarkLoop
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 314
    ldloc_0
    ret
    line 315
  end create
end line 318 NBody

// Generated by compiler  on 2025-06-02T23:11:10

module Richards
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Richards.mic"
  import line 13 Benchmark
  type line 17 _$1 = pointer to RBObject
  type line 16 RBObject = struct 
    line 17 next: _$1
  end
  type line 20 PacketData = array 4 of int32
  type line 24 _$2 = pointer to Packet
  type line 22 Packet = struct 
    line 23 base: RBObject
    line 24 link: _$2
    line 25 identity: int32
    line 26 kind: int32
    line 27 datum: int32
    line 28 data: PacketData
  end
  type line 31 TaskState = struct 
    line 32 base: RBObject
    line 33 packetPending: bool
    line 34 taskWaiting: bool
    line 35 taskHolding: bool
  end
  type line 40 _$3 = pointer to TaskControlBlock
  type line 43 _$4 = pointer to Packet
  type line 44 _$5 = pointer to ProcessFunction
  type line 45 _$6 = pointer to RBObject
  type line 38 TaskControlBlock = struct 
    line 39 base: TaskState
    line 40 link: _$3
    line 41 identity: int32
    line 42 priority: int32
    line 43 input: _$4
    line 44 procedure_: _$5
    line 45 handle: _$6
  end
  type line 50 _$7 = pointer to ProcessFunction
  type _$8 = pointer to Packet
  type _$9 = pointer to RBObject
  type line 38 _$10 = pointer to TaskControlBlock
  type line 50 _$11 = proc(me: _$7; work: _$8; word: _$9):_$10
  type line 48 ProcessFunction = struct 
    line 49 base: RBObject
    line 50 apply: _$11
  end
  type line 55 _$12 = pointer to Packet
  type line 53 DeviceTaskDataRecord = struct 
    line 54 base: RBObject
    line 55 pending: _$12
  end
  type line 60 _$13 = pointer to Packet
  type line 61 _$14 = pointer to Packet
  type line 58 HandlerTaskDataRecord = struct 
    line 59 base: RBObject
    line 60 workIn: _$13
    line 61 deviceIn: _$14
  end
  type line 64 IdleTaskDataRecord = struct 
    line 65 base: RBObject
    line 66 control: int32
    line 67 count: int32
  end
  type line 70 WorkerTaskDataRecord = struct 
    line 71 base: RBObject
    line 72 destination: int32
    line 73 count: int32
  end
  type line 78 _$15 = pointer to TaskControlBlock
  type line 79 _$16 = pointer to TaskControlBlock
  type line 81 _$17 = pointer to TaskControlBlock
  type _$18 = array 6 of _$17
  type line 76 Scheduler = struct 
    line 77 base: RBObject
    line 78 taskList: _$15
    line 79 currentTask: _$16
    line 80 currentTaskIdentity: int32
    line 81 taskTable: _$18
    line 82 queuePacketCount: int32
    line 83 holdCount: int32
    line 84 layout: int32
  end
  type line 89 _$19 = pointer to Scheduler
  type line 87 FP = struct 
    line 88 base: ProcessFunction
    line 89 s: _$19
  end
  type line 107 _$20 = pointer to Packet
  var NO_WORK: _$20
  type line 108 _$21 = pointer to TaskControlBlock
  var NO_TASK: _$21
  type line 109 _$22 = pointer to RBObject
  var toDelete: _$22
  var line 110 TRACING: bool
  type line 113 _$23 = pointer to Scheduler
  type line 38 _$24 = pointer to TaskControlBlock
  procedure line 113 Scheduler_markWaiting(me: _$23):_$24 forward 
  type line 114 _$25 = pointer to Scheduler
  type _$26 = pointer to Packet
  type line 38 _$27 = pointer to TaskControlBlock
  procedure line 114 Scheduler_queuePacket(me: _$25; packet: _$26):_$27 forward 
  type line 115 _$28 = pointer to Scheduler
  procedure Scheduler_trace(me: _$28; id: int32) forward 
  type line 116 _$29 = pointer to Scheduler
  type line 38 _$30 = pointer to TaskControlBlock
  procedure line 116 Scheduler_holdSelf(me: _$29):_$30 forward 
  type line 117 _$31 = pointer to Scheduler
  type line 38 _$32 = pointer to TaskControlBlock
  procedure line 117 Scheduler_release(me: _$31; identity: int32):_$32 forward 
  type line 118 _$33 = pointer to Scheduler
  procedure Scheduler_schedule(me: _$33) forward 
  type line 120 _$34 = pointer to RBObject
  procedure RBObject_init(o: _$34)
  begin
    line 122
    ldarg_0
    ldvar toDelete
    stfld RBObject.next
    line 123
    ldarg_0
    stvar toDelete
    line 124
  end RBObject_init
  type line 126 _$35 = pointer to RBObject
  procedure RBObject_delete(o: _$35)
  begin
    line 128
    if
      ldarg_0
      ldfld RBObject.next
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      line 129
      ldarg_0
      ldfld RBObject.next
      call RBObject_delete
      line 130
    end
    line 131
    ldarg_0
    free
    line 132
  end RBObject_delete
  type line 134 _$36 = pointer to Packet
  type line 22 _$37 = pointer to Packet
  type line 136 _$38 = pointer to Packet
  type line 140 _$39 = pointer to RBObject
  procedure line 134 Packet_create(link: _$36; identity: int32; kind: int32):_$37
  var me: _$38; line 137 i: int32; _$40: int32; 
  begin
    line 139
    ldloca_s 0
    newobj Packet
    stind_ip
    ldloc_0
    ldflda Packet.base
    call RBObject_init
    line 141
    ldloc_0
    ldarg_0
    stfld Packet.link
    line 142
    ldloc_0
    ldarg_1
    stfld Packet.identity
    line 143
    ldloc_0
    ldarg_2
    stfld Packet.kind
    line 144
    ldloc_0
    ldc_i4_0
    stfld Packet.datum
    line 145
    ldc_i4_0
    stloc_1
    ldc_i4_3
    stloc_2
    while
      ldloc_1
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      line 146
      ldloc_0
      ldflda Packet.data
      ldloc_1
      ldc_i4_0
      stelem_i4
      line 145
      ldloc_1
      ldc_i4_1
      add
      stloc_1
      line 147
    end
    line 148
    ldloc_0
    ret
    line 149
  end Packet_create
  type line 151 _$41 = pointer to Packet
  type line 20 _$42 = pointer to PacketData
  type line 153 _$43 = pointer to PacketData
  procedure line 151 Packet_getData(me: _$41):_$42
  begin
    ldarg_0
    ldflda Packet.data
    ret
    line 154
  end Packet_getData
  type line 156 _$44 = pointer to Packet
  procedure Packet_getDatum(me: _$44):int32
  begin
    line 158
    ldarg_0
    ldfld Packet.datum
    ret
    line 159
  end Packet_getDatum
  type line 161 _$45 = pointer to Packet
  procedure Packet_setDatum(me: _$45; someData: int32)
  begin
    line 163
    ldarg_0
    ldarg_1
    stfld Packet.datum
    line 164
  end Packet_setDatum
  type line 166 _$46 = pointer to Packet
  procedure Packet_getIdentity(me: _$46):int32
  begin
    line 168
    ldarg_0
    ldfld Packet.identity
    ret
    line 169
  end Packet_getIdentity
  type line 171 _$47 = pointer to Packet
  procedure Packet_setIdentity(me: _$47; anIdentity: int32)
  begin
    line 173
    ldarg_0
    ldarg_1
    stfld Packet.identity
    line 174
  end Packet_setIdentity
  type line 176 _$48 = pointer to Packet
  procedure Packet_getKind(me: _$48):int32
  begin
    line 178
    ldarg_0
    ldfld Packet.kind
    ret
    line 179
  end Packet_getKind
  type line 181 _$49 = pointer to Packet
  type line 22 _$50 = pointer to Packet
  procedure line 181 Packet_getLink(me: _$49):_$50
  begin
    line 183
    ldarg_0
    ldfld Packet.link
    ret
    line 184
  end Packet_getLink
  type line 186 _$51 = pointer to Packet
  type _$52 = pointer to Packet
  procedure Packet_setLink(me: _$51; aLink: _$52)
  begin
    line 188
    ldarg_0
    ldarg_1
    stfld Packet.link
    line 189
  end Packet_setLink
  type line 191 _$53 = pointer to Packet
  type line 22 _$54 = pointer to Packet
  type line 193 _$55 = pointer to Packet
  procedure line 191 RBObject_append(packet: _$53; queueHead: _$53):_$54
  var mouse: _$55; link: _$55; 
  begin
    line 195
    ldarg_0
    ldvar NO_WORK
    call Packet_setLink
    line 196
    if
      ldarg_1
      ldvar NO_WORK
      ceq
    then
      line 197
      ldarg_0
      ret
      line 198
    end
    line 200
    ldarg_1
    stloc_0
    line 202
    ldloc_0
    call Packet_getLink
    stloc_1
    line 203
    while
      ldvar NO_WORK
      ldloc_1
      ceq
      ldc_i4_0
      ceq
    do
      line 204
      ldloc_1
      stloc_0
      line 205
      ldloc_0
      call Packet_getLink
      stloc_1
      line 206
    end
    line 208
    ldloc_0
    ldarg_0
    call Packet_setLink
    line 209
    ldarg_1
    ret
    line 210
  end RBObject_append
  type line 212 _$56 = pointer to TaskState
  type line 214 _$57 = pointer to RBObject
  procedure TaskState_init(me: _$56)
  begin
    ldarg_0
    ldflda TaskState.base
    call RBObject_init
    line 215
    ldarg_0
    ldc_i4_0
    stfld TaskState.packetPending
    line 216
    ldarg_0
    ldc_i4_0
    stfld TaskState.taskWaiting
    line 217
    ldarg_0
    ldc_i4_0
    stfld TaskState.taskHolding
    line 218
  end TaskState_init
  type line 31 _$58 = pointer to TaskState
  type line 222 _$59 = pointer to TaskState
  procedure line 220 TaskState_create():_$58
  var me: _$59; 
  begin
    line 224
    ldloca_s 0
    newobj TaskState
    stind_ip
    line 225
    ldloc_0
    call TaskState_init
    line 226
    ldloc_0
    ret
    line 227
  end TaskState_create
  type line 229 _$60 = pointer to TaskState
  procedure TaskState_isPacketPending(me: _$60):bool
  begin
    line 231
    ldarg_0
    ldfld TaskState.packetPending
    ret
    line 232
  end TaskState_isPacketPending
  type line 234 _$61 = pointer to TaskState
  procedure TaskState_isTaskHolding(me: _$61):bool
  begin
    line 236
    ldarg_0
    ldfld TaskState.taskHolding
    ret
    line 237
  end TaskState_isTaskHolding
  type line 239 _$62 = pointer to TaskState
  procedure TaskState_isTaskWaiting(me: _$62):bool
  begin
    line 241
    ldarg_0
    ldfld TaskState.taskWaiting
    ret
    line 242
  end TaskState_isTaskWaiting
  type line 244 _$63 = pointer to TaskState
  procedure TaskState_setTaskHolding(me: _$63; b: bool)
  begin
    line 246
    ldarg_0
    ldarg_1
    stfld TaskState.taskHolding
    line 247
  end TaskState_setTaskHolding
  type line 249 _$64 = pointer to TaskState
  procedure TaskState_setTaskWaiting(me: _$64; b: bool)
  begin
    line 251
    ldarg_0
    ldarg_1
    stfld TaskState.taskWaiting
    line 252
  end TaskState_setTaskWaiting
  type line 254 _$65 = pointer to TaskState
  procedure TaskState_setPacketPending(me: _$65; b: bool)
  begin
    line 256
    ldarg_0
    ldarg_1
    stfld TaskState.packetPending
    line 257
  end TaskState_setPacketPending
  type line 259 _$66 = pointer to TaskState
  procedure TaskState_packetPending(me: _$66)
  begin
    line 261
    ldarg_0
    ldc_i4_1
    stfld TaskState.packetPending
    line 262
    ldarg_0
    ldc_i4_0
    stfld TaskState.taskWaiting
    line 263
    ldarg_0
    ldc_i4_0
    stfld TaskState.taskHolding
    line 264
  end TaskState_packetPending
  type line 266 _$67 = pointer to TaskState
  procedure TaskState_running(me: _$67)
  begin
    line 268
    ldarg_0
    ldc_i4_0
    stfld TaskState.packetPending
    line 269
    ldarg_0
    ldc_i4_0
    stfld TaskState.taskWaiting
    line 270
    ldarg_0
    ldc_i4_0
    stfld TaskState.taskHolding
    line 271
  end TaskState_running
  type line 273 _$68 = pointer to TaskState
  procedure TaskState_waiting(me: _$68)
  begin
    line 275
    ldarg_0
    ldc_i4_0
    stfld TaskState.packetPending
    line 276
    ldarg_0
    ldc_i4_0
    stfld TaskState.taskHolding
    line 277
    ldarg_0
    ldc_i4_1
    stfld TaskState.taskWaiting
    line 278
  end TaskState_waiting
  type line 280 _$69 = pointer to TaskState
  procedure TaskState_waitingWithPacket(me: _$69)
  begin
    line 282
    ldarg_0
    ldc_i4_0
    stfld TaskState.taskHolding
    line 283
    ldarg_0
    ldc_i4_1
    stfld TaskState.taskWaiting
    line 284
    ldarg_0
    ldc_i4_1
    stfld TaskState.packetPending
    line 285
  end TaskState_waitingWithPacket
  type line 287 _$70 = pointer to TaskState
  procedure TaskState_isRunning(me: _$70):bool
  begin
    line 289
    iif
      iif
        ldarg_0
        ldfld TaskState.packetPending
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld TaskState.taskWaiting
        ldc_i4_0
        ceq
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld TaskState.taskHolding
      ldc_i4_0
      ceq
    else
      ldc_i4_0
    end
    ret
    line 290
  end TaskState_isRunning
  type line 292 _$71 = pointer to TaskState
  procedure TaskState_isTaskHoldingOrWaiting(me: _$71):bool
  begin
    line 294
    iif
      ldarg_0
      ldfld TaskState.taskHolding
    then
      ldc_i4_1
    else
      iif
        ldarg_0
        ldfld TaskState.packetPending
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld TaskState.taskWaiting
      else
        ldc_i4_0
      end
    end
    ret
    line 295
  end TaskState_isTaskHoldingOrWaiting
  type line 297 _$72 = pointer to TaskState
  procedure TaskState_isWaiting(me: _$72):bool
  begin
    line 299
    iif
      iif
        ldarg_0
        ldfld TaskState.packetPending
        ldc_i4_0
        ceq
      then
        ldarg_0
        ldfld TaskState.taskWaiting
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld TaskState.taskHolding
      ldc_i4_0
      ceq
    else
      ldc_i4_0
    end
    ret
    line 300
  end TaskState_isWaiting
  type line 302 _$73 = pointer to TaskState
  procedure TaskState_isWaitingWithPacket(me: _$73):bool
  begin
    line 304
    iif
      iif
        ldarg_0
        ldfld TaskState.packetPending
      then
        ldarg_0
        ldfld TaskState.taskWaiting
      else
        ldc_i4_0
      end
    then
      ldarg_0
      ldfld TaskState.taskHolding
      ldc_i4_0
      ceq
    else
      ldc_i4_0
    end
    ret
    line 305
  end TaskState_isWaitingWithPacket
  type line 31 _$74 = pointer to TaskState
  type line 309 _$75 = pointer to TaskState
  procedure line 307 TaskState_createPacketPending():_$74
  var t: _$75; 
  begin
    line 311
    call TaskState_create
    stloc_0
    line 312
    ldloc_0
    call TaskState_packetPending
    line 313
    ldloc_0
    ret
    line 314
  end TaskState_createPacketPending
  type line 31 _$76 = pointer to TaskState
  type line 318 _$77 = pointer to TaskState
  procedure line 316 TaskState_createRunning():_$76
  var t: _$77; 
  begin
    line 320
    call TaskState_create
    stloc_0
    line 321
    ldloc_0
    call TaskState_running
    line 322
    ldloc_0
    ret
    line 323
  end TaskState_createRunning
  type line 31 _$78 = pointer to TaskState
  type line 327 _$79 = pointer to TaskState
  procedure line 325 TaskState_createWaiting():_$78
  var t: _$79; 
  begin
    line 329
    call TaskState_create
    stloc_0
    line 330
    ldloc_0
    call TaskState_waiting
    line 331
    ldloc_0
    ret
    line 332
  end TaskState_createWaiting
  type line 31 _$80 = pointer to TaskState
  type line 336 _$81 = pointer to TaskState
  procedure line 334 TaskState_createWaitingWithPacket():_$80
  var t: _$81; 
  begin
    line 338
    call TaskState_create
    stloc_0
    line 339
    ldloc_0
    call TaskState_waitingWithPacket
    line 340
    ldloc_0
    ret
    line 341
  end TaskState_createWaitingWithPacket
  type line 343 _$82 = pointer to TaskControlBlock
  type line 344 _$83 = pointer to Packet
  type _$84 = pointer to TaskState
  type _$85 = pointer to ProcessFunction
  type line 345 _$86 = pointer to RBObject
  type line 38 _$87 = pointer to TaskControlBlock
  type line 347 _$88 = pointer to TaskControlBlock
  type line 350 _$89 = pointer to TaskState
  type line 355 _$90 = pointer to TaskState
  type line 356 _$91 = pointer to TaskState
  type line 357 _$92 = pointer to TaskState
  procedure line 343 TaskControlBlock_create(aLink: _$82; anIdentity: int32; aPriority: int32; line 344 anInitialWorkQueue: _$83; anInitialState: _$84; aBlock: _$85; line 345 aPrivateData: _$86):_$87
  var me: _$88; 
  begin
    line 349
    ldloca_s 0
    newobj TaskControlBlock
    stind_ip
    ldloc_0
    ldflda TaskControlBlock.base
    call TaskState_init
    line 351
    ldloc_0
    ldarg_0
    stfld TaskControlBlock.link
    line 352
    ldloc_0
    ldarg_1
    stfld TaskControlBlock.identity
    line 353
    ldloc_0
    ldarg_2
    stfld TaskControlBlock.priority
    line 354
    ldloc_0
    ldarg_3
    stfld TaskControlBlock.input
    ldloc_0
    ldflda TaskControlBlock.base
    ldarg_s 4
    call TaskState_isPacketPending
    call TaskState_setPacketPending
    ldloc_0
    ldflda TaskControlBlock.base
    ldarg_s 4
    call TaskState_isTaskWaiting
    call TaskState_setTaskWaiting
    ldloc_0
    ldflda TaskControlBlock.base
    ldarg_s 4
    call TaskState_isTaskHolding
    call TaskState_setTaskHolding
    line 358
    ldloc_0
    ldarg_s 5
    stfld TaskControlBlock.procedure_
    line 359
    ldloc_0
    ldarg_s 6
    stfld TaskControlBlock.handle
    line 360
    ldloc_0
    ret
    line 361
  end TaskControlBlock_create
  type line 363 _$93 = pointer to TaskControlBlock
  procedure TaskControlBlock_getIdentity(me: _$93):int32
  begin
    line 365
    ldarg_0
    ldfld TaskControlBlock.identity
    ret
    line 366
  end TaskControlBlock_getIdentity
  type line 368 _$94 = pointer to TaskControlBlock
  type line 38 _$95 = pointer to TaskControlBlock
  procedure line 368 TaskControlBlock_getLink(me: _$94):_$95
  begin
    line 370
    ldarg_0
    ldfld TaskControlBlock.link
    ret
    line 371
  end TaskControlBlock_getLink
  type line 373 _$96 = pointer to TaskControlBlock
  procedure TaskControlBlock_getPriority(me: _$96):int32
  begin
    line 375
    ldarg_0
    ldfld TaskControlBlock.priority
    ret
    line 376
  end TaskControlBlock_getPriority
  type line 378 _$97 = pointer to TaskControlBlock
  type _$98 = pointer to Packet
  type line 379 _$99 = pointer to TaskControlBlock
  type line 38 _$100 = pointer to TaskControlBlock
  type line 383 _$101 = pointer to TaskState
  procedure line 378 TaskControlBlock_addInputAndCheckPriority(me: _$97; packet: _$98; line 379 oldTask: _$99):_$100
  begin
    line 381
    if
      ldarg_0
      ldfld TaskControlBlock.input
      ldvar NO_WORK
      ceq
    then
      line 382
      ldarg_0
      ldarg_1
      stfld TaskControlBlock.input
      ldarg_0
      ldflda TaskControlBlock.base
      ldc_i4_1
      call TaskState_setPacketPending
      line 384
      if
        ldarg_0
        ldfld TaskControlBlock.priority
        ldarg_2
        call TaskControlBlock_getPriority
        cgt
      then
        line 385
        ldarg_0
        ret
        line 386
      end
      line 387
    else
      line 388
      ldarg_0
      ldarg_1
      ldarg_0
      ldfld TaskControlBlock.input
      call RBObject_append
      stfld TaskControlBlock.input
      line 389
    end
    line 390
    ldarg_2
    ret
    line 391
  end TaskControlBlock_addInputAndCheckPriority
  type line 393 _$102 = pointer to TaskControlBlock
  type line 38 _$103 = pointer to TaskControlBlock
  type line 395 _$104 = pointer to Packet
  type _$105 = pointer to TaskState
  type line 401 _$106 = pointer to TaskState
  type line 403 _$107 = pointer to TaskState
  procedure line 393 TaskControlBlock_runTask(me: _$102):_$103
  var message: _$104; 
  begin
    line 397
    if
      ldarg_0
      ldflda TaskControlBlock.base
      call TaskState_isWaitingWithPacket
    then
      line 398
      ldarg_0
      ldfld TaskControlBlock.input
      stloc_0
      line 399
      ldarg_0
      ldloc_0
      call Packet_getLink
      stfld TaskControlBlock.input
      line 400
      if
        ldarg_0
        ldfld TaskControlBlock.input
        ldvar NO_WORK
        ceq
      then
        ldarg_0
        ldflda TaskControlBlock.base
        call TaskState_running
        line 402
      else
        ldarg_0
        ldflda TaskControlBlock.base
        call TaskState_packetPending
        line 404
      end
      line 405
    else
      line 406
      ldvar NO_WORK
      stloc_0
      line 407
    end
    line 408
    ldarg_0
    ldfld TaskControlBlock.procedure_
    ldloc_0
    ldarg_0
    ldfld TaskControlBlock.handle
    ldarg_0
    ldfld TaskControlBlock.procedure_
    ldfld ProcessFunction.apply
    calli _$11
    ret
    line 409
  end TaskControlBlock_runTask
  type line 53 _$108 = pointer to DeviceTaskDataRecord
  type line 413 _$109 = pointer to DeviceTaskDataRecord
  type line 416 _$110 = pointer to RBObject
  procedure line 411 DeviceTaskDataRecord_create():_$108
  var me: _$109; 
  begin
    line 415
    ldloca_s 0
    newobj DeviceTaskDataRecord
    stind_ip
    ldloc_0
    ldflda DeviceTaskDataRecord.base
    call RBObject_init
    line 417
    ldloc_0
    ldvar NO_WORK
    stfld DeviceTaskDataRecord.pending
    line 418
    ldloc_0
    ret
    line 419
  end DeviceTaskDataRecord_create
  type line 421 _$111 = pointer to DeviceTaskDataRecord
  type line 22 _$112 = pointer to Packet
  procedure line 421 DeviceTaskDataRecord_getPending(me: _$111):_$112
  begin
    line 423
    ldarg_0
    ldfld DeviceTaskDataRecord.pending
    ret
    line 424
  end DeviceTaskDataRecord_getPending
  type line 426 _$113 = pointer to DeviceTaskDataRecord
  type _$114 = pointer to Packet
  procedure DeviceTaskDataRecord_setPending(me: _$113; packet: _$114)
  begin
    line 428
    ldarg_0
    ldarg_1
    stfld DeviceTaskDataRecord.pending
    line 429
  end DeviceTaskDataRecord_setPending
  type line 58 _$115 = pointer to HandlerTaskDataRecord
  type line 433 _$116 = pointer to HandlerTaskDataRecord
  type line 436 _$117 = pointer to RBObject
  procedure line 431 HandlerTaskDataRecord_create():_$115
  var me: _$116; 
  begin
    line 435
    ldloca_s 0
    newobj HandlerTaskDataRecord
    stind_ip
    ldloc_0
    ldflda HandlerTaskDataRecord.base
    call RBObject_init
    line 437
    ldloc_0
    ldvar NO_WORK
    stfld HandlerTaskDataRecord.workIn
    line 438
    ldloc_0
    ldvar NO_WORK
    stfld HandlerTaskDataRecord.deviceIn
    line 439
    ldloc_0
    ret
    line 440
  end HandlerTaskDataRecord_create
  type line 442 _$118 = pointer to HandlerTaskDataRecord
  type line 22 _$119 = pointer to Packet
  procedure line 442 HandlerTaskDataRecord_deviceIn(me: _$118):_$119
  begin
    line 444
    ldarg_0
    ldfld HandlerTaskDataRecord.deviceIn
    ret
    line 445
  end HandlerTaskDataRecord_deviceIn
  type line 447 _$120 = pointer to HandlerTaskDataRecord
  type _$121 = pointer to Packet
  procedure HandlerTaskDataRecord_setDeviceIn(me: _$120; aPacket: _$121)
  begin
    line 449
    ldarg_0
    ldarg_1
    stfld HandlerTaskDataRecord.deviceIn
    line 450
  end HandlerTaskDataRecord_setDeviceIn
  type line 452 _$122 = pointer to HandlerTaskDataRecord
  type _$123 = pointer to Packet
  procedure HandlerTaskDataRecord_deviceInAdd(me: _$122; packet: _$123)
  begin
    line 454
    ldarg_0
    ldarg_1
    ldarg_0
    ldfld HandlerTaskDataRecord.deviceIn
    call RBObject_append
    stfld HandlerTaskDataRecord.deviceIn
    line 455
  end HandlerTaskDataRecord_deviceInAdd
  type line 457 _$124 = pointer to HandlerTaskDataRecord
  type line 22 _$125 = pointer to Packet
  procedure line 457 HandlerTaskDataRecord_workIn(me: _$124):_$125
  begin
    line 459
    ldarg_0
    ldfld HandlerTaskDataRecord.workIn
    ret
    line 460
  end HandlerTaskDataRecord_workIn
  type line 462 _$126 = pointer to HandlerTaskDataRecord
  type _$127 = pointer to Packet
  procedure HandlerTaskDataRecord_setWorkIn(me: _$126; aWorkQueue: _$127)
  begin
    line 464
    ldarg_0
    ldarg_1
    stfld HandlerTaskDataRecord.workIn
    line 465
  end HandlerTaskDataRecord_setWorkIn
  type line 467 _$128 = pointer to HandlerTaskDataRecord
  type _$129 = pointer to Packet
  procedure HandlerTaskDataRecord_workInAdd(me: _$128; packet: _$129)
  begin
    line 469
    ldarg_0
    ldarg_1
    ldarg_0
    ldfld HandlerTaskDataRecord.workIn
    call RBObject_append
    stfld HandlerTaskDataRecord.workIn
    line 470
  end HandlerTaskDataRecord_workInAdd
  type line 64 _$130 = pointer to IdleTaskDataRecord
  type line 474 _$131 = pointer to IdleTaskDataRecord
  type line 477 _$132 = pointer to RBObject
  procedure line 472 IdleTaskDataRecord_create():_$130
  var me: _$131; 
  begin
    line 476
    ldloca_s 0
    newobj IdleTaskDataRecord
    stind_ip
    ldloc_0
    ldflda IdleTaskDataRecord.base
    call RBObject_init
    line 478
    ldloc_0
    ldc_i4_1
    stfld IdleTaskDataRecord.control
    line 479
    ldloc_0
    ldc_i4 10000
    stfld IdleTaskDataRecord.count
    line 480
    ldloc_0
    ret
    line 481
  end IdleTaskDataRecord_create
  type line 483 _$133 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_getControl(me: _$133):int32
  begin
    line 485
    ldarg_0
    ldfld IdleTaskDataRecord.control
    ret
    line 486
  end IdleTaskDataRecord_getControl
  type line 488 _$134 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_setControl(me: _$134; aNumber: int32)
  begin
    line 490
    ldarg_0
    ldarg_1
    stfld IdleTaskDataRecord.control
    line 491
  end IdleTaskDataRecord_setControl
  type line 493 _$135 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_getCount(me: _$135):int32
  begin
    line 495
    ldarg_0
    ldfld IdleTaskDataRecord.count
    ret
    line 496
  end IdleTaskDataRecord_getCount
  type line 498 _$136 = pointer to IdleTaskDataRecord
  procedure IdleTaskDataRecord_setCount(me: _$136; aCount: int32)
  begin
    line 500
    ldarg_0
    ldarg_1
    stfld IdleTaskDataRecord.count
    line 501
  end IdleTaskDataRecord_setCount
  type line 70 _$137 = pointer to WorkerTaskDataRecord
  type line 505 _$138 = pointer to WorkerTaskDataRecord
  type line 508 _$139 = pointer to RBObject
  procedure line 503 WorkerTaskDataRecord_create():_$137
  var me: _$138; 
  begin
    line 507
    ldloca_s 0
    newobj WorkerTaskDataRecord
    stind_ip
    ldloc_0
    ldflda WorkerTaskDataRecord.base
    call RBObject_init
    line 509
    ldloc_0
    ldc_i4_2
    stfld WorkerTaskDataRecord.destination
    line 510
    ldloc_0
    ldc_i4_0
    stfld WorkerTaskDataRecord.count
    line 511
    ldloc_0
    ret
    line 512
  end WorkerTaskDataRecord_create
  type line 514 _$140 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_getCount(me: _$140):int32
  begin
    line 516
    ldarg_0
    ldfld WorkerTaskDataRecord.count
    ret
    line 517
  end WorkerTaskDataRecord_getCount
  type line 519 _$141 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_setCount(me: _$141; aCount: int32)
  begin
    line 521
    ldarg_0
    ldarg_1
    stfld WorkerTaskDataRecord.count
    line 522
  end WorkerTaskDataRecord_setCount
  type line 524 _$142 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_getDestination(me: _$142):int32
  begin
    line 526
    ldarg_0
    ldfld WorkerTaskDataRecord.destination
    ret
    line 527
  end WorkerTaskDataRecord_getDestination
  type line 529 _$143 = pointer to WorkerTaskDataRecord
  procedure WorkerTaskDataRecord_setDestination(me: _$143; aHandler: int32)
  begin
    line 531
    ldarg_0
    ldarg_1
    stfld WorkerTaskDataRecord.destination
    line 532
  end WorkerTaskDataRecord_setDestination
  type line 534 _$144 = pointer to Scheduler
  procedure Scheduler_init(me: _$144)
  var line 536 i: int32; _$145: int32; 
  begin
    line 538
    ldarg_0
    ldc_i4_0
    stfld Scheduler.layout
    line 539
    ldarg_0
    ldnull
    stfld Scheduler.currentTask
    line 540
    ldarg_0
    ldc_i4_0
    stfld Scheduler.currentTaskIdentity
    line 541
    ldarg_0
    ldc_i4_0
    stfld Scheduler.queuePacketCount
    line 542
    ldarg_0
    ldc_i4_0
    stfld Scheduler.holdCount
    line 543
    ldc_i4_0
    stloc_0
    ldc_i4_5
    stloc_1
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      line 544
      ldarg_0
      ldflda Scheduler.taskTable
      ldloc_0
      ldvar NO_TASK
      stelem _$17
      line 543
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 545
    end
    line 546
    ldarg_0
    ldvar NO_TASK
    stfld Scheduler.taskList
    line 547
  end Scheduler_init
  type line 549 _$146 = pointer to Scheduler
  type _$147 = pointer to ProcessFunction
  type _$148 = pointer to Packet
  type _$149 = pointer to RBObject
  type line 38 _$150 = pointer to TaskControlBlock
  type line 549 _$151 = proc(me: _$147; work: _$148; word: _$149):_$150
  type line 87 _$152 = pointer to FP
  type line 551 _$153 = pointer to FP
  type line 554 _$154 = pointer to ProcessFunction
  procedure line 549 FP_create(s: _$146; apply: _$151):_$152
  var me: _$153; 
  begin
    line 553
    ldloca_s 0
    newobj FP
    stind_ip
    ldloc_0
    ldflda FP.base
    call RBObject_init
    line 555
    ldloc_0
    ldarg_0
    stfld FP.s
    line 556
    ldloc_0
    ldflda FP.base
    ldarg_1
    stfld ProcessFunction.apply
    line 557
    ldloc_0
    ret
    line 558
  end FP_create
  type line 560 _$155 = pointer to ProcessFunction
  type _$156 = pointer to Packet
  type _$157 = pointer to RBObject
  type line 38 _$158 = pointer to TaskControlBlock
  type line 562 _$159 = pointer to DeviceTaskDataRecord
  type line 563 _$160 = pointer to FP
  type line 564 _$161 = pointer to Packet
  type line 566 _$162 = pointer to DeviceTaskDataRecord
  type line 567 _$163 = pointer to FP
  procedure line 560 createDevice_apply(me: _$155; workArg: _$156; wordArg: _$157):_$158
  var dataRecord: _$159; fp: _$160; functionWork: _$161; 
  begin
    ldarg_2
    castptr DeviceTaskDataRecord
    stloc_0
    ldarg_0
    castptr FP
    stloc_1
    line 568
    ldarg_1
    stloc_2
    line 569
    if
      ldloc_2
      ldvar NO_WORK
      ceq
    then
      line 570
      ldloc_0
      call DeviceTaskDataRecord_getPending
      stloc_2
      line 571
      if
        ldvar NO_WORK
        ldloc_2
        ceq
      then
        line 572
        ldloc_1
        ldfld FP.s
        call Scheduler_markWaiting
        ret
        line 573
      else
        line 574
        ldloc_0
        ldvar NO_WORK
        call DeviceTaskDataRecord_setPending
        line 575
        ldloc_1
        ldfld FP.s
        ldloc_2
        call Scheduler_queuePacket
        ret
        line 576
      end
      line 577
    else
      line 578
      ldloc_0
      ldloc_2
      call DeviceTaskDataRecord_setPending
      line 579
      if
        ldvar TRACING
      then
        line 580
        ldloc_1
        ldfld FP.s
        ldloc_2
        call Packet_getDatum
        call Scheduler_trace
        line 581
      end
      line 582
      ldloc_1
      ldfld FP.s
      call Scheduler_holdSelf
      ret
      line 583
    end
    line 584
  end createDevice_apply
  type line 586 _$164 = pointer to Scheduler
  type _$165 = pointer to Packet
  type line 587 _$166 = pointer to TaskState
  type _$167 = pointer to ProcessFunction
  type _$168 = pointer to RBObject
  type line 589 _$169 = pointer to TaskControlBlock
  procedure line 586 Scheduler_createTask(me: _$164; identity: int32; priority: int32; work: _$165; line 587 state: _$166; aBlock: _$167; data: _$168)
  var t: _$169; 
  begin
    line 591
    ldarg_0
    ldfld Scheduler.taskList
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldarg_s 5
    ldarg_s 6
    call TaskControlBlock_create
    stloc_0
    line 592
    ldarg_0
    ldloc_0
    stfld Scheduler.taskList
    line 593
    ldarg_0
    ldflda Scheduler.taskTable
    ldarg_1
    ldloc_0
    stelem _$17
    line 594
  end Scheduler_createTask
  type line 596 _$170 = pointer to Scheduler
  type _$171 = pointer to Packet
  type _$172 = pointer to TaskState
  type line 598 _$173 = pointer to DeviceTaskDataRecord
  type line 599 _$174 = pointer to FP
  type line 603 _$175 = pointer to ProcessFunction
  procedure Scheduler_createDevice(me: _$170; identity: int32; priority: int32; workPacket: _$171; state: _$172)
  var data: _$173; fp: _$174; 
  begin
    line 601
    call DeviceTaskDataRecord_create
    stloc_0
    line 602
    ldarg_0
    ldproc createDevice_apply
    call FP_create
    stloc_1
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
    line 604
  end Scheduler_createDevice
  type line 606 _$176 = pointer to ProcessFunction
  type _$177 = pointer to Packet
  type _$178 = pointer to RBObject
  type line 38 _$179 = pointer to TaskControlBlock
  type line 608 _$180 = pointer to HandlerTaskDataRecord
  type line 609 _$181 = pointer to FP
  type line 610 _$182 = pointer to Packet
  type line 613 _$183 = pointer to HandlerTaskDataRecord
  type line 614 _$184 = pointer to FP
  procedure line 606 createHandler_apply(me: _$176; work: _$177; word: _$178):_$179
  var dataRecord: _$180; fp: _$181; workPacket: _$182; devicePacket: _$182; line 611 count: int32; 
  begin
    ldarg_2
    castptr HandlerTaskDataRecord
    stloc_0
    ldarg_0
    castptr FP
    stloc_1
    line 615
    if
      ldarg_1
      ldvar NO_WORK
      ceq
      ldc_i4_0
      ceq
    then
      line 616
      if
        ldarg_1
        call Packet_getKind
        ldc_i4_1
        ceq
      then
        line 617
        ldloc_0
        ldarg_1
        call HandlerTaskDataRecord_workInAdd
        line 618
      else
        line 619
        ldloc_0
        ldarg_1
        call HandlerTaskDataRecord_deviceInAdd
        line 620
      end
      line 621
    end
    line 623
    ldloc_0
    call HandlerTaskDataRecord_workIn
    stloc_2
    line 624
    if
      ldloc_2
      ldvar NO_WORK
      ceq
    then
      line 625
      ldloc_1
      ldfld FP.s
      call Scheduler_markWaiting
      ret
      line 626
    else
      line 627
      ldloc_2
      call Packet_getDatum
      stloc_s 4
      line 628
      if
        ldloc_s 4
        ldc_i4_4
        clt
        ldc_i4_0
        ceq
      then
        line 629
        ldloc_0
        ldloc_2
        call Packet_getLink
        call HandlerTaskDataRecord_setWorkIn
        line 630
        ldloc_1
        ldfld FP.s
        ldloc_2
        call Scheduler_queuePacket
        ret
        line 631
      else
        line 632
        ldloc_0
        call HandlerTaskDataRecord_deviceIn
        stloc_3
        line 633
        if
          ldloc_3
          ldvar NO_WORK
          ceq
        then
          line 634
          ldloc_1
          ldfld FP.s
          call Scheduler_markWaiting
          ret
          line 635
        else
          line 636
          ldloc_0
          ldloc_3
          call Packet_getLink
          call HandlerTaskDataRecord_setDeviceIn
          line 637
          ldloc_3
          ldloc_2
          call Packet_getData
          ldloc_s 4
          ldelema int32
          call Packet_setDatum
          line 638
          ldloc_2
          ldloc_s 4
          ldc_i4_1
          add
          call Packet_setDatum
          line 639
          ldloc_1
          ldfld FP.s
          ldloc_3
          call Scheduler_queuePacket
          ret
          line 640
        end
        line 641
      end
      line 642
    end
    line 643
  end createHandler_apply
  type line 645 _$185 = pointer to Scheduler
  type _$186 = pointer to Packet
  type _$187 = pointer to TaskState
  type line 647 _$188 = pointer to HandlerTaskDataRecord
  type line 648 _$189 = pointer to FP
  type line 652 _$190 = pointer to ProcessFunction
  procedure Scheduler_createHandler(me: _$185; identity: int32; priority: int32; workPacket: _$186; state: _$187)
  var data: _$188; fp: _$189; 
  begin
    line 650
    call HandlerTaskDataRecord_create
    stloc_0
    line 651
    ldarg_0
    ldproc createHandler_apply
    call FP_create
    stloc_1
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
    line 653
  end Scheduler_createHandler
  type line 655 _$191 = pointer to ProcessFunction
  type _$192 = pointer to Packet
  type _$193 = pointer to RBObject
  type line 38 _$194 = pointer to TaskControlBlock
  type line 657 _$195 = pointer to IdleTaskDataRecord
  type line 658 _$196 = pointer to FP
  type line 660 _$197 = pointer to IdleTaskDataRecord
  type line 661 _$198 = pointer to FP
  procedure line 655 createIdler_apply(me: _$191; workArg: _$192; wordArg: _$193):_$194
  var dataRecord: _$195; fp: _$196; 
  begin
    ldarg_2
    castptr IdleTaskDataRecord
    stloc_0
    ldarg_0
    castptr FP
    stloc_1
    line 662
    ldloc_0
    ldloc_0
    call IdleTaskDataRecord_getCount
    ldc_i4_1
    sub
    call IdleTaskDataRecord_setCount
    line 663
    if
      ldloc_0
      call IdleTaskDataRecord_getCount
      ldc_i4_0
      ceq
    then
      line 664
      ldloc_1
      ldfld FP.s
      call Scheduler_holdSelf
      ret
      line 665
    else
      line 666
      if
        ldloc_0
        call IdleTaskDataRecord_getControl
        conv_u4
        ldc_i4_1
        and
        ldc_i4_0
        ceq
      then
        line 667
        ldloc_0
        ldloc_0
        call IdleTaskDataRecord_getControl
        ldc_i4_2
        div
        call IdleTaskDataRecord_setControl
        line 668
        ldloc_1
        ldfld FP.s
        ldc_i4_4
        call Scheduler_release
        ret
        line 669
      else
        line 670
        ldloc_0
        ldloc_0
        call IdleTaskDataRecord_getControl
        conv_u4
        ldc_i4_2
        div_un
        ldc_i4 53256
        xor
        conv_i4
        call IdleTaskDataRecord_setControl
        line 671
        ldloc_1
        ldfld FP.s
        ldc_i4_5
        call Scheduler_release
        ret
        line 672
      end
      line 673
    end
    line 674
  end createIdler_apply
  type line 676 _$199 = pointer to Scheduler
  type _$200 = pointer to Packet
  type _$201 = pointer to TaskState
  type line 678 _$202 = pointer to IdleTaskDataRecord
  type line 679 _$203 = pointer to FP
  type line 683 _$204 = pointer to ProcessFunction
  procedure Scheduler_createIdler(me: _$199; identity: int32; priority: int32; work: _$200; state: _$201)
  var data: _$202; fp: _$203; 
  begin
    line 681
    call IdleTaskDataRecord_create
    stloc_0
    line 682
    ldarg_0
    ldproc createIdler_apply
    call FP_create
    stloc_1
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
    line 684
  end Scheduler_createIdler
  type line 686 _$205 = pointer to Scheduler
  type _$206 = pointer to Packet
  type line 22 _$207 = pointer to Packet
  procedure line 686 Scheduler_createPacket(me: _$205; link: _$206; identity: int32; kind: int32):_$207
  begin
    line 688
    ldarg_1
    ldarg_2
    ldarg_3
    call Packet_create
    ret
    line 689
  end Scheduler_createPacket
  type line 691 _$208 = pointer to ProcessFunction
  type _$209 = pointer to Packet
  type _$210 = pointer to RBObject
  type line 38 _$211 = pointer to TaskControlBlock
  type line 693 _$212 = pointer to WorkerTaskDataRecord
  type line 694 _$213 = pointer to FP
  type line 697 _$214 = pointer to WorkerTaskDataRecord
  type line 698 _$215 = pointer to FP
  procedure line 691 createWorker_apply(me: _$208; work: _$209; word: _$210):_$211
  var data: _$212; fp: _$213; line 695 i: int32; _$216: int32; 
  begin
    ldarg_2
    castptr WorkerTaskDataRecord
    stloc_0
    ldarg_0
    castptr FP
    stloc_1
    line 699
    if
      ldarg_1
      ldvar NO_WORK
      ceq
    then
      line 700
      ldloc_1
      ldfld FP.s
      call Scheduler_markWaiting
      ret
      line 701
    else
      line 702
      if
        ldloc_0
        call WorkerTaskDataRecord_getDestination
        ldc_i4_2
        ceq
      then
        line 703
        ldloc_0
        ldc_i4_3
        call WorkerTaskDataRecord_setDestination
        line 704
      else
        line 705
        ldloc_0
        ldc_i4_2
        call WorkerTaskDataRecord_setDestination
        line 706
      end
      line 707
      ldarg_1
      ldloc_0
      call WorkerTaskDataRecord_getDestination
      call Packet_setIdentity
      line 708
      ldarg_1
      ldc_i4_0
      call Packet_setDatum
      line 709
      ldc_i4_0
      stloc_2
      ldc_i4_3
      stloc_3
      while
        ldloc_2
        ldloc_3
        cgt
        ldc_i4_0
        ceq
      do
        line 710
        ldloc_0
        ldloc_0
        call WorkerTaskDataRecord_getCount
        ldc_i4_1
        add
        call WorkerTaskDataRecord_setCount
        line 711
        if
          ldloc_0
          call WorkerTaskDataRecord_getCount
          ldc_i4_s 26
          cgt
        then
          line 712
          ldloc_0
          ldc_i4_1
          call WorkerTaskDataRecord_setCount
          line 713
        end
        line 714
        ldarg_1
        call Packet_getData
        ldloc_2
        ldc_i4_s 65
        ldloc_0
        call WorkerTaskDataRecord_getCount
        add
        ldc_i4_1
        sub
        stelem_i4
        line 709
        ldloc_2
        ldc_i4_1
        add
        stloc_2
        line 715
      end
      line 716
      ldloc_1
      ldfld FP.s
      ldarg_1
      call Scheduler_queuePacket
      ret
      line 717
    end
    line 718
  end createWorker_apply
  type line 720 _$217 = pointer to Scheduler
  type _$218 = pointer to Packet
  type _$219 = pointer to TaskState
  type line 722 _$220 = pointer to WorkerTaskDataRecord
  type line 723 _$221 = pointer to FP
  type line 727 _$222 = pointer to ProcessFunction
  procedure Scheduler_createWorker(me: _$217; identity: int32; priority: int32; workPacket: _$218; state: _$219)
  var dataRecord: _$220; fp: _$221; 
  begin
    line 725
    call WorkerTaskDataRecord_create
    stloc_0
    line 726
    ldarg_0
    ldproc createWorker_apply
    call FP_create
    stloc_1
    ldarg_0
    ldarg_1
    ldarg_2
    ldarg_3
    ldarg_s 4
    ldloc_1
    ldflda FP.base
    ldloc_0
    call Scheduler_createTask
    line 728
  end Scheduler_createWorker
  type line 730 _$223 = pointer to Scheduler
  type line 732 _$224 = pointer to Packet
  procedure Scheduler_start(me: _$223):bool
  var workQ: _$224; 
  begin
    line 734
    ldnull
    stloc_0
    line 735
    ldarg_0
    ldc_i4_0
    ldc_i4_0
    ldvar NO_WORK
    call TaskState_createRunning
    call Scheduler_createIdler
    line 736
    ldarg_0
    ldvar NO_WORK
    ldc_i4_1
    ldc_i4_1
    call Scheduler_createPacket
    stloc_0
    line 737
    ldarg_0
    ldloc_0
    ldc_i4_1
    ldc_i4_1
    call Scheduler_createPacket
    stloc_0
    line 738
    ldarg_0
    ldc_i4_1
    ldc_i4 1000
    ldloc_0
    call TaskState_createWaitingWithPacket
    call Scheduler_createWorker
    line 739
    ldarg_0
    ldvar NO_WORK
    ldc_i4_4
    ldc_i4_0
    call Scheduler_createPacket
    stloc_0
    line 740
    ldarg_0
    ldloc_0
    ldc_i4_4
    ldc_i4_0
    call Scheduler_createPacket
    stloc_0
    line 741
    ldarg_0
    ldloc_0
    ldc_i4_4
    ldc_i4_0
    call Scheduler_createPacket
    stloc_0
    line 742
    ldarg_0
    ldc_i4_2
    ldc_i4 2000
    ldloc_0
    call TaskState_createWaitingWithPacket
    call Scheduler_createHandler
    line 743
    ldarg_0
    ldvar NO_WORK
    ldc_i4_5
    ldc_i4_0
    call Scheduler_createPacket
    stloc_0
    line 744
    ldarg_0
    ldloc_0
    ldc_i4_5
    ldc_i4_0
    call Scheduler_createPacket
    stloc_0
    line 745
    ldarg_0
    ldloc_0
    ldc_i4_5
    ldc_i4_0
    call Scheduler_createPacket
    stloc_0
    line 746
    ldarg_0
    ldc_i4_3
    ldc_i4 3000
    ldloc_0
    call TaskState_createWaitingWithPacket
    call Scheduler_createHandler
    line 747
    ldarg_0
    ldc_i4_4
    ldc_i4 4000
    ldvar NO_WORK
    call TaskState_createWaiting
    call Scheduler_createDevice
    line 748
    ldarg_0
    ldc_i4_5
    ldc_i4 5000
    ldvar NO_WORK
    call TaskState_createWaiting
    call Scheduler_createDevice
    line 749
    ldarg_0
    call Scheduler_schedule
    line 750
    iif
      ldarg_0
      ldfld Scheduler.queuePacketCount
      ldc_i4 23246
      ceq
    then
      ldarg_0
      ldfld Scheduler.holdCount
      ldc_i4 9297
      ceq
    else
      ldc_i4_0
    end
    ret
    line 751
  end Scheduler_start
  type line 753 _$225 = pointer to Scheduler
  type line 38 _$226 = pointer to TaskControlBlock
  type line 755 _$227 = pointer to TaskControlBlock
  procedure line 753 Scheduler_findTask(me: _$225; identity: int32):_$226
  var t: _$227; 
  begin
    line 757
    ldarg_0
    ldflda Scheduler.taskTable
    ldarg_1
    ldelem _$17
    stloc_0
    line 758
    if
      ldloc_0
      ldvar NO_TASK
      ceq
    then
      line 759
      ldc_i4_0
      ldc_i4 759
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Richards.mic"
      call MIC$!assert
      line 760
    end
    line 761
    ldloc_0
    ret
    line 762
  end Scheduler_findTask
  type line 764 _$228 = pointer to Scheduler
  type line 38 _$229 = pointer to TaskControlBlock
  type line 767 _$230 = pointer to TaskState
  procedure line 764 Scheduler_holdSelf(me: _$228):_$229
  begin
    line 766
    ldarg_0
    ldarg_0
    ldfld Scheduler.holdCount
    ldc_i4_1
    add
    stfld Scheduler.holdCount
    ldarg_0
    ldfld Scheduler.currentTask
    ldflda TaskControlBlock.base
    ldc_i4_1
    call TaskState_setTaskHolding
    line 768
    ldarg_0
    ldfld Scheduler.currentTask
    call TaskControlBlock_getLink
    ret
    line 769
  end Scheduler_holdSelf
  type line 771 _$231 = pointer to Scheduler
  type _$232 = pointer to Packet
  type line 38 _$233 = pointer to TaskControlBlock
  type line 773 _$234 = pointer to TaskControlBlock
  procedure line 771 Scheduler_queuePacket(me: _$231; packet: _$232):_$233
  var t: _$234; 
  begin
    line 775
    ldarg_0
    ldarg_1
    call Packet_getIdentity
    call Scheduler_findTask
    stloc_0
    line 776
    if
      ldloc_0
      ldvar NO_TASK
      ceq
    then
      line 777
      ldvar NO_TASK
      ret
      line 778
    end
    line 779
    ldarg_0
    ldarg_0
    ldfld Scheduler.queuePacketCount
    ldc_i4_1
    add
    stfld Scheduler.queuePacketCount
    line 780
    ldarg_1
    ldvar NO_WORK
    call Packet_setLink
    line 781
    ldarg_1
    ldarg_0
    ldfld Scheduler.currentTaskIdentity
    call Packet_setIdentity
    line 782
    ldloc_0
    ldarg_1
    ldarg_0
    ldfld Scheduler.currentTask
    call TaskControlBlock_addInputAndCheckPriority
    ret
    line 783
  end Scheduler_queuePacket
  type line 785 _$235 = pointer to Scheduler
  type line 38 _$236 = pointer to TaskControlBlock
  type line 787 _$237 = pointer to TaskControlBlock
  type line 793 _$238 = pointer to TaskState
  procedure line 785 Scheduler_release(me: _$235; identity: int32):_$236
  var t: _$237; 
  begin
    line 789
    ldarg_0
    ldarg_1
    call Scheduler_findTask
    stloc_0
    line 790
    if
      ldloc_0
      ldvar NO_TASK
      ceq
    then
      line 791
      ldvar NO_TASK
      ret
      line 792
    end
    ldloc_0
    ldflda TaskControlBlock.base
    ldc_i4_0
    call TaskState_setTaskHolding
    line 794
    if
      ldloc_0
      call TaskControlBlock_getPriority
      ldarg_0
      ldfld Scheduler.currentTask
      call TaskControlBlock_getPriority
      cgt
    then
      line 795
      ldloc_0
      ret
      line 796
    else
      line 797
      ldarg_0
      ldfld Scheduler.currentTask
      ret
      line 798
    end
    line 799
  end Scheduler_release
  type line 801 _$239 = pointer to Scheduler
  procedure Scheduler_trace(me: _$239; id: int32)
  begin
    line 803
    ldarg_0
    ldarg_0
    ldfld Scheduler.layout
    ldc_i4_1
    sub
    stfld Scheduler.layout
    line 804
    if
      ldarg_0
      ldfld Scheduler.layout
      ldc_i4_0
      cgt
      ldc_i4_0
      ceq
    then
      line 806
      ldarg_0
      ldc_i4_s 50
      stfld Scheduler.layout
      line 807
    end
    line 808
    ldarg_1
    conv_i8
    call MIC$!printI8
    line 809
  end Scheduler_trace
  type line 811 _$240 = pointer to Scheduler
  type line 38 _$241 = pointer to TaskControlBlock
  type line 813 _$242 = pointer to TaskState
  procedure line 811 Scheduler_markWaiting(me: _$240):_$241
  begin
    ldarg_0
    ldfld Scheduler.currentTask
    ldflda TaskControlBlock.base
    ldc_i4_1
    call TaskState_setTaskWaiting
    line 814
    ldarg_0
    ldfld Scheduler.currentTask
    ret
    line 815
  end Scheduler_markWaiting
  type line 817 _$243 = pointer to Scheduler
  type line 819 _$244 = pointer to TaskControlBlock
  type _$245 = pointer to TaskState
  procedure Scheduler_schedule(me: _$243)
  var tmp: _$244; 
  begin
    line 821
    ldarg_0
    ldarg_0
    ldfld Scheduler.taskList
    stfld Scheduler.currentTask
    line 822
    while
      ldarg_0
      ldfld Scheduler.currentTask
      ldvar NO_TASK
      ceq
      ldc_i4_0
      ceq
    do
      line 823
      if
        ldarg_0
        ldfld Scheduler.currentTask
        ldflda TaskControlBlock.base
        call TaskState_isTaskHoldingOrWaiting
      then
        line 824
        ldarg_0
        ldfld Scheduler.currentTask
        call TaskControlBlock_getLink
        stloc_0
        line 825
        ldarg_0
        ldloc_0
        stfld Scheduler.currentTask
        line 826
      else
        line 827
        ldarg_0
        ldarg_0
        ldfld Scheduler.currentTask
        call TaskControlBlock_getIdentity
        stfld Scheduler.currentTaskIdentity
        line 828
        if
          ldvar TRACING
        then
          line 829
          ldarg_0
          ldarg_0
          ldfld Scheduler.currentTaskIdentity
          call Scheduler_trace
          line 830
        end
        line 831
        ldarg_0
        ldfld Scheduler.currentTask
        call TaskControlBlock_runTask
        stloc_0
        line 832
        ldarg_0
        ldloc_0
        stfld Scheduler.currentTask
        line 833
      end
      line 834
    end
    line 835
  end Scheduler_schedule
  type line 837 _$246 = pointer to Benchmark!Benchmark
  type line 843 _$247 = pointer to Scheduler
  type line 844 _$248 = pointer to Scheduler
  procedure benchmark(me: _$246):int32
  var line 839 s: Scheduler; line 840 res: bool; 
  begin
    line 842
    ldc_i4_0
    stloc_1
    ldloca_s 0
    call Scheduler_init
    ldloca_s 0
    call Scheduler_start
    stloc_1
    line 845
    ldvar toDelete
    call RBObject_delete
    line 846
    ldnull
    stvar toDelete
    line 847
    if
      ldloc_1
    then
      ldc_i4_1
      ret
    else
      ldc_i4_0
      ret
    end
    line 848
  end benchmark
  type line 850 _$249 = pointer to Benchmark!Benchmark
  procedure verifyResult(me: _$249; result: int32):bool
  begin
    line 852
    ldarg_1
    ldc_i4_0
    ceq
    ldc_i4_0
    ceq
    ret
    line 853
  end verifyResult
  type line 27 _$250 = pointer to Benchmark!Benchmark
  type line 856 _$251 = pointer to Benchmark!Benchmark
  procedure line 855 create():_$250
  var bench: _$251; 
  begin
    line 858
    ldloca_s 0
    newobj Benchmark!Benchmark
    stind_ip
    line 859
    ldloc_0
    ldproc benchmark
    stfld Benchmark!Benchmark.benchmark
    line 860
    ldloc_0
    ldproc verifyResult
    stfld Benchmark!Benchmark.verifyResult
    line 861
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.dispose
    line 862
    ldloc_0
    ldnull
    stfld Benchmark!Benchmark.innerBenchmarkLoop
    line 863
    ldloc_0
    ret
    line 864
  end create
  procedure line 866 begin$() init 
  begin
    line 867
    ldc_i4_0
    stvar TRACING
    line 868
    ldnull
    stvar NO_WORK
    line 869
    ldnull
    stvar NO_TASK
    line 870
    ldnull
    stvar toDelete
    line 872
  end begin$
end line 866 Richards

// Generated by compiler  on 2025-06-02T23:11:10

module Run
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Run.mic"
  import line 26 Benchmark
  import Input
  import Out
  import line 27 Bounce
  import Mandelbrot
  import Permute
  import List
  import Queens
  import Sieve
  import Storage
  import Towers
  import line 28 NBody
  import Richards
  type line 32 _$1 = array of char
  type _$2 = pointer to _$1
  type line 33 _$3 = pointer to Benchmark!Benchmark
  type line 31 Run* = struct 
    line 32 name*: _$2
    line 33 benchmarkSuite*: _$3
    line 34 numIterations*: int32
    innerIterations*: int32
    total*: int32
  end
  type line 37 _$4 = array of char
  type _$5 = pointer to _$4
  type line 27 _$6 = pointer to Benchmark!Benchmark
  procedure line 37 getSuiteFromName(name: _$5):_$6
  begin
    line 39
    if
      ldarg_0
      ldstr "Bounce"
      ldc_i4_1
      call MIC$!relop1
    then
      line 40
      call Bounce!create
      ret
      line 41
    else
      if
        ldarg_0
        ldstr "Mandelbrot"
        ldc_i4_1
        call MIC$!relop1
      then
        line 42
        call Mandelbrot!create
        ret
        line 43
      else
        if
          ldarg_0
          ldstr "Permute"
          ldc_i4_1
          call MIC$!relop1
        then
          line 44
          call Permute!create
          ret
          line 45
        else
          if
            ldarg_0
            ldstr "List"
            ldc_i4_1
            call MIC$!relop1
          then
            line 46
            call List!create
            ret
            line 47
          else
            if
              ldarg_0
              ldstr "Queens"
              ldc_i4_1
              call MIC$!relop1
            then
              line 48
              call Queens!create
              ret
              line 49
            else
              if
                ldarg_0
                ldstr "Sieve"
                ldc_i4_1
                call MIC$!relop1
              then
                line 50
                call Sieve!create
                ret
                line 51
              else
                if
                  ldarg_0
                  ldstr "Storage"
                  ldc_i4_1
                  call MIC$!relop1
                then
                  line 52
                  call Storage!create
                  ret
                  line 53
                else
                  if
                    ldarg_0
                    ldstr "Towers"
                    ldc_i4_1
                    call MIC$!relop1
                  then
                    line 54
                    call Towers!create
                    ret
                    line 55
                  else
                    if
                      ldarg_0
                      ldstr "NBody"
                      ldc_i4_1
                      call MIC$!relop1
                    then
                      line 56
                      call NBody!create
                      ret
                      line 57
                    else
                      if
                        ldarg_0
                        ldstr "Richards"
                        ldc_i4_1
                        call MIC$!relop1
                      then
                        line 58
                        call Richards!create
                        ret
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      line 59
    end
    line 73
    ldnull
    ret
    line 74
  end getSuiteFromName
  type line 76 _$7 = pointer to Run
  type _$8 = array of char
  type _$9 = pointer to _$8
  procedure init(me: _$7; name: _$9)
  begin
    line 78
    ldarg_0
    ldc_i4_1
    stfld Run.numIterations
    line 79
    ldarg_0
    ldc_i4_1
    stfld Run.innerIterations
    line 80
    ldarg_0
    ldc_i4_0
    stfld Run.total
    line 81
    ldarg_0
    ldarg_1
    stfld Run.name
    line 82
    ldarg_0
    ldarg_1
    call getSuiteFromName
    stfld Run.benchmarkSuite
    line 83
  end init
  type line 85 _$10 = pointer to Run
  procedure deinit(me: _$10)
  begin
    line 87
    if
      ldarg_0
      ldfld Run.benchmarkSuite
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      line 88
      if
        ldarg_0
        ldfld Run.benchmarkSuite
        ldfld Benchmark!Benchmark.dispose
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        line 89
        ldarg_0
        ldfld Run.benchmarkSuite
        ldarg_0
        ldfld Run.benchmarkSuite
        ldfld Benchmark!Benchmark.dispose
        calli Benchmark!_$2
        line 90
      end
      line 91
      ldarg_0
      ldfld Run.benchmarkSuite
      free
      line 92
    end
    line 93
  end deinit
  type line 95 _$11 = pointer to Run
  procedure printResult(me: _$11; runTime: int32)
  begin
    line 97
    ret
    line 98
    ldarg_0
    ldfld Run.name
    call Out!String
    line 99
    ldstr ": iterations=1 runtime: "
    call Out!String
    line 100
    ldarg_1
    conv_i8
    ldc_i4_0
    call Out!Int
    line 101
    ldstr "us"
    call Out!String
    line 102
    call Out!Ln
    line 103
  end printResult
  type line 105 _$12 = pointer to Run
  procedure printTotal(me: _$12)
  begin
    line 107
    ret
    line 108
    ldstr "Total Runtime: "
    call Out!String
    line 109
    ldarg_0
    ldfld Run.total
    conv_i8
    ldc_i4_0
    call Out!Int
    line 110
    ldstr "us"
    call Out!String
    line 111
    call Out!Ln
    line 112
  end printTotal
  type line 114 _$13 = pointer to Run
  type _$14 = pointer to Benchmark!Benchmark
  type line 116 _$15 = pointer to Benchmark!Benchmark
  type _$16 = proc(me: _$15; innerIterations: int32):bool
  procedure measure(me: _$13; bench: _$14):bool
  var line 115 startTime: int32; endTime: int32; runTime: int32; innerBenchmarkLoop: _$16; 
  begin
    line 118
    call Input!Time
    stloc_0
    line 119
    ldarg_1
    ldfld Benchmark!Benchmark.innerBenchmarkLoop
    stloc_3
    line 120
    if
      ldloc_3
      ldnull
      ceq
    then
      line 121
      ldproc Benchmark!innerBenchmarkLoop
      stloc_3
      line 122
    end
    line 123
    if
      ldarg_1
      ldarg_0
      ldfld Run.innerIterations
      ldloc_3
      calli _$16
      ldc_i4_0
      ceq
    then
      line 124
      ldc_i4_0
      ret
      line 125
    end
    line 126
    call Input!Time
    stloc_1
    line 127
    ldloc_1
    ldloc_0
    sub
    stloc_2
    line 128
    ldarg_0
    ldloc_2
    call printResult
    line 129
    ldarg_0
    ldarg_0
    ldfld Run.total
    ldloc_2
    add
    stfld Run.total
    line 130
    ldc_i4_1
    ret
    line 131
  end measure
  type line 133 _$17 = pointer to Run
  type _$18 = pointer to Benchmark!Benchmark
  procedure doRuns(me: _$17; bench: _$18):bool
  var line 134 i: int32; _$19: int32; 
  begin
    line 136
    ldc_i4_0
    stloc_0
    ldarg_0
    ldfld Run.numIterations
    ldc_i4_1
    sub
    stloc_1
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      line 137
      if
        ldarg_0
        ldarg_1
        call measure
        ldc_i4_0
        ceq
      then
        line 138
        ldc_i4_0
        ret
        line 139
      end
      line 136
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 140
    end
    line 141
    ldc_i4_1
    ret
    line 142
  end doRuns
  type line 144 _$20 = pointer to Run
  procedure reportBenchmark(me: _$20)
  begin
    line 146
    ldarg_0
    ldfld Run.name
    call Out!String
    line 147
    ldstr ": iterations="
    call Out!String
    line 148
    ldarg_0
    ldfld Run.numIterations
    conv_i8
    ldc_i4_0
    call Out!Int
    line 149
    ldstr " average: "
    call Out!String
    line 150
    ldarg_0
    ldfld Run.total
    ldarg_0
    ldfld Run.numIterations
    div
    conv_i8
    ldc_i4_0
    call Out!Int
    line 151
    ldstr "us total: "
    call Out!String
    line 152
    ldarg_0
    ldfld Run.total
    conv_i8
    ldc_i4_0
    call Out!Int
    line 153
    ldstr "us"
    call Out!String
    line 154
    call Out!Ln
    line 155
  end reportBenchmark
  type line 157 _$21 = pointer to Run
  procedure runBenchmark(me: _$21)
  begin
    line 159
    ldstr "Starting "
    call Out!String
    line 160
    ldarg_0
    ldfld Run.name
    call Out!String
    line 161
    ldstr " benchmark ..."
    call Out!String
    line 162
    call Out!Ln
    line 164
    if
      ldarg_0
      ldfld Run.benchmarkSuite
      ldnull
      ceq
    then
      line 165
      ldstr "ERROR unknown benchmark "
      call Out!String
      line 166
      ldarg_0
      ldfld Run.name
      call Out!String
      call Out!Ln
      line 167
      ret
      line 168
    end
    line 169
    if
      ldarg_0
      ldarg_0
      ldfld Run.benchmarkSuite
      call doRuns
      ldc_i4_0
      ceq
    then
      line 170
      ldstr "ERROR"
      call Out!String
      call Out!Ln
      line 171
      ret
      line 172
    end
    line 173
    ldarg_0
    call reportBenchmark
    line 174
    call Out!Ln
    line 175
  end runBenchmark
  type line 177 _$22 = pointer to Run
  procedure setNumIterations(me: _$22; numIterations: int32)
  begin
    line 179
    ldarg_0
    ldarg_1
    stfld Run.numIterations
    line 180
  end setNumIterations
  type line 182 _$23 = pointer to Run
  procedure setInnerIterations(me: _$23; innerIterations: int32)
  begin
    line 184
    ldarg_0
    ldarg_1
    stfld Run.innerIterations
    line 185
  end setInnerIterations
end line 187 Run

// Generated by compiler  on 2025-06-02T23:11:10

module Interfaces$20
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Interfaces.mic"
  type line 24 T = int32
  type line 27 Data = pointer to any
  type line 28 _$1 = pointer to int32
  type ValueIterator* = proc(value: _$1; data: Data)
  type line 29 _$2 = pointer to int32
  type TestIterator* = proc(value: _$2; data: Data):bool
  type line 30 _$3 = pointer to int32
  type CompareIterator* = proc(lhs: _$3; rhs: _$3; data: Data):int32
end line 34 Interfaces$20

// Generated by compiler  on 2025-06-02T23:11:10

module Vector$19
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
  type line 24 T = int32
  import line 26 Interfaces$20
  type line 29 _$1 = pointer to int32
  type Equal* = proc(lhs: _$1; rhs: _$1):bool
  type line 32 _$2 = array of int32
  type _$3 = pointer to _$2
  type line 30 _$4 = struct 
    line 31 firstIdx: int32
    lastIdx: int32
    length: int32
    line 32 storage: _$3
  end
  type line 30 Vector* = pointer to _$4
  type _$5 = array of int32
  type _$6 = pointer to _$5
  procedure line 35 expand(me: Vector; newLength: int32)
  var line 36 i: int32; old: _$6; _$7: int32; 
  begin
    line 38
    if
      ldarg_1
      ldarg_0
      ldfld _$4.length
      cgt
      ldc_i4_0
      ceq
    then
      line 39
      ret
      line 40
    end
    line 42
    if
      ldarg_1
      ldc_i4_0
      cgt
    then
      line 43
      ldarg_0
      ldfld _$4.storage
      stloc_1
      line 44
      ldarg_0
      ldflda _$4.storage
      ldarg_1
      newarr int32
      stind_ip
      line 45
      if
        ldloc_1
        ldnull
        ceq
        ldc_i4_0
        ceq
      then
        line 46
        ldc_i4_0
        stloc_0
        ldarg_0
        ldfld _$4.length
        ldc_i4_1
        sub
        stloc_2
        while
          ldloc_0
          ldloc_2
          cgt
          ldc_i4_0
          ceq
        do
          line 47
          ldarg_0
          ldfld _$4.storage
          ldloc_0
          ldloc_1
          ldloc_0
          ldelem_i4
          stelem_i4
          line 46
          ldloc_0
          ldc_i4_1
          add
          stloc_0
          line 48
        end
        line 49
      end
      line 50
    end
    line 51
    ldarg_0
    ldarg_1
    stfld _$4.length
    line 52
  end expand
  procedure line 54 enlarge(me: Vector; idx: int32)
  var line 55 newLength: int32; 
  begin
    line 57
    ldarg_0
    ldfld _$4.length
    stloc_0
    line 58
    while
      ldloc_0
      ldarg_1
      cgt
      ldc_i4_0
      ceq
    do
      line 59
      ldloc_0
      ldc_i4_2
      mul
      stloc_0
      line 60
      ldloc_0
      ldc_i4_s 50
      add
      stloc_0
      line 61
    end
    line 62
    ldarg_0
    ldloc_0
    call expand
    line 63
  end enlarge
  type line 55 _$8 = pointer to int32
  type line 70 _$9 = pointer to int32
  procedure line 65 at(me: Vector; idx: int32):_$8
  begin
    line 67
    if
      iif
        ldarg_1
        ldc_i4_0
        clt
      then
        ldc_i4_1
      else
        ldarg_1
        ldarg_0
        ldfld _$4.length
        clt
        ldc_i4_0
        ceq
      end
    then
      line 68
      ldc_i4_0
      ldc_i4_s 68
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
      call MIC$!assert
      line 69
    end
    ldarg_0
    ldfld _$4.storage
    ldarg_1
    ldelema int32
    ret
    line 71
  end at
  type line 73 _$10 = pointer to int32
  procedure atPut(me: Vector; idx: int32; val: _$10)
  begin
    line 75
    if
      ldarg_1
      ldarg_0
      ldfld _$4.length
      clt
      ldc_i4_0
      ceq
    then
      line 76
      ldarg_0
      ldarg_1
      call enlarge
      line 77
    end
    line 78
    ldarg_0
    ldfld _$4.storage
    ldarg_1
    ldarg_2
    ldind_i4
    stelem_i4
    line 79
    if
      ldarg_0
      ldfld _$4.lastIdx
      ldarg_1
      ldc_i4_1
      add
      clt
    then
      line 80
      ldarg_0
      ldarg_1
      ldc_i4_1
      add
      stfld _$4.lastIdx
      line 81
    end
    line 82
  end atPut
  type line 88 _$12 = pointer to int32
  procedure line 84 forEach(me: Vector; iter: Interfaces$20!ValueIterator; data: Interfaces$20!Data)
  var line 85 i: int32; _$11: int32; 
  begin
    line 87
    ldarg_0
    ldfld _$4.firstIdx
    stloc_0
    ldarg_0
    ldfld _$4.lastIdx
    ldc_i4_1
    sub
    stloc_1
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      ldarg_0
      ldfld _$4.storage
      ldloc_0
      ldelema int32
      ldarg_2
      ldarg_1
      calli Interfaces$20!ValueIterator
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 89
    end
    line 90
  end forEach
  type _$14 = pointer to int32
  procedure line 92 hasSome(me: Vector; iter: Interfaces$20!TestIterator; data: Interfaces$20!Data):bool
  var line 93 i: int32; _$13: int32; 
  begin
    line 95
    ldarg_0
    ldfld _$4.firstIdx
    stloc_0
    ldarg_0
    ldfld _$4.lastIdx
    ldc_i4_1
    sub
    stloc_1
    while
      ldloc_0
      ldloc_1
      cgt
      ldc_i4_0
      ceq
    do
      line 96
      if
        ldarg_0
        ldfld _$4.storage
        ldloc_0
        ldelema int32
        ldarg_2
        ldarg_1
        calli Interfaces$20!TestIterator
      then
        line 97
        ldc_i4_1
        ret
        line 98
      end
      line 95
      ldloc_0
      ldc_i4_1
      add
      stloc_0
      line 99
    end
    line 100
    ldc_i4_0
    ret
    line 101
  end hasSome
  type line 105 _$15 = array of int32
  type _$16 = pointer to _$15
  type line 107 _$17 = pointer to int32
  type line 104 Remove_Iterator = struct 
    line 105 newArray: _$16
    line 106 newLast: int32
    line 107 obj: _$17
    line 108 found: bool
    line 109 eq: Equal
  end
  type line 112 _$18 = pointer to int32
  type line 113 _$19 = pointer to Remove_Iterator
  type line 115 _$20 = pointer to Remove_Iterator
  procedure remove_iter(value: _$18; data: Interfaces$20!Data)
  var me: _$19; 
  begin
    ldarg_1
    castptr Remove_Iterator
    stloc_0
    line 116
    if
      ldarg_0
      ldloc_0
      ldfld Remove_Iterator.obj
      ldloc_0
      ldfld Remove_Iterator.eq
      calli Equal
    then
      line 117
      ldloc_0
      ldc_i4_1
      stfld Remove_Iterator.found
      line 118
    else
      line 119
      ldloc_0
      ldfld Remove_Iterator.newArray
      ldloc_0
      ldfld Remove_Iterator.newLast
      ldarg_0
      ldind_i4
      stelem_i4
      line 120
      ldloc_0
      ldflda Remove_Iterator.newLast
      dup
      ldind_i4
      ldc_i4_1
      add
      stind_i4
      line 121
    end
    line 122
  end remove_iter
  type line 124 _$21 = pointer to int32
  type line 137 _$22 = pointer to Remove_Iterator
  procedure remove(me: Vector; obj: _$21; eq: Equal):bool
  var line 125 iter: Remove_Iterator; 
  begin
    line 127
    if
      ldarg_0
      ldfld _$4.length
      ldc_i4_0
      ceq
    then
      line 128
      ldc_i4_0
      ret
      line 129
    end
    line 131
    ldloca_s 0
    ldflda Remove_Iterator.newArray
    ldarg_0
    ldfld _$4.length
    newarr int32
    stind_ip
    line 132
    ldloca_s 0
    ldc_i4_0
    stfld Remove_Iterator.found
    line 133
    ldloca_s 0
    ldarg_1
    stfld Remove_Iterator.obj
    line 134
    ldloca_s 0
    ldc_i4_0
    stfld Remove_Iterator.newLast
    line 135
    ldloca_s 0
    ldarg_2
    stfld Remove_Iterator.eq
    ldarg_0
    ldproc remove_iter
    ldloca_s 0
    call forEach
    line 139
    ldarg_0
    ldfld _$4.storage
    free
    line 140
    ldarg_0
    ldloca_s 0
    ldfld Remove_Iterator.newArray
    stfld _$4.storage
    line 141
    ldarg_0
    ldloca_s 0
    ldfld Remove_Iterator.newLast
    stfld _$4.lastIdx
    line 142
    ldarg_0
    ldc_i4_0
    stfld _$4.firstIdx
    line 143
    ldloca_s 0
    ldfld Remove_Iterator.found
    ret
    line 144
  end remove
  type line 147 _$23 = pointer to int32
  procedure append(me: Vector; elem: _$23)
  begin
    line 149
    if
      ldarg_0
      ldfld _$4.lastIdx
      ldarg_0
      ldfld _$4.length
      clt
      ldc_i4_0
      ceq
    then
      line 150
      ldarg_0
      ldarg_0
      ldfld _$4.lastIdx
      call enlarge
      line 151
    end
    line 152
    ldarg_0
    ldfld _$4.storage
    ldarg_0
    ldfld _$4.lastIdx
    ldarg_1
    ldind_i4
    stelem_i4
    line 153
    ldarg_0
    ldflda _$4.lastIdx
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    line 154
  end append
  procedure line 156 isEmpty(me: Vector):bool
  begin
    line 158
    ldarg_0
    ldfld _$4.lastIdx
    ldarg_0
    ldfld _$4.firstIdx
    ceq
    ret
    line 159
  end isEmpty
  type _$24 = pointer to int32
  type line 167 _$25 = pointer to int32
  procedure line 161 removeFirst(me: Vector):_$24
  begin
    line 163
    if
      ldarg_0
      call isEmpty
    then
      line 164
      ldc_i4_0
      ldc_i4 164
      ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
      call MIC$!assert
      line 165
    end
    line 166
    ldarg_0
    ldflda _$4.firstIdx
    dup
    ldind_i4
    ldc_i4_1
    add
    stind_i4
    ldarg_0
    ldfld _$4.storage
    ldarg_0
    ldfld _$4.firstIdx
    ldc_i4_1
    sub
    ldelema int32
    ret
    line 168
  end removeFirst
  procedure line 170 removeAll(me: Vector)
  begin
    line 172
    ldarg_0
    ldc_i4_0
    stfld _$4.firstIdx
    line 173
    ldarg_0
    ldc_i4_0
    stfld _$4.lastIdx
    line 174
  end removeAll
  procedure line 176 size(me: Vector):int32
  begin
    line 178
    ldarg_0
    ldfld _$4.lastIdx
    ldarg_0
    ldfld _$4.firstIdx
    sub
    ret
    line 179
  end size
  procedure line 181 capacity(me: Vector):int32
  begin
    line 183
    ldarg_0
    ldfld _$4.length
    ret
    line 184
  end capacity
  procedure line 186 create(len: int32):Vector
  var line 187 v: Vector; 
  begin
    line 189
    ldloca_s 0
    newobj _$4
    stind_ip
    line 190
    ldloc_0
    ldc_i4_0
    stfld _$4.firstIdx
    line 191
    ldloc_0
    ldc_i4_0
    stfld _$4.lastIdx
    line 192
    ldloc_0
    ldc_i4_0
    stfld _$4.length
    line 193
    ldloc_0
    ldnull
    stfld _$4.storage
    line 194
    ldloc_0
    ldarg_0
    call expand
    line 195
    ldloc_0
    ret
    line 196
  end create
  procedure line 198 createDefault():Vector
  begin
    line 200
    ldc_i4_0
    call create
    ret
    line 201
  end createDefault
  procedure line 203 copy(in_: Vector):Vector
  var line 204 me: Vector; i: int32; _$26: int32; 
  begin
    line 206
    ldarg_0
    ldfld _$4.length
    call create
    stloc_0
    line 207
    ldloc_0
    ldarg_0
    ldfld _$4.firstIdx
    stfld _$4.firstIdx
    line 208
    ldloc_0
    ldarg_0
    ldfld _$4.lastIdx
    stfld _$4.lastIdx
    line 209
    ldc_i4_0
    stloc_1
    ldarg_0
    ldfld _$4.length
    ldc_i4_1
    sub
    stloc_2
    while
      ldloc_1
      ldloc_2
      cgt
      ldc_i4_0
      ceq
    do
      line 210
      ldloc_0
      ldfld _$4.storage
      ldloc_1
      ldarg_0
      ldfld _$4.storage
      ldloc_1
      ldelem_i4
      stelem_i4
      line 209
      ldloc_1
      ldc_i4_1
      add
      stloc_1
      line 211
    end
    line 212
    ldloc_0
    ret
    line 213
  end copy
  procedure line 215 free(me: Vector)
  begin
    line 217
    if
      ldarg_0
      ldnull
      ceq
    then
      line 218
      ret
      line 219
    end
    line 220
    if
      ldarg_0
      ldfld _$4.storage
      ldnull
      ceq
      ldc_i4_0
      ceq
    then
      line 221
      ldarg_0
      ldfld _$4.storage
      free
      line 222
    end
    line 223
    ldarg_0
    free
    line 224
  end free
  type line 226 _$27 = array of int32
  type _$28 = pointer to _$27
  procedure swap(storage: _$28; i: int32; j: int32) inline 
  begin
    line 228
    ldc_i4_0
    ldc_i4 228
    ldstr "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/som/Vector.mic"
    call MIC$!assert
    line 229
  end swap
  type line 233 _$29 = pointer to int32
  type line 241 _$30 = pointer to int32
  type line 242 _$31 = pointer to int32
  type line 253 _$32 = pointer to int32
  type _$33 = pointer to int32
  type _$34 = pointer to int32
  procedure line 231 sort_imp(me: Vector; i: int32; j: int32; c: Interfaces$20!CompareIterator; data: Interfaces$20!Data)
  var line 232 n: int32; ij: int32; k: int32; l: int32; di: _$29; dj: _$29; tt: _$29; dij: _$29; 
  begin
    line 236
    ldarg_2
    ldc_i4_1
    add
    ldarg_1
    sub
    stloc_0
    line 237
    if
      ldloc_0
      ldc_i4_1
      cgt
      ldc_i4_0
      ceq
    then
      line 238
      ret
      line 239
    end
    ldarg_0
    ldfld _$4.storage
    ldarg_1
    ldelema int32
    stloc_s 4
    ldarg_0
    ldfld _$4.storage
    ldarg_2
    ldelema int32
    stloc_s 5
    line 244
    if
      ldloc_s 4
      ldloc_s 5
      ldarg_s 4
      ldarg_3
      calli Interfaces$20!CompareIterator
      ldc_i4_0
      cgt
    then
      line 245
      ldarg_0
      ldfld _$4.storage
      ldarg_1
      ldarg_2
      call swap
      line 246
      ldloc_s 4
      stloc_s 6
      line 247
      ldloc_s 5
      stloc_s 4
      line 248
      ldloc_s 6
      stloc_s 5
      line 249
    end
    line 251
    if
      ldloc_0
      ldc_i4_2
      cgt
    then
      line 252
      ldarg_1
      ldarg_2
      add
      ldc_i4_2
      div
      stloc_1
      ldarg_0
      ldfld _$4.storage
      ldloc_1
      ldelema int32
      stloc_s 7
      line 255
      if
        ldloc_s 4
        ldloc_s 7
        ldarg_s 4
        ldarg_3
        calli Interfaces$20!CompareIterator
        ldc_i4_0
        cgt
        ldc_i4_0
        ceq
      then
        line 256
        if
          ldloc_s 7
          ldloc_s 5
          ldarg_s 4
          ldarg_3
          calli Interfaces$20!CompareIterator
          ldc_i4_0
          cgt
        then
          line 257
          ldarg_0
          ldfld _$4.storage
          ldarg_2
          ldloc_1
          call swap
          line 258
          ldloc_s 5
          stloc_s 7
          line 259
        end
        line 260
      else
        line 261
        ldarg_0
        ldfld _$4.storage
        ldarg_1
        ldloc_1
        call swap
        line 262
        ldloc_s 4
        stloc_s 7
        line 263
      end
      line 265
      if
        ldloc_0
        ldc_i4_3
        cgt
      then
        line 266
        ldarg_1
        stloc_2
        line 267
        ldarg_2
        ldc_i4_1
        sub
        stloc_3
        line 269
        loop
          line 270
          while
            iif
              ldloc_2
              ldloc_3
              cgt
              ldc_i4_0
              ceq
            then
              ldloc_s 7
              ldarg_0
              ldfld _$4.storage
              ldloc_3
              ldelema int32
              ldarg_s 4
              ldarg_3
              calli Interfaces$20!CompareIterator
              ldc_i4_0
              cgt
              ldc_i4_0
              ceq
            else
              ldc_i4_0
            end
          do
            line 271
            ldloca_s 3
            dup
            ldind_i4
            ldc_i4_1
            sub
            stind_i4
            line 272
          end
          line 274
          ldloca_s 2
          dup
          ldind_i4
          ldc_i4_1
          add
          stind_i4
          line 275
          while
            iif
              ldloc_2
              ldloc_3
              cgt
              ldc_i4_0
              ceq
            then
              ldarg_0
              ldfld _$4.storage
              ldloc_2
              ldelema int32
              ldloc_s 7
              ldarg_s 4
              ldarg_3
              calli Interfaces$20!CompareIterator
              ldc_i4_0
              cgt
              ldc_i4_0
              ceq
            else
              ldc_i4_0
            end
          do
            line 276
            ldloca_s 2
            dup
            ldind_i4
            ldc_i4_1
            add
            stind_i4
            line 277
          end
          line 279
          if
            ldloc_2
            ldloc_3
            cgt
          then
            line 280
            exit
            line 281
          end
          line 282
          ldarg_0
          ldfld _$4.storage
          ldloc_2
          ldloc_3
          call swap
          line 283
        end
        line 285
        ldarg_0
        ldarg_1
        ldloc_3
        ldarg_3
        ldarg_s 4
        call sort_imp
        line 286
        ldarg_0
        ldloc_2
        ldarg_2
        ldarg_3
        ldarg_s 4
        call sort_imp
        line 287
      end
      line 288
    end
    line 289
  end sort_imp
  procedure line 291 sort(me: Vector; c: Interfaces$20!CompareIterator; data: Interfaces$20!Data)
  begin
    line 293
    if
      ldarg_0
      call size
      ldc_i4_0
      cgt
    then
      line 294
      ldarg_0
      ldarg_0
      ldfld _$4.firstIdx
      ldarg_0
      ldfld _$4.lastIdx
      ldc_i4_1
      sub
      ldarg_1
      ldarg_2
      call sort_imp
      line 295
    end
    line 296
  end sort
end line 298 Vector$19

// Generated by compiler  on 2025-06-02T23:11:10

module Main
  source "/home/me/Entwicklung/Modules/Are-we-fast-yet/Micron/Main.mic"
  import line 24 Run
  import line 25 Vector$19
  type line 27 _$1 = array of char
  type _$2 = pointer to _$1
  type line 30 _$3 = pointer to Run!Run
  type line 31 _$4 = pointer to Run!Run
  type line 32 _$5 = pointer to Run!Run
  type line 35 _$6 = pointer to Run!Run
  type line 36 _$7 = pointer to Run!Run
  type line 39 _$8 = pointer to Run!Run
  procedure run(what: _$2; numIterations: int32; innerIterations: int32)
  var line 28 r: Run!Run; 
  begin
    ldloca_s 0
    ldarg_0
    call Run!init
    ldloca_s 0
    ldarg_1
    call Run!setNumIterations
    ldloca_s 0
    ldarg_2
    call Run!setInnerIterations
    ldloca_s 0
    call Run!runBenchmark
    ldloca_s 0
    call Run!printTotal
    ldloca_s 0
    call Run!deinit
    line 40
  end run
  procedure line 42 runAll()
  begin
    line 44
    ldstr "DeltaBlue"
    ldc_i4 12000
    ldc_i4_1
    call run
    line 45
    ldstr "Richards"
    ldc_i4_s 100
    ldc_i4_1
    call run
    line 46
    ldstr "Json"
    ldc_i4_s 100
    ldc_i4_1
    call run
    line 47
    ldstr "Havlak"
    ldc_i4_s 10
    ldc_i4_1
    call run
    line 48
    ldstr "CD"
    ldc_i4 250
    ldc_i4_2
    call run
    line 49
    ldstr "Bounce"
    ldc_i4 1500
    ldc_i4_1
    call run
    line 50
    ldstr "List"
    ldc_i4 1500
    ldc_i4_1
    call run
    line 51
    ldstr "Mandelbrot"
    ldc_i4 500
    ldc_i4_1
    call run
    line 52
    ldstr "NBody"
    ldc_i4 250000
    ldc_i4_1
    call run
    line 53
    ldstr "Permute"
    ldc_i4 1000
    ldc_i4_1
    call run
    line 54
    ldstr "Queens"
    ldc_i4 1000
    ldc_i4_1
    call run
    line 55
    ldstr "Sieve"
    ldc_i4 3000
    ldc_i4_1
    call run
    line 56
    ldstr "Storage"
    ldc_i4 1000
    ldc_i4_1
    call run
    line 57
    ldstr "Towers"
    ldc_i4 600
    ldc_i4_1
    call run
    line 58
  end runAll
  procedure line 60 runOnce()
  begin
    line 62
    ldstr "DeltaBlue"
    ldc_i4_1
    ldc_i4_1
    call run
    line 63
    ldstr "Richards"
    ldc_i4_1
    ldc_i4_1
    call run
    line 64
    ldstr "Json"
    ldc_i4_1
    ldc_i4_1
    call run
    line 65
    ldstr "Havlak"
    ldc_i4_1
    ldc_i4_1
    call run
    line 66
    ldstr "CD"
    ldc_i4_1
    ldc_i4_2
    call run
    line 67
    ldstr "Bounce"
    ldc_i4_1
    ldc_i4_1
    call run
    line 68
    ldstr "List"
    ldc_i4_1
    ldc_i4_1
    call run
    line 69
    ldstr "Mandelbrot"
    ldc_i4_1
    ldc_i4_1
    call run
    line 70
    ldstr "NBody"
    ldc_i4_1
    ldc_i4_1
    call run
    line 71
    ldstr "Permute"
    ldc_i4_1
    ldc_i4_1
    call run
    line 72
    ldstr "Queens"
    ldc_i4_1
    ldc_i4_1
    call run
    line 73
    ldstr "Sieve"
    ldc_i4_1
    ldc_i4_1
    call run
    line 74
    ldstr "Storage"
    ldc_i4_1
    ldc_i4_1
    call run
    line 75
    ldstr "Towers"
    ldc_i4_1
    ldc_i4_1
    call run
    line 76
  end runOnce
  procedure line 78 begin$() init 
  begin
    line 80
    call runOnce
    line 82
  end begin$
end line 78 Main
