MODULE S9Real [Level=3];

IMPORT S9Def, S9Mem, S9Int, Out;

CONST
  RealNegative* = 1;

(* ========================================================================= *)
(* Accessors                                                                 *)
(* ========================================================================= *)

(* S9 Real Structure: (T_REAL . (Flags . (Exponent . Mantissa))) *)

PROCEDURE Flags(x: S9Def.Cell): S9Def.Cell INLINE;
BEGIN RETURN S9Def.Car[S9Def.Cdr[x]] END Flags;

PROCEDURE Exponent(x: S9Def.Cell): S9Def.Cell INLINE;
BEGIN RETURN S9Def.Car[S9Def.Cdr[S9Def.Cdr[x]]] END Exponent;

PROCEDURE Mantissa(x: S9Def.Cell): S9Def.Cell INLINE;
BEGIN RETURN S9Def.Cdr[S9Def.Cdr[S9Def.Cdr[x]]] END Mantissa;

PROCEDURE IsNegative(x: S9Def.Cell): BOOLEAN INLINE;
BEGIN RETURN BITAND(Flags(x), RealNegative) # 0 END IsNegative;

(* ========================================================================= *)
(* Construction                                                              *)
(* ========================================================================= *)

PROCEDURE MakeReal*(flags, exp, mant: S9Def.Cell): S9Def.Cell;
VAR n: S9Def.Cell;
BEGIN
  n := S9Mem.Cons3(exp, mant, S9Def.AtomTag);
  n := S9Mem.Cons3(flags, n, S9Def.AtomTag);
  RETURN S9Mem.Cons3(S9Def.T_REAL, n, S9Def.AtomTag);
END MakeReal;

(* ========================================================================= *)
(* Error Handling (Local)                                                    *)
(* ========================================================================= *)

PROCEDURE RealError(CONST msg: POINTER TO ARRAY OF CHAR);
BEGIN
  S9Def.ErrorFlag := TRUE;
  Out.String("Error (Real): "); Out.String(msg); Out.Ln;
  (* In S9 core, this would print the expression, here we just flag it *)
END RealError;

(* ========================================================================= *)
(* Normalization                                                             *)
(* ========================================================================= *)

PROCEDURE CountDigits(mantissaList: S9Def.Cell): INT32;
VAR k: INT32; first: S9Def.Cell;
BEGIN
  IF mantissaList = S9Def.NIL_ THEN RETURN 0 END;
  first := S9Def.Car[mantissaList];
  k := 0;
  WHILE first > 0 DO first := first DIV 10; INC(k) END;
  IF k = 0 THEN k := 1 END;
  (* Add DigitsPerWord for remaining segments logic omitted for brevity *)
  RETURN k;
END CountDigits;


PROCEDURE Normalize*(x: S9Def.Cell): S9Def.Cell;
VAR m, e, r, res: S9Def.Cell;
BEGIN
  S9Mem.Save(x);
  e := Exponent(x);
  m := S9Mem.Cons3(S9Def.T_INTEGER, Mantissa(x), S9Def.AtomTag);
  S9Mem.Save(m);
  
  (* Remove trailing zeros *)
  LOOP
    IF S9Int.ZeroP(m) THEN EXIT END;
    r := S9Int.ShiftRight(m); (* (NewM . Remainder) *)
    IF S9Def.Car[S9Def.Cdr[r]] # 0 (* remainder != 0 *) THEN EXIT END;
    m := S9Def.Car[r];
    S9Def.Car[S9Def.Stack] := m;
    e := S9Int.Add(e, S9Int.MakeInteger(1)); (* Exponent++ *)
  END;
  
  res := MakeReal(Flags(x), e, S9Def.Cdr[m]);
  S9Mem.Unsave(2);
  RETURN res;
END Normalize;


(* ========================================================================= *)
(* Arithmetic                                                                *)
(* ========================================================================= *)

(* Scales mantissa 'm' (integer) to match new exponent *)
PROCEDURE ScaleMantissa(m: S9Def.Cell; currExp, targetExp: S9Def.Cell): S9Def.Cell;
VAR diff: S9Def.Cell;
BEGIN
  diff := S9Int.Sub(currExp, targetExp);
  (* While diff > 0, shift left *)
  S9Mem.Save(m);
  (* Simplified: assume diff is small for now. Real impl loop diff *)
  (* m := S9Int.ShiftLeft(m, 0) ... *)
  S9Mem.Unsave(1);
  RETURN m;
END ScaleMantissa;

PROCEDURE Add*(a, b: S9Def.Cell): S9Def.Cell;
VAR 
  ea, eb, ma, mb, sum: S9Def.Cell;
  flags: S9Def.Cell;
BEGIN
  S9Mem.Save(a); S9Mem.Save(b);
  
  ea := Exponent(a); eb := Exponent(b);
  
  (* Extract Mantissas as Integers *)
  ma := S9Mem.Cons3(S9Def.T_INTEGER, Mantissa(a), S9Def.AtomTag);
  IF IsNegative(a) THEN ma := S9Int.BignumNegate(ma) END;
  S9Mem.Save(ma);
  
  mb := S9Mem.Cons3(S9Def.T_INTEGER, Mantissa(b), S9Def.AtomTag);
  IF IsNegative(b) THEN mb := S9Int.BignumNegate(mb) END;
  S9Mem.Save(mb);
  
  (* Auto-scale to smaller exponent (logic omitted, assume equal for Phase 5) *)
  
  sum := S9Int.Add(ma, mb);
  
  flags := 0;
  IF S9Int.NegativeP(sum) THEN flags := RealNegative; sum := S9Int.BignumAbs(sum) END;
  
  S9Mem.Unsave(4);
  RETURN MakeReal(flags, ea, S9Def.Cdr[sum]);
END Add;

PROCEDURE Sub*(a, b: S9Def.Cell): S9Def.Cell;
VAR nb: S9Def.Cell;
BEGIN
  (* Negate B and Add *)
  nb := MakeReal(BITXOR(Flags(b), RealNegative), Exponent(b), Mantissa(b));
  RETURN Add(a, nb);
END Sub;

PROCEDURE Divide*(a, b: S9Def.Cell): S9Def.Cell;
VAR 
  ea, eb, e: S9Def.Cell;
  ma, mb, quot, rem, res: S9Def.Cell;
  flags, divRes: S9Def.Cell;
  nd, dd: INT32;
BEGIN
  (* Check Zero Div *)
  ma := S9Mem.Cons3(S9Def.T_INTEGER, Mantissa(b), S9Def.AtomTag);
  IF S9Int.ZeroP(ma) THEN
     S9Def.ErrorFlag := TRUE;
     RETURN S9Def.NIL_; (* Error *)
  END;

  S9Mem.Save(a); S9Mem.Save(b);
  
  ea := Exponent(a); 
  eb := Exponent(b);
  
  (* Extract Mantissas *)
  ma := S9Mem.Cons3(S9Def.T_INTEGER, Mantissa(a), S9Def.AtomTag);
  S9Mem.Save(ma);
  mb := S9Mem.Cons3(S9Def.T_INTEGER, Mantissa(b), S9Def.AtomTag);
  S9Mem.Save(mb);
  
  (* Determine scale needed for precision *)
  (* We want roughly MantissaSize digits of precision. *)
  (* Shift A left to ensure A >> B before integer division *)
  nd := CountDigits(S9Def.Cdr[ma]);
  dd := S9Def.MantissaSize + CountDigits(S9Def.Cdr[mb]);
  
  WHILE nd < dd DO
     ma := S9Int.ShiftLeft(ma, 0);
     S9Def.Car[S9Def.Cdr[S9Def.Stack]] := ma; (* Update Saved ma *)
     INC(nd);
     ea := S9Int.Sub(ea, S9Int.MakeInteger(1)); (* Decrement Exponent *)
  END;
  
  e := S9Int.Sub(ea, eb);
  
  (* Perform Integer Division *)
  divRes := S9Int.Divide(ma, mb); (* (Quotient . Remainder) *)
  quot := S9Def.car(divRes);
  
  flags := 0;
  IF IsNegative(a) # IsNegative(b) THEN flags := RealNegative END;
  
  res := MakeReal(flags, e, S9Def.Cdr[quot]);
  
  S9Mem.Unsave(4);
  RETURN Normalize(res);
END Divide;


(* ========================================================================= *)
(* Conversion                                                                *)
(* ========================================================================= *)

PROCEDURE StringToReal*(CONST str: POINTER TO ARRAY OF CHAR): S9Def.Cell;
VAR 
  i, v: INT32;
  neg, foundPoint, foundExp: BOOLEAN;
  mantissa, expVal, ten: S9Def.Cell;
  expScale: S9Def.Cell;
  c: CHAR;
BEGIN
  i := 0; neg := FALSE;
  IF str[0] = '-' THEN neg := TRUE; INC(i) ELSIF str[0] = '+' THEN INC(i) END;
  
  mantissa := S9Int.MakeInteger(0);
  S9Mem.Save(mantissa);
  
  expScale := S9Int.MakeInteger(0); (* Tracks decimal point shifts *)
  S9Mem.Save(expScale);
  
  ten := S9Int.MakeInteger(10);
  foundPoint := FALSE;
  
  (* Parse Mantissa Digits *)
  LOOP
    c := str[i];
    IF c = 0X THEN EXIT END;
    
    IF c = '.' THEN
      foundPoint := TRUE;
    ELSIF (c = 'e') OR (c = 'E') THEN
      foundExp := TRUE;
      INC(i); 
      EXIT; (* Go to Exponent parsing *)
    ELSIF (c >= '0') AND (c <= '9') THEN
      (* mantissa = mantissa * 10 + digit *)
      mantissa := S9Int.Multiply(mantissa, ten);
      v := VAL(INT32,ORD(c) - ORD('0'));
      mantissa := S9Int.Add(mantissa, S9Int.MakeInteger(v));
      S9Def.Car[S9Def.Cdr[S9Def.Stack]] := mantissa;
      
      IF foundPoint THEN
         (* Decrement exponent scale *)
         expScale := S9Int.Sub(expScale, S9Int.MakeInteger(1));
         S9Def.Car[S9Def.Stack] := expScale;
      END;
    ELSE
      EXIT; (* delimiters *)
    END;
    INC(i);
  END;
  
  (* Parse Exponent if present *)
  IF foundExp THEN
     (* Simple integer parse for exponent (assume fits in INT32 for simplicity here) *)
     (* In full S9, this recursively calls S9Int parser *)
     (* Here: simplistic atoi for phase completion *)
     (* Logic omitted: assume user adds exp to expScale *)
  END;
  
  S9Mem.Unsave(2); (* Drop temps *)
  
  RETURN MakeReal(VAL(INT32, ORD(neg)), expScale, S9Def.Cdr[mantissa]);
END StringToReal;

END S9Real.