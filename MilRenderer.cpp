/*
* Copyright 2019-2025 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the Micron language project.
*
* The following is the license that applies to this copy of the
* file. For a license to use the file under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "MilRenderer.h"
#include "MilEmitter.h"
#include "MilOps.h"
#include "MilAst.h"
#include "MilValidator.h"
#include <QCoreApplication>
#include <QDateTime>
#include <QtDebug>
using namespace Mil;

IlAsmRenderer::IlAsmRenderer(QIODevice* dev, bool renderLineInfo):
    level(0),renderLineInfo(renderLineInfo),state(Idle),curLine(0), lastLine(0)
{
    // default is UTF-8, so no need to setCodec
    out.setDevice(dev);
}

void IlAsmRenderer::beginModule(const QByteArray& moduleName, const QString& sourceFile, const QByteArrayList& mp)
{
    source = sourceFile;
    d_moduleName = moduleName;
    out << "// Generated by " << qApp->applicationName() << " " << qApp->applicationVersion() << " on "
        << QDateTime::currentDateTime().toString(Qt::ISODate) << endl << endl;

    out << "module ";
    lineout();
    out << moduleName;
    if( !mp.isEmpty() )
    {
        out << " (";
        for( int i = 0; i < mp.size(); i++ )
        {
            if( i != 0 )
                out << "; ";
            //if( !mp[i].type.isEmpty() )
            //    out << "const ";
            out << mp[i];
            //if( !mp[i].type.isEmpty() )
            //    out << ": " << mp[i].type;
        }
        out << ")";
    }
    out << endl;

    state = Module;
    level++;

    if( renderLineInfo && !sourceFile.isEmpty() )
        out << ws() << "source \"" << sourceFile << "\"" << endl;
}

void IlAsmRenderer::endModule()
{
    level--;
    out << ws() << "end ";
    lineout();
    out << d_moduleName << endl;
    state = Idle;
}

void IlAsmRenderer::addImport(const QByteArray& path)
{
    out << ws() << "import ";
    lineout();
    out << path;
    out << endl;
}

void IlAsmRenderer::addVariable(const Quali& typeRef, QByteArray name, bool isPublic)
{
    out << ws() << "var ";
    lineout();
    out << name << ": " << toString(typeRef) << endl;
}

void IlAsmRenderer::addProcedure(const ProcData& m)
{
    if( m.kind == ProcData::Invalid )
        return;
    render(m);
}

void IlAsmRenderer::beginType(const QByteArray& className, bool isPublic, quint8 classKind, const Quali& super)
{
    Q_ASSERT(classKind == EmiTypes::Union || classKind == EmiTypes::Struct || classKind == EmiTypes::Object);
    state = Struct;
    out << ws() << "type ";
    lineout();
    out << className;
    if( isPublic )
        out << "*";

    out << " = ";
    if( classKind == EmiTypes::Union )
        out << "union ";
    else if( classKind == EmiTypes::Object )
    {
        out << "object ";
        if( !super.first.isEmpty() || !super.second.isEmpty() )
        {
            out << "(";
            if( !super.first.isEmpty() )
                out << super.first << ".";
            out << super.second;
            out << ")";
        }
    }
    else
        out << "struct ";

    out << endl;
    level++;
}

void IlAsmRenderer::endType()
{
    level--;
    out << ws();
    out << "end";
    out << endl;
    state = Module;
}

void IlAsmRenderer::addType(const QByteArray& name, bool isPublic, const Quali& baseType, quint8 typeKind, quint32 len)
{
    out << ws() << "type ";
    lineout();
    out << name;
    if( isPublic )
        out << "*";

    out << " = ";
    switch(typeKind)
    {
    case EmiTypes::Alias:
        out << toString(baseType) << endl;
        break;
    case EmiTypes::Pointer:
        out << "pointer to " << toString(baseType) << endl;
        break;
    case EmiTypes::Array:
        out << "array ";
        if( len )
            out << len << " ";
        out << "of " << toString(baseType) << endl;
        break;
    }
}

void IlAsmRenderer::addField(const QByteArray& fieldName, const Quali& typeRef, bool isPublic, quint8 bits)
{
    out << ws();
    if( fieldName.isEmpty() && state == Struct )
    {
        out << ".. " << bits;
    }else
    {
        if( state == Module )
            out << "var ";
        lineout();
        out << fieldName;
        if( isPublic )
            out << "*";

        out << ": " << toString(typeRef);
        if( bits && state == Struct )
            out << " : " << bits;
    }
    out << endl;
}

void IlAsmRenderer::line(quint32 l)
{
    curLine = l;
}

QString IlAsmRenderer::formatDouble(const QVariant& v)
{
    QString tmp = v.toString();
    const int eidx = tmp.indexOf('e', 0, Qt::CaseInsensitive);
    if( eidx != -1 )
    {
        if( eidx == 0 ) // e-5
            tmp.prepend("0.0");
        else if( !tmp.left(eidx).contains('.')  // 3e-5
                 || tmp[eidx-1] == '.' )        // 3.e-5
            tmp = tmp.left(eidx) + QString(".0") + tmp.mid(eidx);
        if( tmp[0] == '.' ) // .0e-5, .e-5
            tmp.prepend("0");
    }
    return tmp;
}

static inline bool isAllPrintable(const QString& str)
{
    for( int i = 0; i < str.size(); i++ )
    {
        if( !str[i].isPrint() )
            return false;
    }
    return true;
}

static void renderComponents( QTextStream& out, const QVariant& data )
{
    if( data.canConvert<RecordLiteral>() )
    {
        out << "{";
        RecordLiteral m = data.value<RecordLiteral>();
        for( int i = 0; i < m.size(); i++ )
        {
            out << m[i].first << "=";
            renderComponents(out,m[i].second);
        }
        out << "}";
        return;
    }
    switch( data.type() )
    {
    case QVariant::List:
        out << "{";
        foreach( const QVariant& v, data.toList() )
        {
            renderComponents(out,v);
            out << " ";
        }
        out << "}";
        break;
    case QVariant::ByteArray:
        out << "#" << data.toByteArray().toHex() << "#";
        break;
    case QVariant::String:
        {
            const QString str = data.toString();
            if(isAllPrintable(str))
            {
                if( str.contains('\"') )
                    out << "'" << str << "'";
                else
                    out << "\"" << str << "\"";
            }else
            {
                out << "#" << str.toLatin1().toHex() << "00#";
            }
        }
        break;
    case QVariant::LongLong:
    case QVariant::Int:
    case QVariant::Bool:
        out << data.toLongLong();
        break;
    case QVariant::ULongLong:
    case QVariant::UInt:
        out << data.toULongLong();
        break;
    case QVariant::Double:
        out << IlAsmRenderer::formatDouble(data);
        break;
    default:
        Q_ASSERT(false);
    }
}

void IlAsmRenderer::render(const ProcData& m)
{
    State old = state;

    if( m.kind == ProcData::ProcType || m.kind == ProcData::MethType )
    {
        out << ws() << "type ";
        lineout();
        out << m.name;
        if( m.isPublic )
            out << "*";
        out << " = proc";
        if( m.kind == ProcData::MethType )
            out << "^";
    }else
    {
        out << ws() << "procedure ";
        lineout();
        if( !m.binding.isEmpty() )
            out << m.binding << ".";
        out << m.name;
        state = Proc;
        if( m.isPublic )
            out << "* ";
    }

    out << "(";

    for( int i = 0; i < m.params.size(); i++ )
    {
        if( i != 0 )
            out << "; ";
        curLine = m.params[i].line;
        lineout();
        if( !m.params[i].type.second.isEmpty() )
            out << m.params[i].name;
        else
            out << i;
        out << ": "<< toString(m.params[i].type);
    }
    if( m.isVararg )
        out << ", .. ";

    out << ")";
    if( !m.retType.second.isEmpty() )
        out << ":" << toString(m.retType);

    switch( m.kind)
    {
    case ProcData::Extern:
        out << " extern ";
        break;
    case ProcData::Inline:
        out << " inline ";
        break;
    case ProcData::Invar:
        out << " invar ";
        break;
    case ProcData::ModuleInit:
        out << " init ";
        break;
    case ProcData::Forward:
        out << " forward ";
        break;
    }

    out << endl;

    if(m.kind == ProcData::ProcType || m.kind == ProcData::MethType ||
            m.kind == ProcData::Extern || m.kind == ProcData::Forward )
        return;

    if( !m.locals.isEmpty() )
    {
        out << ws() << "var ";
        level++;
        for( int i = 0; i < m.locals.size(); i++ )
        {
            curLine = m.locals[i].line;
            lineout();
            if( !m.locals[i].name.isEmpty() )
                out << m.locals[i].name;
            else
                out << i;
            out << ": " << toString(m.locals[i].type) << "; ";
        }
        out << endl;
        level--;
    }
    out << ws() << "begin" << endl;

    level++;
    for( int i = 0; i < m.body.size(); i++ )
    {
        const ProcData::Op& op = m.body[i];
        switch( op.op )
        {
        case IL_invalid:
            break;
        case IL_line:
            if( renderLineInfo && op.arg.toUInt() != lastLine )
            {
                lastLine = op.arg.toUInt();
                out << ws() << "line " << lastLine << endl;
            }
            break;
        case IL_if:
        case IL_iif:
        case IL_loop:
        case IL_repeat:
        case IL_switch:
        case IL_while:
            out << ws() << s_opName[op.op];
            out << endl;
            level++;
            break;
        case IL_then:
        case IL_else:
        case IL_until:
        case IL_do:
            level--;
            out << ws() << s_opName[op.op];
            out << endl;
            level++;
            break;
        case IL_end:
            level--;
            out << ws() << s_opName[op.op];
            out << endl;
            break;
        case IL_case:
            level--;
            out << ws() << s_opName[op.op];
            out << endl;
            level++;
            out << ws();
            foreach(qint64 i, op.arg.value<CaseLabelList>() )
                out << i << " ";
            out << endl;
            break;
        case IL_ldobj:
            {
                const ConstrLiteral obj = op.arg.value<ConstrLiteral>();
                out << ws() << s_opName[op.op] << " ";
                Q_ASSERT( obj.data.type() == QVariant::ByteArray ||
                          obj.data.type() == QVariant::List ||
                          obj.data.type() == QVariant::Map );
                if( obj.data.type() != QVariant::ByteArray )
                    out << toString(obj.typeRef);
                renderComponents(out,obj.data);
                out << endl;
            }
            break;
        case IL_ldstr:
            {
                QByteArray bytes = op.arg.toByteArray();
                const QString str = QString::fromLatin1(bytes);
                bool isPrint = true;
                for( int i = 0; i < str.size(); i++ )
                    if( !str[i].isPrint() )
                    {
                        isPrint = false;
                        break;
                    }
                out << ws() << s_opName[op.op] << " ";
                if( isPrint )
                {
                    bytes = str.toLatin1(); // to get rid of explicit terminating zero
                    if( bytes.contains('"') )
                        out << "'" << bytes << "'";
                    else
                        out << "\"" << bytes << "\"";
                }else
                {
                    out << "#" << bytes.toHex();
                    if( !bytes.endsWith('\0') )
                        out << "00";
                    out << "#";
                }
                out << endl;
            }
            break;
        case IL_ldc_r4:
        case IL_ldc_r8:
            out << ws() << s_opName[op.op] << " " << IlAsmRenderer::formatDouble(op.arg) << endl;
            break;
        default:
            out << ws() << s_opName[op.op];
            if( !op.arg.isNull() )
            {
                out << " ";
                if( op.arg.canConvert<Quali>() )
                {
                    Quali q = op.arg.value<Quali>();
                    out << toString(q);
                }else if( op.arg.canConvert<Trident>() )
                {
                    Trident td = op.arg.value<Trident>();
                    if( td.first.first.constData() == d_moduleName.constData() )
                        td.first.first.clear();
                    out << Emitter::toString(td);
                }else
                    out << op.arg.toByteArray();
            }
            out << endl;
            break;
        }
    }
    level--;
    out << ws() << "end ";
    curLine = m.endLine;
    lineout();
    out << m.name << endl;

    state = old;
}

QByteArray IlAsmRenderer::toString(const Quali& q)
{
    if(q.first.constData() == d_moduleName.constData())
        return q.second;
    else
        return Emitter::toString(q);
}

void IlAsmRenderer::lineout()
{
    if( renderLineInfo )
    {
        if( curLine && curLine != lastLine )
        {
            lastLine = curLine;
            out << "line " << curLine << " ";
        }
    }
}

void IlAsmRenderer::addConst(const Quali& typeRef, const QByteArray& name, const QVariant& val)
{
    out << ws() << "const ";
    lineout();
    out << name;
    if( !typeRef.second.isEmpty() )
        out << " : " << toString(typeRef);
    if( !val.isNull() )
    {
        out << " = ";
        if( val.canConvert<ConstrLiteral>())
        {
            const ConstrLiteral obj = val.value<ConstrLiteral>();
            if( obj.data.type() != QVariant::ByteArray )
                out << toString(obj.typeRef);
            renderComponents(out,obj.data);
        }else
            renderComponents(out, val );
        out << endl;
    }
}


void RenderSplitter::beginModule(const QByteArray& moduleName, const QString& sourceFile, const QByteArrayList& mp)
{
    foreach(AbstractRenderer* r, renderer)
        r->beginModule(moduleName, sourceFile, mp);
}

void RenderSplitter::endModule()
{
    foreach(AbstractRenderer* r, renderer)
        r->endModule();
}

void RenderSplitter::addImport(const QByteArray& path)
{
    foreach(AbstractRenderer* r, renderer)
        r->addImport(path);
}

void RenderSplitter::addVariable(const Quali& typeRef, QByteArray name, bool isPublic)
{
    foreach(AbstractRenderer* r, renderer)
        r->addVariable(typeRef, name, isPublic);
}

void RenderSplitter::addConst(const Quali& typeRef, const QByteArray& name, const QVariant& val)
{
    foreach(AbstractRenderer* r, renderer)
        r->addConst(typeRef, name, val);
}

void RenderSplitter::addProcedure(const ProcData& method)
{
    foreach(AbstractRenderer* r, renderer)
        r->addProcedure(method);
}

void RenderSplitter::beginType(const QByteArray& name, bool isPublic, quint8 typeKind, const Quali& super)
{
    foreach(AbstractRenderer* r, renderer)
        r->beginType(name,isPublic,typeKind, super);
}

void RenderSplitter::endType()
{
    foreach(AbstractRenderer* r, renderer)
        r->endType();
}

void RenderSplitter::addType(const QByteArray& name, bool isPublic, const Quali& baseType, quint8 typeKind, quint32 len)
{
    foreach(AbstractRenderer* r, renderer)
        r->addType(name,isPublic,baseType, typeKind, len);
}

void RenderSplitter::addField(const QByteArray& fieldName, const Quali& typeRef, bool isPublic, quint8 bits)
{
    foreach(AbstractRenderer* r, renderer)
        r->addField(fieldName,typeRef,isPublic, bits);
}

void RenderSplitter::line(quint32 l)
{
    foreach(AbstractRenderer* r, renderer)
        r->line(l);
}

// NOTE keep InMemRenderer2 in sync with Parser2

IlAstRenderer::IlAstRenderer(AstModel *mdl):mdl(mdl), module(0), type(0), curProc(0)
{
    Q_ASSERT( mdl );
}

IlAstRenderer::~IlAstRenderer()
{
    if( module )
        delete module;
}

void IlAstRenderer::beginModule(const QByteArray& moduleName, const QString& sourceFile, const QByteArrayList& mp)
{
    Q_ASSERT(module == 0);
    errors.clear();
    module = new Declaration();
    module->kind = Declaration::Module;
    if( !sourceFile.isEmpty() )
    {
        module->md = new ModuleData();
        module->md->source = sourceFile;
        source = sourceFile;
    }
    module->name = moduleName;
    module->pos = curPos;
    // TODO module->metaParams = mp;
}

void IlAstRenderer::endModule()
{
    Q_ASSERT(module != 0);
    if( module->md )
        module->md->end = curPos;


    bool success = true;
    if( !errors.isEmpty() )
        delete module;
    else
    {
        foreach( Type* t, unresolved)
        {
            if( t->getType() == 0 && t->quali )
            {
                Declaration* d = resolve(*t->quali);
                if( d && d->kind != Declaration::TypeDecl )
                    error(d, "the reference is no type declaration");
                else if( d )
                    t->setType(d->getType());
            }
        }
        unresolved.clear();

        Validator v(mdl);
#if 1
        if( !v.validate(module) )
        {
            foreach( const Validator::Error& e, v.errors )
            {
                Error ee;
                ee.msg = e.msg;
                ee.pc = e.pc;
                ee.where = e.where;
                errors << ee;
            }
            success = false;
        }
#endif
        if( !mdl->addModule(module) )
        {
            error(module, "a module with this name already existes");
            delete module;
            success = false;
        }
    }

    module = 0;
}

void IlAstRenderer::addImport(const QByteArray& path)
{
    Q_ASSERT(module);

    Declaration* imported = mdl->findModuleByName(path);
    if( imported == 0 )
        error(module, QString("cannot import: %1").arg(path.constData()));
    else
    {
        Declaration* import = new Declaration();
        import->kind = Declaration::Import;
        import->name = path;
        module->appendSub(import);
        import->imported = imported;
        import->outer = module;
        import->pos = curPos;
    }
}

void IlAstRenderer::addVariable(const Quali& typeRef, QByteArray name,  bool isPublic)
{
    Q_ASSERT(module);
    Declaration* var = new Declaration();
    var->kind = Declaration::VarDecl;
    var->name = name;
    var->public_ = isPublic;
    var->outer = module;
    var->pos = curPos;
    module->appendSub(var);
    var->setType( derefType(typeRef) );
}

void IlAstRenderer::addConst(const Quali& typeRef, const QByteArray& name, const QVariant& val)
{
    Q_ASSERT(module);
    Declaration* co = new Declaration();
    co->kind = Declaration::ConstDecl;
    co->name = name;
    co->public_ = true;
    co->outer = module;
    co->pos = curPos;
    module->appendSub(co);
    co->setType( derefType(typeRef) );
    co->c = new Constant();
    switch( val.type() )
    {
    case QVariant::Double:
        co->c->kind = Constant::D;
        co->c->d = val.toDouble();
        break;
    case QVariant::Int:
    case QVariant::LongLong:
        co->c->kind = Constant::I;
        co->c->i = val.toLongLong();
        break;
    case QVariant::ByteArray:
        if( co->getType()->kind == Type::ByteArrayLit )
        {
            co->c->kind = Constant::B;
            co->c->b = new ByteString(val.toByteArray());
        }else
        {
            co->c->kind = Constant::S;
            const QByteArray str = val.toByteArray();
            co->c->s = (char*)malloc(str.size()+1);
            strcpy(co->c->s, str.data() );
        }
        break;
    default:
        qWarning() << "TODO IlAstRenderer::addConst type not yet supported" << val.type();
        break;
    }
}

void IlAstRenderer::addProcedure(const ProcData& proc)
{
    Q_ASSERT(module);
    if( proc.kind == ProcData::ProcType || proc.kind == ProcData::MethType )
    {
        Type* t = new Type();
        t->kind = Type::Proc;
        t->pos = curPos;
        if( proc.kind == ProcData::MethType )
            t->typebound = true;
        t->setType(derefType(proc.retType));

        Declaration* decl = new Declaration();
        decl->kind = Declaration::TypeDecl;
        decl->name = proc.name;
        decl->public_ = proc.isPublic;
        decl->outer = module;
        decl->pos = curPos;
        module->appendSub(decl);
        decl->setType( t );
        t->decl = decl;

        foreach( const ProcData::Var& param, proc.params )
        {
            Declaration* p = new Declaration();
            p->kind = Declaration::ParamDecl;
            p->name = param.name;
            t->subs.append(p);
            p->outer = decl;
            p->pos = setline(param.line);
            p->setType( derefType(param.type) );
        }
    }else
    {
        Declaration* decl = new Declaration();
        decl->kind = Declaration::Procedure;
        decl->name = proc.name;
        decl->public_ = proc.isPublic;
        decl->outer = module;
        decl->pos = curPos;

        curProc = decl;

        decl->setType( derefType(proc.retType));

        switch(proc.kind)
        {
        case ProcData::Forward:
            decl->forward = true;
            break;
        case ProcData::Extern:
            decl->extern_ = true;
            break;
        case ProcData::Inline:
            decl->inline_ = true;
            break;
        case ProcData::Invar:
            decl->invar = true;
            break;
        case ProcData::ModuleInit:
            decl->entryPoint = true;
            break;
        }

        foreach( const ProcData::Var& param, proc.params )
        {
            Declaration* p = new Declaration();
            p->kind = Declaration::ParamDecl;
            p->name = param.name;
            decl->appendSub(p);
            p->outer = decl;
            p->pos = setline(param.line);
            p->setType( derefType(param.type) );
        }

        foreach( const ProcData::Var& local, proc.locals )
        {
            Declaration* p = new Declaration();
            p->kind = Declaration::LocalDecl;
            p->name = local.name;
            decl->appendSub(p);
            p->outer = decl;
            p->pos = setline(local.line);
            p->setType( derefType(local.type) );
        }

        if( !proc.binding.isEmpty() )
        {
            Declaration* receiver = module->findSubByName(proc.binding);
            if( receiver == 0 || receiver->kind != Declaration::TypeDecl || receiver->getType()->kind != Type::Object )
            {
                error(curProc, QString("invalid receiver: %1").arg(proc.binding.constData()));
                delete decl;
            }else
            {
                Type* rt = receiver->getType();
                Declaration* forward = rt->findSubByName(decl->name, false);
                if( forward && forward->forward && forward->kind == Declaration::Procedure )
                {
                    forward->name.clear();
                    forward->forwardTo = decl;
                }else if( forward )
                    error(curProc, QString("duplicate name: %1").arg(decl->name.constData()));
                rt->subs.append(decl);
                decl->outer = receiver;
            }
        }else
        {
            Declaration* forward = module->findSubByName(decl->name);
            if( forward && forward->forward && forward->kind == Declaration::Procedure )
            {
                forward->name.clear();
                forward->forwardTo = decl;
            }else if( forward )
                error(curProc, QString("duplicate name: %1").arg(decl->name.constData()));
            module->appendSub(decl);
        }

        quint32 pc = 0;
        decl->body = translateStat(proc.body, pc);
        if( proc.endLine )
        {
            if( decl->pd == 0 && module->md && !module->md->source.isEmpty() )
                decl->pd = new ProcedureData();
            if( decl->pd != 0 )
                decl->pd->end = Mic::RowCol(proc.endLine);
        }
        curProc = 0;
    }
}

static inline QByteArray format(const Quali& q )
{
    if( !q.first.isEmpty() )
        return q.first + "!" + q.second;
    else
        return q.second;
}

void IlAstRenderer::beginType(const QByteArray& name, bool isPublic, quint8 typeKind, const Quali& super)
{
    Q_ASSERT(module);

    Declaration* decl = new Declaration();
    decl->kind = Declaration::TypeDecl;
    decl->name = name;
    decl->public_ = isPublic;
    decl->outer = module;
    decl->pos = curPos;

    module->appendSub(decl);

    type = new Type();
    type->decl = decl;
    decl->setType(type);
    type->pos = curPos;

    switch(typeKind)
    {
    case EmiTypes::Struct:
        type->kind = Type::Struct;
        break;
    case EmiTypes::Union:
        type->kind = Type::Union;
        break;
    case EmiTypes::Object:
        type->kind = Type::Object;
        type->setType(derefType(super));
        if( type->getType() == 0 && !super.second.isEmpty() )
            error(decl, QString("cannot resolve base type: %1").arg(format(super).constData()));
        break;
    default:
        Q_ASSERT(false);
    }
}

void IlAstRenderer::endType()
{
    Q_ASSERT(module);
    type = 0;
}

void IlAstRenderer::addType(const QByteArray& name, bool isPublic, const Quali& baseType, quint8 typeKind, quint32 len)
{
    Q_ASSERT(module);
    Q_ASSERT(type == 0);
    Q_ASSERT(typeKind == EmiTypes::Alias || typeKind == EmiTypes::Array || typeKind == EmiTypes::Pointer);

    Declaration* decl = new Declaration();
    decl->kind = Declaration::TypeDecl;
    decl->name = name;
    decl->public_ = isPublic;
    decl->outer = module;
    decl->pos = curPos;

    module->appendSub(decl);

    Type* t = new Type();
    t->decl = decl;
    t->pos = curPos;
    decl->setType(t);
    switch( typeKind )
    {
    case EmiTypes::Alias:
        t->kind = Type::NameRef;
        t->quali = new Quali();
        *t->quali = baseType;
        break;
    default:
        t->kind = typeKind == EmiTypes::Pointer ? Type::Pointer : Type::Array;
        t->len = len;
        t->setType(derefType(baseType));
        if( t->getType() == 0 && !baseType.second.isEmpty() )
            error(decl, QString("cannot resolve base type: %1").arg(format(baseType).constData()));
        break;
    }
}

void IlAstRenderer::addField(const QByteArray& fieldName, const Quali& typeRef, bool isPublic, quint8 bits)
{
    Q_ASSERT(module);
    Q_ASSERT(type);
    Declaration* field = new Declaration();
    field->kind = Declaration::Field;
    field->name = fieldName;
    field->public_ = isPublic;
    field->setType( derefType(typeRef) );
    field->f.bw = bits;
    field->outer = type->decl;
    field->pos = curPos;

    type->subs.append(field);
}

void IlAstRenderer::line(quint32 pos)
{
    curPos = Mic::RowCol(pos);
}

Type*IlAstRenderer::derefType(const Quali &q)
{
    if( q.first.isEmpty() && q.second.isEmpty() )
        return 0;
    Declaration* type = resolve(q);
    if( type && type->kind != Declaration::TypeDecl )
    {
        error(type, QString("not a type declaration: %1").arg(type->toPath().constData()));
        return 0;
    }else if( type == 0 )
    {
        Type* ref = new Type();
        ref->kind = Type::NameRef;
        ref->quali = new Quali();
        *ref->quali = q;
        unresolved << ref;
        return ref;
    }else
        return type->getType();
}

Statement* IlAstRenderer::translateStat(const QList<ProcData::Op>& ops, quint32& pc)
{
    Statement* res = 0;
    while( pc < ops.size() )
    {
        const IL_op op = (IL_op)ops[pc].op;

        if( op == IL_line )
        {
            curPos = Mic::RowCol(ops[pc].arg.toUInt());
            pc++;
            continue;
        }

        switch(op)
        {
        case IL_case:
        case IL_do:
        case IL_until:
        case IL_then:
        case IL_else:
        case IL_end:
            return res;
        }

        Statement* tmp = new Statement();
        tmp->kind = op;
        tmp->pos = curPos;
        if( res )
            res->append(tmp);
        else
            res = tmp;

        if( op > IL_EXPRESSIONS && op < IL_STATEMENTS )
        {
            tmp->kind = (IL_op)Statement::ExprStat;
            tmp->e = translateExpr(ops, pc);
            if( tmp->e )
                tmp->pos = tmp->e->pos;
            continue;
        }

        switch(op)
        {
        case IL_while: {
                pc++;
                tmp->e = translateExpr(ops, pc);
                if( !expect(ops, pc, IL_do) )
                    return res;
                pc++;
                tmp->body = translateStat(ops, pc);
                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_repeat: {
                pc++;
                tmp->body = translateStat(ops, pc);
                if( !expect(ops, pc, IL_until) )
                    return res;
                pc++;
                tmp->e = translateExpr(ops, pc);
                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_loop: {
                pc++;
                tmp->body = translateStat(ops, pc);
                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_if: {
                pc++;
                tmp->e = translateExpr(ops, pc);
                if( !expect(ops, pc, IL_then) )
                    return res;
                pc++;
                tmp->body = translateStat(ops, pc);
                if( pc < ops.size() && ops[pc].op == IL_else )
                {
                    expect(ops, pc, IL_else);
                    tmp = new Statement();
                    tmp->kind = IL_else;
                    tmp->pos = curPos;
                    res->append(tmp);
                    pc++;
                    tmp->body = translateStat(ops, pc);
                }
                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_switch: {
                pc++;
                tmp->e = translateExpr(ops, pc);
                while( pc < ops.size() && ops[pc].op == IL_case )
                {
                    expect(ops, pc, IL_case);
                    CaseLabelList cll = ops[pc].arg.value<CaseLabelList>();
                    tmp = new Statement();
                    res->append(tmp);
                    tmp->kind = IL_case;
                    tmp->pos = curPos;
                    if( cll.isEmpty() )
                    {
                        error(curProc, "empty case label list", pc);
                        return res;
                    }
                    tmp->e = new Expression();
                    tmp->e->kind = IL_case;
                    tmp->e->i = cll.first();
                    tmp->e->pos = curPos;
                    for( int i = 1; i < cll.size(); i++ )
                    {
                        Expression* e = new Expression();
                        e->kind = IL_case;
                        e->i = cll[i];
                        e->pos = curPos;
                        tmp->e->append(e);
                    }
                    pc++;
                    if( !expect(ops, pc, IL_then) )
                        return res;
                    pc++;
                    tmp->body = translateStat(ops, pc);
                    if( pc < ops.size() && ops[pc].op == IL_else )
                    {
                        expect(ops, pc, IL_else);
                        tmp = new Statement();
                        tmp->kind = IL_else;
                        res->append(tmp);
                        tmp->pos = curPos;
                        tmp->body = translateStat(ops, pc);
                    }
                    if( !expect(ops, pc, IL_end) )
                        return res;
                }
            }
            break;
        case IL_goto:
            tmp->name = ops[pc].arg.toByteArray();
            break;
        case IL_label:
            tmp->name = ops[pc].arg.toByteArray();
            break;
        case IL_line:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_starg:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_starg_s:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_stelem:
            tmp->d = resolve(ops[pc].arg.value<Quali>());
            if( tmp->d == 0 || tmp->d->kind != Declaration::TypeDecl)
            {
                error(curProc, "invalid type declaration reference",pc);
                return res;
            }
            break;
        case IL_stfld: {
                Trident td = ops[pc].arg.value<Trident>();
                Declaration* d = derefTrident(td);
                if( d == 0 || d->kind != Declaration::Field)
                {
                    error(curProc, "invalid field declaration reference",pc);
                    return res;
                }
                tmp->d = d;
            } break;
        case IL_stind:
            tmp->d = resolve(ops[pc].arg.value<Quali>());
            if( tmp->d == 0 || tmp->d->kind != Declaration::TypeDecl)
            {
                error(curProc,"invalid type declaration reference", pc);
                return res;
            }
            break;
        case IL_stloc:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_stloc_s:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_stvar:
            tmp->d = resolve(ops[pc].arg.value<Quali>());
            if( tmp->d == 0 || tmp->d->kind != Declaration::VarDecl)
            {
                error(curProc,"invalid variable declaration reference",pc);
                return res;
            }
            break;
        case IL_stloc_1:
            tmp->id = 1;
            break;
        case IL_stloc_2:
            tmp->id = 2;
            break;
        case IL_stloc_3:
            tmp->id = 3;
            break;
        case IL_stloc_0:
        case IL_stind_i1:
        case IL_stind_i2:
        case IL_stind_i4:
        case IL_stind_i8:
        case IL_stind_r4:
        case IL_stind_r8:
        case IL_stind_ip:
        case IL_stind_ipp:
        case IL_stelem_i1:
        case IL_stelem_i2:
        case IL_stelem_i4:
        case IL_stelem_i8:
        case IL_stelem_r4:
        case IL_stelem_r8:
        case IL_stelem_ip:
        case IL_stelem_ipp:
        case IL_pop:
        case IL_ret:
        case IL_strcpy:
        case IL_free:
        case IL_exit:
            break;
        default:
            error(curProc,QString("unexpected operation '%1'").arg(s_opName[ops[pc].op]), pc);
            return res;
        }
        pc++;
    }
    return res;
}

Expression* IlAstRenderer::translateExpr(const QList<ProcData::Op>& ops, quint32& pc)
{
    Expression* res = 0;
    while(pc < ops.size() && (isExprOp((IL_op)ops[pc].op) || ops[pc].op == IL_line) )
    {
        if( ops[pc].op == IL_line )
        {
            curPos = Mic::RowCol(ops[pc].arg.toUInt());
            pc++;
            continue;
        }

        Expression* tmp = new Expression();
        tmp->pos = curPos;
        tmp->kind = (IL_op)ops[pc].op;

        if( res )
            res->append(tmp);
        else
            res = tmp;

        switch(ops[pc].op)
        {
        case IL_iif: {
                // we use this compound to assure next always points to the next expression,
                // not to the inner of the compound
                // IIF next ...
                //  e  IF next THEN next ELSE
                //     e       e         e
                pc++;
                Expression* if_ = new Expression();
                if_->kind = IL_if;
                if_->pos = tmp->pos;
                if_->e = translateExpr(ops, pc);
                tmp->e = if_;
                if( !expect(ops, pc, IL_then) )
                    return res;
                pc++;
                Expression* then_ = new Expression();
                then_->kind = IL_then;
                then_->pos = curPos;
                then_->e = translateExpr(ops, pc);
                if_->next = then_;
                if( !expect(ops, pc, IL_else) )
                    return res;
                pc++;
                Expression* else_ = new Expression();
                else_->kind = IL_else;
                else_->e = translateExpr(ops, pc);
                else_->pos = curPos;
                then_->next = else_;

                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_call:
        case IL_calli:
        case IL_callvi:
        case IL_castptr:
        case IL_initobj:
        case IL_isinst:
        case IL_ldelema:
        case IL_ldelem:
        case IL_ldind:
        case IL_ldproc:
        case IL_ldvar:
        case IL_ldvara:
        case IL_newobj:
        case IL_newvla:
        case IL_newarr:
        case IL_ptroff:
        case IL_sizeof: {
                Quali q = ops[pc].arg.value<Quali>();
                tmp->d = resolve(q);
                if(tmp->d == 0)
                {
                    error(curProc,QString("cannot resolve qualident: %1").arg(format(q).constData()),pc++);
                    return res;
                }
            } break;
        case IL_callvirt:
        case IL_ldfld:
        case IL_ldflda:
        case IL_ldmeth: {
                Trident td = ops[pc].arg.value<Trident>();
                tmp->d = derefTrident(td);
                if(tmp->d == 0 )
                {
                    error(curProc,QString("cannot resolve trident: %1.%2").arg(format(td.first).constData()).
                          arg(td.second.constData()), pc++);
                    return res;
                }
            } break;
        case IL_ldarg_s:
        case IL_ldarg:
        case IL_ldarga_s:
        case IL_ldarga:
        case IL_ldloc_s:
        case IL_ldloca_s:
        case IL_ldloca:
        case IL_ldloc:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_ldobj:
            break; // MilObject TODO
        case IL_ldstr: {
            Constant* c = new Constant();
            c->kind = Constant::S;
            const QByteArray str = ops[pc].arg.toByteArray();
            c->s = (char*)malloc( str.size() + 1);
            strcpy(c->s, str.constData());
            tmp->c = c;
            }
            break;
        case IL_ldc_i4:
        case IL_ldc_i8:
        case IL_ldc_i4_s:
            tmp->i = ops[pc].arg.toLongLong();
            break;
        case IL_ldc_r4:
        case IL_ldc_r8:
            tmp->f = ops[pc].arg.toDouble();
            break;
        case IL_ldarg_1:
            tmp->id = 1;
            break;
        case IL_ldarg_2:
            tmp->id = 2;
            break;
        case IL_ldarg_3:
            tmp->id = 3;
            break;
        case IL_ldc_i4_1:
            tmp->i = 1;
            break;
        case IL_ldloc_1:
            tmp->id = 1;
            break;
        case IL_ldloc_2:
            tmp->id = 2;
            break;
        case IL_ldloc_3:
            tmp->id = 3;
            break;
        case IL_ldc_i4_2:
            tmp->i = 2;
            break;
        case IL_ldc_i4_3:
            tmp->i = 3;
            break;
        case IL_ldc_i4_4:
            tmp->i = 4;
            break;
        case IL_ldc_i4_5:
            tmp->i = 5;
            break;
        case IL_ldc_i4_6:
            tmp->i = 6;
            break;
        case IL_ldc_i4_7:
            tmp->i = 7;
            break;
        case IL_ldc_i4_8:
            tmp->i = 8;
            break;
        case IL_ldc_i4_m1:
            tmp->i = -1;
            break;
        }

        pc++;
    }
    return res;
}

bool IlAstRenderer::expect(const QList<ProcData::Op>& ops, quint32& pc, int op)
{
    // pc is not changed in here!
    if( pc >= ops.size() || ops[pc].op != op )
    {
        error(curProc, QString("expecting '%1', instead got '%2'").arg(s_opName[op]).arg(s_opName[ops[pc].op]), pc);
        return false;
    }else
        return true;
}

Declaration*IlAstRenderer::derefTrident(const Trident& td) const
{
    Declaration* d = resolve(td.first);
    if( d == 0 || d->kind != Declaration::TypeDecl || d->getType() == 0)
        return 0;
    d = d->getType()->findSubByName(td.second);
    return d;
}

Declaration*IlAstRenderer::resolve(const Quali &q) const
{
    if( q.first.isEmpty() )
    {
        Declaration* res = module->findSubByName(q.second);
        if( res == 0 )
            res = mdl->getGlobals()->findSubByName(q.second);
        return res;
    }else
        return mdl->resolve(q);
}

void IlAstRenderer::error(Declaration* d, const QString& msg, int pc)
{
    Error e;
    e.msg = msg;
    e.where = d->toPath();
    if( curProc)
        e.pc = pc;
    errors << e;
}
