/*
* Copyright 2019-2025 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the Micron language project.
*
* The following is the license that applies to this copy of the
* file. For a license to use the file under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "MilRenderer.h"
#include "MilEmitter.h"
#include "MilOps.h"
#include "MilAst.h"
#include "MilValidator.h"
#include "MilAstSerializer.h"
#include <QCoreApplication>
#include <QDateTime>
#include <QFile>
#include <QtDebug>
using namespace Mil;

IlAsmRenderer::IlAsmRenderer(QIODevice* dev, bool renderLineInfo):
    level(0),renderLineInfo(renderLineInfo),state(Idle),curLine(0), lastLine(0)
{
    // default is UTF-8, so no need to setCodec
    out.setDevice(dev);
}

void IlAsmRenderer::beginModule(const QByteArray& moduleName, const QString& sourceFile, const QByteArrayList& mp)
{
    source = sourceFile;
    d_moduleName = moduleName;
    out << "// Generated by " << qApp->applicationName() << " " << qApp->applicationVersion() << " on "
        << QDateTime::currentDateTime().toString(Qt::ISODate) << endl << endl;

    out << "module ";
    lineout();
    out << moduleName;
    if( !mp.isEmpty() )
    {
        out << " (";
        for( int i = 0; i < mp.size(); i++ )
        {
            if( i != 0 )
                out << ", ";
            out << mp[i];
        }
        out << ")";
    }
    out << endl;

    state = Module;
    level++;

    if( renderLineInfo && !sourceFile.isEmpty() )
        out << ws() << "source \"" << sourceFile << "\"" << endl;
}

void IlAsmRenderer::endModule()
{
    level--;
    out << ws() << "end ";
    lineout();
    out << d_moduleName << endl;
    state = Idle;
}

void IlAsmRenderer::addImport(const QByteArray& path, bool reverse)
{
    out << ws() << (reverse? "importer " : "import ");
    lineout();
    out << path;
    out << endl;
}

void IlAsmRenderer::addVariable(const Quali& typeRef, QByteArray name, bool isPublic)
{
    out << ws() << "var ";
    lineout();
    out << name << ": " << toString(typeRef) << endl;
}

void IlAsmRenderer::addProcedure(const ProcData& m)
{
    if( m.kind == ProcData::Invalid )
        return;
    render(m);
}

void IlAsmRenderer::beginType(const QByteArray& className, bool isPublic, quint8 classKind, const Quali& super)
{
    Q_ASSERT(classKind == EmiTypes::Union || classKind == EmiTypes::Struct || classKind == EmiTypes::Object);
    state = Struct;
    out << ws() << "type ";
    lineout();
    out << className;
    if( isPublic )
        out << "*";

    out << " = ";
    if( classKind == EmiTypes::Union )
        out << "union ";
    else if( classKind == EmiTypes::Object )
    {
        out << "object ";
        if( !super.first.isEmpty() || !super.second.isEmpty() )
        {
            out << "(";
            out << toString(super);
            out << ")";
        }
    }
    else
        out << "struct ";

    out << endl;
    level++;
}

void IlAsmRenderer::endType()
{
    level--;
    out << ws();
    out << "end";
    out << endl;
    state = Module;
}

void IlAsmRenderer::addType(const QByteArray& name, bool isPublic, const Quali& baseType, quint8 typeKind, quint32 len)
{
    out << ws() << "type ";
    lineout();
    out << name;
    if( isPublic )
        out << "*";

    if( typeKind == EmiTypes::Generic )
    {
        out << endl;
        return;
    }
    out << " = ";
    switch(typeKind)
    {
    case EmiTypes::Alias:
        out << toString(baseType) << endl;
        break;
    case EmiTypes::Pointer:
        out << "pointer to " << toString(baseType) << endl;
        break;
    case EmiTypes::Array:
        out << "array ";
        if( len )
            out << len << " ";
        out << "of " << toString(baseType) << endl;
        break;
    case EmiTypes::Interface:
        out << "interface" << endl;
        break;
    default:
        Q_ASSERT(false);
    }
}

void IlAsmRenderer::addField(const QByteArray& fieldName, const Quali& typeRef, bool isPublic, quint8 bits)
{
    out << ws();
    if( fieldName.isEmpty() && state == Struct )
    {
        out << ".. " << bits;
    }else
    {
        if( state == Module )
            out << "var ";
        lineout();
        out << fieldName;
        if( isPublic )
            out << "*";

        out << ": " << toString(typeRef);
        if( bits && state == Struct )
            out << " : " << bits;
    }
    out << endl;
}

void IlAsmRenderer::line(quint32 l)
{
    curLine = l;
}

QString IlAsmRenderer::formatDouble(const QVariant& v)
{
    QString tmp = v.toString();
    const int eidx = tmp.indexOf('e', 0, Qt::CaseInsensitive);
    if( eidx != -1 )
    {
        if( eidx == 0 ) // e-5
            tmp.prepend("0.0");
        else if( !tmp.left(eidx).contains('.')  // 3e-5
                 || tmp[eidx-1] == '.' )        // 3.e-5
            tmp = tmp.left(eidx) + QString(".0") + tmp.mid(eidx);
        if( tmp[0] == '.' ) // .0e-5, .e-5
            tmp.prepend("0");
    }
    return tmp;
}

static inline bool isAllPrintable(const QString& str)
{
    for( int i = 0; i < str.size(); i++ )
    {
        if( !str[i].isPrint() )
            return false;
    }
    return true;
}

static void renderComponents( QTextStream& out, const QVariant& data )
{
    if( data.canConvert<RecordLiteral>() )
    {
        out << "{";
        RecordLiteral m = data.value<RecordLiteral>();
        for( int i = 0; i < m.size(); i++ )
        {
            out << m[i].first << "=";
            renderComponents(out,m[i].second);
        }
        out << "}";
        return;
    }
    switch( data.type() )
    {
    case QVariant::List:
        out << "{";
        foreach( const QVariant& v, data.toList() )
        {
            renderComponents(out,v);
            out << " ";
        }
        out << "}";
        break;
    case QVariant::ByteArray:
        out << "#" << data.toByteArray().toHex() << "#";
        break;
    case QVariant::String:
        {
            const QString str = data.toString();
            if(isAllPrintable(str))
            {
                if( str.contains('\"') )
                    out << "'" << str << "'";
                else
                    out << "\"" << str << "\"";
            }else
            {
                out << "#" << str.toLatin1().toHex() << "00#";
            }
        }
        break;
    case QVariant::LongLong:
    case QVariant::Int:
    case QVariant::Bool:
        out << data.toLongLong();
        break;
    case QVariant::ULongLong:
    case QVariant::UInt:
        out << data.toULongLong();
        break;
    case QVariant::Double:
        out << IlAsmRenderer::formatDouble(data);
        break;
    default:
        Q_ASSERT(false);
    }
}

void IlAsmRenderer::render(const ProcData& m)
{
    State old = state;

    if( m.kind == ProcData::ProcType || m.kind == ProcData::MethType )
    {
        out << ws() << "type ";
        lineout();
        out << m.name;
        if( m.isPublic )
            out << "*";
        out << " = proc";
        if( m.kind == ProcData::MethType )
            out << "^";
    }else
    {
        out << ws() << "procedure ";
        lineout();
        if( !m.binding.isEmpty() )
            out << m.binding << ".";
        out << m.name;
        state = Proc;
        if( m.isPublic )
            out << "* ";
    }

    out << "(";

    for( int i = 0; i < m.params.size(); i++ )
    {
        if( i != 0 )
            out << "; ";
        curLine = m.params[i].line;
        lineout();
        if( !m.params[i].type.second.isEmpty() )
            out << m.params[i].name;
        else
            out << i;
        out << ": "<< toString(m.params[i].type);
    }

    out << ")";
    if( !m.retType.second.isEmpty() )
        out << ":" << toString(m.retType);

    switch( m.kind)
    {
    case ProcData::Extern:
        out << " extern ";
        break;
    case ProcData::Foreign:
        out << " extern c ";
        if( !m.origName.isEmpty() )
            out << "\"" << m.origName << "\" ";
        break;
    case ProcData::Inline:
        out << " inline ";
        break;
    case ProcData::Invar:
        out << " invar ";
        break;
    case ProcData::Abstract:
        out << " abstract ";
        break;
    case ProcData::ModuleInit:
        out << " init ";
        break;
    case ProcData::Forward:
        out << " forward ";
        break;
    }

    out << endl;

    if(m.kind == ProcData::ProcType || m.kind == ProcData::MethType ||
            m.kind == ProcData::Extern || m.kind == ProcData::Foreign || m.kind == ProcData::Forward || m.kind == ProcData::Abstract )
        return;

    if( !m.locals.isEmpty() )
    {
        out << ws() << "var ";
        level++;
        for( int i = 0; i < m.locals.size(); i++ )
        {
            curLine = m.locals[i].line;
            lineout();
            if( !m.locals[i].name.isEmpty() )
                out << m.locals[i].name;
            else
                out << i;
            out << ": " << toString(m.locals[i].type) << "; ";
        }
        out << endl;
        level--;
    }
    out << ws() << "begin" << endl;

    level++;
    for( int i = 0; i < m.body.size(); i++ )
    {
        const ProcData::Op& op = m.body[i];
        switch( op.op )
        {
        case IL_invalid:
            break;
        case IL_line:
            if( renderLineInfo && op.arg.toUInt() != lastLine )
            {
                lastLine = op.arg.toUInt();
                out << ws() << "line " << lastLine << endl;
            }
            break;
        case IL_if:
        case IL_iif:
        case IL_loop:
        case IL_repeat:
        case IL_switch:
        case IL_while:
            out << ws() << s_opName[op.op];
            out << endl;
            level++;
            break;
        case IL_then:
        case IL_else:
        case IL_until:
        case IL_do:
            level--;
            out << ws() << s_opName[op.op];
            out << endl;
            level++;
            break;
        case IL_end:
            level--;
            out << ws() << s_opName[op.op];
            out << endl;
            break;
        case IL_case:
            level--;
            out << ws() << s_opName[op.op];
            foreach(qint64 i, op.arg.value<CaseLabelList>() )
                out << " " << i;
            level++;
            out << endl;
            break;
        case IL_ldc_obj:
            {
                const ConstrLiteral obj = op.arg.value<ConstrLiteral>();
                out << ws() << s_opName[op.op] << " ";
                if( obj.data.type() != QVariant::ByteArray )
                    out << toString(obj.typeRef);
                renderComponents(out,obj.data);
                out << endl;
            }
            break;
        case IL_ldstr:
            {
                QByteArray bytes = op.arg.toByteArray();
                const QString str = QString::fromLatin1(bytes);
                bool isPrint = true;
                for( int i = 0; i < str.size(); i++ )
                    if( !str[i].isPrint() )
                    {
                        isPrint = false;
                        break;
                    }
                out << ws() << s_opName[op.op] << " ";
                if( isPrint )
                {
                    bytes = str.toLatin1(); // to get rid of explicit terminating zero
                    if( bytes.contains('"') )
                        out << "'" << bytes << "'";
                    else
                        out << "\"" << bytes << "\"";
                }else
                {
                    out << "#" << bytes.toHex();
                    if( !bytes.endsWith('\0') )
                        out << "00";
                    out << "#";
                }
                out << endl;
            }
            break;
        case IL_ldc_r4:
        case IL_ldc_r8:
            out << ws() << s_opName[op.op] << " " << IlAsmRenderer::formatDouble(op.arg) << endl;
            break;
        default:
            out << ws() << s_opName[op.op];
            if( !op.arg.isNull() )
            {
                out << " ";
                if( op.arg.canConvert<Quali>() )
                {
                    Quali q = op.arg.value<Quali>();
                    out << toString(q);
                }else if( op.arg.canConvert<Trident>() )
                {
                    Trident td = op.arg.value<Trident>();
                    if( td.first.first.constData() == d_moduleName.constData() )
                        td.first.first.clear();
                    out << Emitter::toString(td);
                }else
                    out << op.arg.toByteArray();
            }
            out << endl;
            break;
        }
    }
    level--;
    out << ws() << "end ";
    curLine = m.endLine;
    lineout();
    out << m.name << endl;

    state = old;
}

QByteArray IlAsmRenderer::toString(const Quali& q)
{
    if(q.first.constData() == d_moduleName.constData())
        return q.second;
    else
        return Emitter::toString(q);
}

void IlAsmRenderer::lineout()
{
    if( renderLineInfo )
    {
        if( curLine && curLine != lastLine )
        {
            lastLine = curLine;
            out << "line " << curLine << " ";
        }
    }
}

void IlAsmRenderer::addConst(const Quali& typeRef, const QByteArray& name, const QVariant& val)
{
    out << ws() << "const ";
    lineout();
    out << name;
    if( !typeRef.second.isEmpty() )
        out << " : " << toString(typeRef);
    if( !val.isNull() )
    {
        out << " = ";
        if( val.canConvert<ConstrLiteral>())
        {
            const ConstrLiteral obj = val.value<ConstrLiteral>();
            if( obj.data.type() != QVariant::ByteArray )
                out << toString(obj.typeRef);
            renderComponents(out,obj.data);
        }else
            renderComponents(out, val );
        out << endl;
    }
}


void RenderSplitter::beginModule(const QByteArray& moduleName, const QString& sourceFile, const QByteArrayList& mp)
{
    foreach(AbstractRenderer* r, renderer)
        r->beginModule(moduleName, sourceFile, mp);
}

void RenderSplitter::endModule()
{
    foreach(AbstractRenderer* r, renderer)
        r->endModule();
}

void RenderSplitter::addImport(const QByteArray& path, bool reverse)
{
    foreach(AbstractRenderer* r, renderer)
        r->addImport(path, reverse);
}

void RenderSplitter::addVariable(const Quali& typeRef, QByteArray name, bool isPublic)
{
    foreach(AbstractRenderer* r, renderer)
        r->addVariable(typeRef, name, isPublic);
}

void RenderSplitter::addConst(const Quali& typeRef, const QByteArray& name, const QVariant& val)
{
    foreach(AbstractRenderer* r, renderer)
        r->addConst(typeRef, name, val);
}

void RenderSplitter::addProcedure(const ProcData& method)
{
    foreach(AbstractRenderer* r, renderer)
        r->addProcedure(method);
}

void RenderSplitter::beginType(const QByteArray& name, bool isPublic, quint8 typeKind, const Quali& super)
{
    foreach(AbstractRenderer* r, renderer)
        r->beginType(name,isPublic,typeKind, super);
}

void RenderSplitter::endType()
{
    foreach(AbstractRenderer* r, renderer)
        r->endType();
}

void RenderSplitter::addType(const QByteArray& name, bool isPublic, const Quali& baseType, quint8 typeKind, quint32 len)
{
    foreach(AbstractRenderer* r, renderer)
        r->addType(name,isPublic,baseType, typeKind, len);
}

void RenderSplitter::addField(const QByteArray& fieldName, const Quali& typeRef, bool isPublic, quint8 bits)
{
    foreach(AbstractRenderer* r, renderer)
        r->addField(fieldName,typeRef,isPublic, bits);
}

void RenderSplitter::line(quint32 l)
{
    foreach(AbstractRenderer* r, renderer)
        r->line(l);
}

// NOTE keep InMemRenderer2 in sync with Parser2

IlAstRenderer::IlAstRenderer(AstModel *mdl):mdl(mdl), module(0), type(0), curProc(0)
{
    Q_ASSERT( mdl );
}

IlAstRenderer::~IlAstRenderer()
{
    // don't delete module
}

void IlAstRenderer::beginModule(const QByteArray& moduleName, const QString& sourceFile, const QByteArrayList& mp)
{
    Q_ASSERT(module == 0);
    errors.clear();
    unresolved.clear();
    toDelete = false;
    module = new Declaration();
    module->kind = Declaration::Module;
    if( !sourceFile.isEmpty() || !mp.isEmpty() )
    {
        module->md = new ModuleData();
        module->md->source = sourceFile;
        module->md->metaParamNames = mp;
        module->generic = !mp.isEmpty();
        source = sourceFile;
    }
    module->name = moduleName;
    module->pos = curPos;
    // TODO module->metaParams = mp;

    // we register the module immediately so that a generic which depends on this module
    // can see the types declared here and passed to the generic
    if( !mdl->addModule(module) )
    {
        error(module, "a module with this name already existes");
        toDelete = true;
    }
}

void IlAstRenderer::endModule()
{
    Q_ASSERT(module != 0);
    if( module->md )
        module->md->end = curPos;

    resolveAll(true);

    //dump("before validation");

    if( toDelete )
    {
        delete module;
        module = 0;
        return;
    }

#if 1
    Validator v(mdl);
    if( !v.validate(module) )
    {
        foreach( const Validator::Error& e, v.errors )
        {
            Error ee;
            ee.msg = e.msg;
            ee.pc = e.pc;
            ee.where = e.where;
            errors << ee;
        }
    }
    // dump("after validation");
#endif
}

void IlAstRenderer::addImport(const QByteArray& path, bool reverse)
{
    Q_ASSERT(module);

    Declaration* imported = mdl->findModuleByName(path);
    if( imported == 0 )
        error(module, QString("cannot import: %1").arg(path.constData()));
    else
    {
        Declaration* import = new Declaration();
        import->kind = reverse ? Declaration::Importer : Declaration::Import;
        import->name = path;
        module->appendSub(import);
        import->imported = imported;
        import->outer = module;
        import->pos = curPos;
    }
}

void IlAstRenderer::addVariable(const Quali& typeRef, QByteArray name,  bool isPublic)
{
    Q_ASSERT(module);
    Declaration* var = new Declaration();
    var->kind = Declaration::VarDecl;
    var->name = name;
    var->public_ = isPublic;
    var->outer = module;
    var->pos = curPos;
    module->appendSub(var);
    var->setType( derefType(typeRef) );
}

void IlAstRenderer::addConst(const Quali& typeRef, const QByteArray& name, const QVariant& val)
{
    Q_ASSERT(module);
    Declaration* co = new Declaration();
    co->kind = Declaration::ConstDecl;
    co->name = name;
    co->public_ = true;
    co->outer = module;
    co->pos = curPos;
    module->appendSub(co);
    co->setType( derefType(typeRef) );
    co->c = new Constant();
    switch( val.type() )
    {
    case QVariant::Double:
        co->c->kind = Constant::D;
        co->c->d = val.toDouble();
        break;
    case QVariant::Int:
    case QVariant::LongLong:
        co->c->kind = Constant::I;
        co->c->i = val.toLongLong();
        break;
    case QVariant::ByteArray:
        if( co->getType()->kind == Type::ByteArrayLit )
        {
            co->c->kind = Constant::B;
            co->c->b = new ByteString(val.toByteArray());
        }else
        {
            co->c->kind = Constant::S;
            const QByteArray str = val.toByteArray();
            co->c->s = (char*)malloc(str.size()+1);
            strcpy(co->c->s, str.data() );
        }
        break;
    default:
        qWarning() << "TODO IlAstRenderer::addConst type not yet supported" << val.type();
        break;
    }
}

void IlAstRenderer::addProcedure(const ProcData& proc)
{
    Q_ASSERT(module);
    if( proc.kind == ProcData::ProcType || proc.kind == ProcData::MethType )
    {
        Type* t = new Type();
        t->kind = Type::Proc;
        t->pos = curPos;
        if( proc.kind == ProcData::MethType )
            t->typebound = true;
        t->setType(derefType(proc.retType));

        Declaration* decl = new Declaration();
        decl->kind = Declaration::TypeDecl;
        decl->name = proc.name;
        decl->public_ = proc.isPublic;
        decl->outer = module;
        decl->pos = curPos;
        module->appendSub(decl);
        decl->setType( t );
        t->decl = decl;

        foreach( const ProcData::Var& param, proc.params )
        {
            Declaration* p = new Declaration();
            p->kind = Declaration::ParamDecl;
            p->name = param.name;
            t->subs.append(p);
            p->outer = decl;
            p->pos = setline(param.line);
            p->setType( derefType(param.type) );
        }
    }else
    {
        resolveAll();
        Declaration* decl = new Declaration();
        decl->kind = Declaration::Procedure;
        decl->name = proc.name;
        decl->public_ = proc.isPublic;
        decl->outer = module;
        decl->pos = curPos;

        curProc = decl;

        decl->setType( derefType(proc.retType));

        switch(proc.kind)
        {
        case ProcData::Forward:
            decl->forward = true;
            break;
        case ProcData::Extern:
            decl->extern_ = true;
            break;
        case ProcData::Foreign:
            decl->foreign_ = true;
            decl->getPd()->origName = proc.origName;
            break;
        case ProcData::Inline:
            decl->inline_ = true;
            break;
        case ProcData::Invar:
            decl->invar = true;
            break;
        case ProcData::ModuleInit:
            decl->entryPoint = true;
            break;
        }

        foreach( const ProcData::Var& param, proc.params )
        {
            Declaration* p = new Declaration();
            p->kind = Declaration::ParamDecl;
            p->name = param.name;
            decl->appendSub(p);
            p->outer = decl;
            p->pos = setline(param.line);
            p->setType( derefType(param.type) );
        }

        foreach( const ProcData::Var& local, proc.locals )
        {
            Declaration* p = new Declaration();
            p->kind = Declaration::LocalDecl;
            p->name = local.name;
            decl->appendSub(p);
            p->outer = decl;
            p->pos = setline(local.line);
            p->setType( derefType(local.type) );
        }

        if( !proc.binding.isEmpty() )
        {
            decl->typebound = true;
            Declaration* receiver = module->findSubByName(proc.binding);
            if( receiver == 0 || receiver->kind != Declaration::TypeDecl ||
                    !(receiver->getType()->kind == Type::Object || receiver->getType()->kind == Type::Interface || receiver->getType()->kind == Type::Struct))
            {
                error(curProc, QString("invalid receiver: %1").arg(proc.binding.constData()));
                delete decl;
            }else
            {
                resolveAll(); // because of binding pointer which can point to a named ref
                Type* rt = receiver->getType();
                if( rt ) rt = rt->deref();
                Declaration* forward = rt->findSubByName(decl->name, false);
                if( forward && forward->forward && forward->kind == Declaration::Procedure )
                {
                    forward->name.clear();
                    forward->forwardTo = decl;
                }else if( forward )
                    error(curProc, QString("duplicate name: %1").arg(decl->name.constData()));

                if( rt->kind == Type::Interface )
                    decl->nobody = true; // interface procedures have no body and no self param
                else
                {
                    Type* ptr = decl->subs ? decl->subs->getType() : 0;
                    if( ptr ) ptr = ptr->deref();
                    Type* obj = ptr ? ptr->getType() : 0;
                    if( obj ) obj = obj->deref();
                    if( decl->subs == 0 || decl->subs->kind != Declaration::ParamDecl ||
                            ptr == 0 ||  ptr->kind != Type::Pointer ||
                            obj == 0 || (obj->kind != Type::Object && obj->kind != Type::Struct) || obj != rt )
                        error(curProc, QString("first parameter of a bound procedure must be a pointer to the object type"));
                    else if( decl->subs )
                        decl->subs->typebound = true;
                }
                rt->subs.append(decl);
                decl->outer = receiver;
            }
        }else
        {
            Declaration* forward = module->findSubByName(decl->name);
            if( forward && forward->forward && forward->kind == Declaration::Procedure )
            {
                forward->name.clear();
                forward->forwardTo = decl;
            }else if( forward )
                error(curProc, QString("duplicate name: %1").arg(decl->name.constData()));
            module->appendSub(decl);
        }

        quint32 pc = 0;
        decl->body = translateStat(proc.body, pc);
        if( proc.endLine && !decl->forward )
            decl->getPd()->end = Mic::RowCol(proc.endLine);
        curProc = 0;
    }
}

static inline QByteArray format(const Quali& q )
{
    if( !q.first.isEmpty() )
        return q.first + "!" + q.second;
    else
        return q.second;
}

void IlAstRenderer::beginType(const QByteArray& name, bool isPublic, quint8 typeKind, const Quali& super)
{
    Q_ASSERT(module);

    Declaration* decl = new Declaration();
    decl->kind = Declaration::TypeDecl;
    decl->name = name;
    decl->public_ = isPublic;
    decl->outer = module;
    decl->pos = curPos;

    module->appendSub(decl);

    type = new Type();
    type->decl = decl;
    decl->setType(type);
    type->pos = curPos;

    switch(typeKind)
    {
    case EmiTypes::Struct:
        type->kind = Type::Struct;
        break;
    case EmiTypes::Union:
        type->kind = Type::Union;
        break;
    case EmiTypes::Object:
        type->kind = Type::Object;
        type->setType(derefType(super));
        if( type->getType() == 0 && !super.second.isEmpty() )
            error(decl, QString("cannot resolve base type: %1").arg(format(super).constData()));
        break;
    default:
        Q_ASSERT(false);
    }
}

void IlAstRenderer::endType()
{
    Q_ASSERT(module);
    type = 0;
    resolveAll();
}

void IlAstRenderer::addType(const QByteArray& name, bool isPublic, const Quali& baseType, quint8 typeKind, quint32 len)
{
    Q_ASSERT(module);
    Q_ASSERT(type == 0);
    Q_ASSERT(typeKind == EmiTypes::Alias || typeKind == EmiTypes::Array || typeKind == EmiTypes::Pointer
             || typeKind == EmiTypes::Generic || typeKind == EmiTypes::Interface);

    Declaration* decl = new Declaration();
    decl->kind = Declaration::TypeDecl;
    decl->name = name;
    decl->public_ = isPublic;
    decl->outer = module;
    decl->pos = curPos;

    module->appendSub(decl);

    Type* t = new Type();
    t->decl = decl;
    t->pos = curPos;
    decl->setType(t);
    switch( typeKind )
    {
    case EmiTypes::Alias:
        t->kind = Type::NameRef;
        t->quali = new Quali();
        *t->quali = baseType;
        unresolved << t;
        break;
    case EmiTypes::Interface:
        t->kind = Type::Interface;
        break;
    case EmiTypes::Generic:
        t->kind = Type::Generic;
        break;
    default:
        t->kind = typeKind == EmiTypes::Pointer ? Type::Pointer : Type::Array;
        t->len = len;
        t->setType(derefType(baseType));
        if( t->getType() == 0 && !baseType.second.isEmpty() )
            error(decl, QString("cannot resolve base type: %1").arg(format(baseType).constData()));
        break;
    }
}

void IlAstRenderer::addField(const QByteArray& fieldName, const Quali& typeRef, bool isPublic, quint8 bits)
{
    Q_ASSERT(module);
    Q_ASSERT(type);
    Declaration* field = new Declaration();
    field->kind = Declaration::Field;
    field->name = fieldName;
    field->public_ = isPublic;
    field->setType( derefType(typeRef) );
    field->f.bw = bits;
    field->outer = type->decl;
    field->pos = curPos;

    type->subs.append(field);
}

void IlAstRenderer::line(quint32 pos)
{
    curPos = Mic::RowCol(pos);
}

Type*IlAstRenderer::derefType(const Quali &q)
{
    if( q.first.isEmpty() && q.second.isEmpty() )
        return 0;
    Declaration* type = resolve(q);
    if( type && type->kind != Declaration::TypeDecl )
    {
        error(type, QString("not a type declaration: %1").arg(type->toPath().constData()));
        return 0;
    }else if( type == 0 ) // TODO: why not make a NameRef for all qualis?
    {
        Type* ref = new Type();
        ref->kind = Type::NameRef;
        ref->quali = new Quali();
        *ref->quali = q;
        unresolved << ref;
        return ref;
    }else
        return type->getType();
}

Statement* IlAstRenderer::translateStat(const QList<ProcData::Op>& ops, quint32& pc)
{
    Statement* res = 0;
    while( pc < ops.size() )
    {
        const IL_op op = (IL_op)ops[pc].op;

        if( op == IL_line )
        {
            curPos = Mic::RowCol(ops[pc].arg.toUInt());
            pc++;
            continue;
        }

        switch(op)
        {
        case IL_case:
        case IL_do:
        case IL_until:
        case IL_then:
        case IL_else:
        case IL_end:
            return res;
        }

        Statement* tmp = new Statement();
        tmp->kind = op;
        tmp->pos = curPos;
        if( res )
            res->append(tmp);
        else
            res = tmp;

        if( op > IL_EXPRESSIONS && op < IL_STATEMENTS )
        {
            tmp->kind = (IL_op)Statement::ExprStat;
            tmp->e = translateExpr(ops, pc);
            if( tmp->e )
                tmp->pos = tmp->e->pos;
            continue;
        }

        switch(op)
        {
        case IL_while: {
                pc++;
                tmp->e = translateExpr(ops, pc);
                if( !expect(ops, pc, IL_do) )
                    return res;
                pc++;
                tmp->body = translateStat(ops, pc);
                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_repeat: {
                pc++;
                tmp->body = translateStat(ops, pc);
                if( !expect(ops, pc, IL_until) )
                    return res;
                pc++;
                tmp->e = translateExpr(ops, pc);
                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_loop: {
                pc++;
                tmp->body = translateStat(ops, pc);
                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_if: {
                pc++;
                tmp->e = translateExpr(ops, pc);
                if( !expect(ops, pc, IL_then) )
                    return res;
                pc++;
                tmp->body = translateStat(ops, pc);
                if( pc < ops.size() && ops[pc].op == IL_else )
                {
                    expect(ops, pc, IL_else);
                    tmp = new Statement();
                    tmp->kind = IL_else;
                    tmp->pos = curPos;
                    res->append(tmp);
                    pc++;
                    tmp->body = translateStat(ops, pc);
                }
                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_switch: {
                pc++;
                tmp->e = translateExpr(ops, pc);
                while( pc < ops.size() && ops[pc].op == IL_case )
                {
                    expect(ops, pc, IL_case);
                    CaseLabelList cll = ops[pc].arg.value<CaseLabelList>();
                    tmp = new Statement();
                    res->append(tmp);
                    tmp->kind = IL_case;
                    tmp->pos = curPos;
                    if( cll.isEmpty() )
                    {
                        error(curProc, "empty case label list", pc);
                        return res;
                    }
                    tmp->e = new Expression();
                    tmp->e->kind = IL_case;
                    tmp->e->i = cll.first();
                    tmp->e->pos = curPos;
                    for( int i = 1; i < cll.size(); i++ )
                    {
                        Expression* e = new Expression();
                        e->kind = IL_case;
                        e->i = cll[i];
                        e->pos = curPos;
                        tmp->e->append(e);
                    }
                    pc++;
                    if( !expect(ops, pc, IL_then) )
                        return res;
                    pc++;
                    tmp->body = translateStat(ops, pc);
                }
                if( pc < ops.size() && ops[pc].op == IL_else )
                {
                    expect(ops, pc, IL_else);
                    pc++;
                    tmp = new Statement();
                    tmp->kind = IL_else;
                    res->append(tmp);
                    tmp->pos = curPos;
                    tmp->body = translateStat(ops, pc);
                }
                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_goto:
            tmp->name = ops[pc].arg.toByteArray();
            break;
        case IL_label:
            tmp->name = ops[pc].arg.toByteArray();
            break;
        case IL_line:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_starg:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_starg_s:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_stelem:
            tmp->d = resolve(ops[pc].arg.value<Quali>());
            if( tmp->d == 0 || tmp->d->kind != Declaration::TypeDecl)
            {
                error(curProc, "invalid type declaration reference",pc);
                return res;
            }
            break;
        case IL_stfld: {
                Trident td = ops[pc].arg.value<Trident>();
                Declaration* d = derefTrident(td);
                if( d == 0 || d->kind != Declaration::Field)
                {
                    error(curProc, "invalid field declaration reference",pc);
                    return res;
                }
                tmp->d = d;
            } break;
        case IL_stind:
            tmp->d = resolve(ops[pc].arg.value<Quali>());
            if( tmp->d == 0 || tmp->d->kind != Declaration::TypeDecl)
            {
                error(curProc,"invalid type declaration reference", pc);
                return res;
            }
            break;
        case IL_stloc:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_stloc_s:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_stvar: {
                Quali q = ops[pc].arg.value<Quali>();
                tmp->d = resolve(q);
                if( tmp->d == 0 || tmp->d->kind != Declaration::VarDecl)
                {
                    tmp->d = resolve(q);
                    error(curProc,"invalid variable declaration reference",pc);
                    return res;
                }
            } break;
        case IL_stloc_1:
            tmp->id = 1;
            break;
        case IL_stloc_2:
            tmp->id = 2;
            break;
        case IL_stloc_3:
            tmp->id = 3;
            break;
        case IL_stloc_0:
        case IL_stind_i1:
        case IL_stind_i2:
        case IL_stind_i4:
        case IL_stind_i8:
        case IL_stind_r4:
        case IL_stind_r8:
        case IL_stind_ip:
        case IL_stind_ipp:
        case IL_stelem_i1:
        case IL_stelem_i2:
        case IL_stelem_i4:
        case IL_stelem_i8:
        case IL_stelem_r4:
        case IL_stelem_r8:
        case IL_stelem_ip:
        case IL_stelem_ipp:
        case IL_pop:
        case IL_strcpy:
        case IL_free:
        case IL_exit:
            break;
        case IL_ret:
            break;
        default:
            error(curProc,QString("unexpected operation '%1'").arg(s_opName[ops[pc].op]), pc);
            return res;
        }
        pc++;
    }
    return res;
}

Expression* IlAstRenderer::translateExpr(const QList<ProcData::Op>& ops, quint32& pc)
{
    Expression* res = 0;
    while(pc < ops.size() && (isExprOp((IL_op)ops[pc].op) || ops[pc].op == IL_line) )
    {
        const IL_op op = (IL_op)ops[pc].op;

        if( op == IL_line )
        {
            curPos = Mic::RowCol(ops[pc].arg.toUInt());
            pc++;
            continue;
        }

        Expression* tmp = new Expression();
        tmp->pos = curPos;
        tmp->kind = op;

        if( res )
            res->append(tmp);
        else
            res = tmp;

        switch(op)
        {
        case IL_iif: {
                // we use this compound to assure next always points to the next expression,
                // not to the inner of the compound
                // IIF next ...
                //  e  IF next THEN next ELSE
                //     e       e         e
                pc++;
                Expression* if_ = new Expression();
                if_->kind = IL_if;
                if_->pos = tmp->pos;
                if_->e = translateExpr(ops, pc);
                tmp->e = if_;
                if( !expect(ops, pc, IL_then) )
                    return res;
                pc++;
                Expression* then_ = new Expression();
                then_->kind = IL_then;
                then_->pos = curPos;
                then_->e = translateExpr(ops, pc);
                if_->next = then_;
                if( !expect(ops, pc, IL_else) )
                    return res;
                pc++;
                Expression* else_ = new Expression();
                else_->kind = IL_else;
                else_->e = translateExpr(ops, pc);
                else_->pos = curPos;
                then_->next = else_;

                if( !expect(ops, pc, IL_end) )
                    return res;
            }
            break;
        case IL_callmi: {
                if( ops[pc].arg.canConvert<Quali>() ) {
                    Quali q = ops[pc].arg.value<Quali>();
                    tmp->d = resolve(q);
                    if(tmp->d == 0)
                        error(curProc,QString("cannot resolve qualident: %1").arg(format(q).constData()),pc++);
                } else {
                    Trident td = ops[pc].arg.value<Trident>();
                    tmp->d = derefTrident(td);
                    if(tmp->d == 0)
                        error(curProc,QString("cannot resolve trident: %1.%2").arg(format(td.first).constData()).
                              arg(td.second.constData()), pc++);
                }
                if(tmp->d == 0)
                    return res;
            }
          break;
        case IL_call:
        case IL_calli:
        case IL_castptr:
        case IL_initobj:
        case IL_isinst:
        case IL_ldelema:
        case IL_ldelem:
        case IL_ldind:
        case IL_ldiface:
        case IL_ldproc:
        case IL_ldvar:
        case IL_ldvara:
        case IL_newobj:
        case IL_newvla:
        case IL_newarr:
        case IL_ptroff:
        case IL_sizeof: {
                Quali q = ops[pc].arg.value<Quali>();
                tmp->d = resolve(q);
                if(tmp->d == 0)
                {
                    //tmp->d = resolve(q); // TEST
                    error(curProc,QString("cannot resolve qualident: %1").arg(format(q).constData()),pc++);
                    return res;
                }
            } break;
        case IL_callvirt:
        case IL_callinst:
        case IL_ldfld:
        case IL_ldflda:
        case IL_ldmeth: {
                Trident td = ops[pc].arg.value<Trident>();
                tmp->d = derefTrident(td);
                if(tmp->d == 0 )
                {
                    // tmp->d = derefTrident(td);
                    error(curProc,QString("cannot resolve trident: %1.%2").arg(format(td.first).constData()).
                          arg(td.second.constData()), pc++);
                    //return res;
                }
            } break;
        case IL_ldarg_s:
        case IL_ldarg:
        case IL_ldarga_s:
        case IL_ldarga:
        case IL_ldloc_s:
        case IL_ldloca_s:
        case IL_ldloca:
        case IL_ldloc:
            tmp->id = ops[pc].arg.toUInt();
            break;
        case IL_ldc_obj: {
            ConstrLiteral cl = ops[pc].arg.value<ConstrLiteral>();
            tmp->c = ConstrLiteral::toConst(cl.data);
            if( tmp->c && tmp->c->kind == Constant::C )
            {
                Declaration* d = resolve(cl.typeRef);
                Q_ASSERT(d);
                tmp->c->c->type = d->getType();
            }
            } break;
        case IL_ldstr: {
            Constant* c = new Constant();
            c->kind = Constant::S;
            const QByteArray str = ops[pc].arg.toByteArray();
            c->s = (char*)malloc( str.size() + 1);
            strcpy(c->s, str.constData());
            tmp->c = c;
            }
            break;
        case IL_ldc_i4:
        case IL_ldc_i8:
        case IL_ldc_i4_s:
            tmp->i = ops[pc].arg.toLongLong();
            break;
        case IL_ldc_r4:
        case IL_ldc_r8:
            tmp->f = ops[pc].arg.toDouble();
            break;
        case IL_ldarg_1:
            tmp->id = 1;
            break;
        case IL_ldarg_2:
            tmp->id = 2;
            break;
        case IL_ldarg_3:
            tmp->id = 3;
            break;
        case IL_ldc_i4_1:
            tmp->i = 1;
            break;
        case IL_ldloc_1:
            tmp->id = 1;
            break;
        case IL_ldloc_2:
            tmp->id = 2;
            break;
        case IL_ldloc_3:
            tmp->id = 3;
            break;
        case IL_ldc_i4_2:
            tmp->i = 2;
            break;
        case IL_ldc_i4_3:
            tmp->i = 3;
            break;
        case IL_ldc_i4_4:
            tmp->i = 4;
            break;
        case IL_ldc_i4_5:
            tmp->i = 5;
            break;
        case IL_ldc_i4_6:
            tmp->i = 6;
            break;
        case IL_ldc_i4_7:
            tmp->i = 7;
            break;
        case IL_ldc_i4_8:
            tmp->i = 8;
            break;
        case IL_ldc_i4_m1:
            tmp->i = -1;
            break;
        }

        pc++;
    }
    return res;
}

bool IlAstRenderer::expect(const QList<ProcData::Op>& ops, quint32& pc, int op)
{
    // pc is not changed in here!
    if( pc >= ops.size() || ops[pc].op != op )
    {
        error(curProc, QString("expecting '%1', instead got '%2'").arg(s_opName[op]).arg(s_opName[ops[pc].op]), pc);
        return false;
    }else
        return true;
}

Declaration*IlAstRenderer::derefTrident(const Trident& td) const
{
    Declaration* d = resolve(td.first);
    if( d == 0 || d->kind != Declaration::TypeDecl || d->getType() == 0)
        return 0;
    d = d->getType()->findSubByName(td.second);
    return d;
}

Declaration*IlAstRenderer::resolve(const Quali &q) const
{
    if( q.first.isEmpty() || q.first.constData() == module->name.constData() )
    {
        Declaration* res = module->findSubByName(q.second);
        if( res == 0 )
            res = mdl->getGlobals()->findSubByName(q.second);
        return res;
    }else
        return mdl->resolve(q);
}

void IlAstRenderer::error(Declaration* d, const QString& msg, int pc)
{
    Error e;
    e.msg = msg;
    e.where = d->toPath();
    if( curProc)
        e.pc = pc;
    errors << e;
}

void IlAstRenderer::error(Type *t, const QString & msg, int pc)
{
    if( t->decl )
        error(t->decl, msg, pc);
    else
    {
        Error e;
        e.msg = msg;
        e.where = module->name;
        if( curProc)
            e.pc = pc;
        errors << e;
    }
}

void IlAstRenderer::resolveAll(bool reportError)
{
    foreach( Type* t, unresolved)
    {
        Q_ASSERT(t && t->quali);
        if( t->getType() == 0 )
        {
            Declaration* d = resolve(*t->quali);
            if( reportError )
            {
                if( d == 0 )
                    error(t, "the reference cannot be resolved");
                else if( d->kind != Declaration::TypeDecl )
                    error(t, "the reference is no type declaration");
            }
            if( d && d->kind == Declaration::TypeDecl )
                t->setType(d->getType());
        }
    }
}

void IlAstRenderer::dump(const char *title)
{
    // print not yet validated MIL to stdout
    QFile out;
    out.open(stdout, QIODevice::WriteOnly);
    out.write("// ");
    out.write(title);
    out.write("\n\n");
    IlAsmRenderer r(&out, false);
    AstSerializer::render(&r,module, Mil::AstSerializer::None);
}

QVariant ConstrLiteral::toVariant(Constant* c, Type* t)
{
    if( t )
    {
        Q_ASSERT(c->kind == Constant::B || c->kind == Constant::C );
        ConstrLiteral l;
        l.typeRef = t->toQuali();
        l.data = toVariant(c, 0);
        return QVariant::fromValue(l);
    }
    switch(c->kind)
    {
    case Constant::D:
        return c->d;
    case Constant::I:
        return c->i;
    case Constant::S:
        return QByteArray(c->s);
    case Constant::B:
        return QByteArray((char*)c->b->b, c->b->len);
    case Constant::R:
        return ConstrLiteral::toVariant(c->r->c, c->r->getType());
    case Constant::C: {
            ComponentList* cl = c->c;
            if( !cl->c.isEmpty() && !cl->c.first().name.isEmpty() )
            {
                // named
                RecordLiteral r;
                for( int i = 0; i < cl->c.size(); i++ )
                    r.append(FieldData(cl->c[i].name, toVariant(cl->c[i].c, 0 )));
                return QVariant::fromValue(r);
            }else
            {
                // anonymous
                QVariantList l;
                for( int i = 0; i < cl->c.size(); i++ )
                    l.append(toVariant(cl->c[i].c, 0 ));
                return l;
            }
        } break;
    default:
        Q_ASSERT(false);
    }
    return QVariant();
}

Constant * ConstrLiteral::toConst(const QVariant & data)
{
    // sync with renderComponents
    if( data.canConvert<ConstrLiteral>() )
    {
        Q_ASSERT(false);
        // the caller is responsible for this
        return 0;
    }
    Constant* c = new Constant();
    if( data.canConvert<RecordLiteral>() )
    {
        RecordLiteral m = data.value<RecordLiteral>();
        c->c = new ComponentList();
        c->kind = Constant::C;
        for( int i = 0; i < m.size(); i++ )
        {
            c->c->c.append(Component());
            c->c->c.back().name = m[i].first;
            c->c->c.back().c = toConst(m[i].second);
        }
        return c;
    }
    switch( data.type() )
    {
    case QVariant::List:
        c->kind = Constant::C;
        c->c = new ComponentList();
        foreach( const QVariant& v, data.toList() )
        {
            c->c->c.append(Component());
            c->c->c.back().c = toConst(v);
        }
        break;
    case QVariant::ByteArray:
        {
            const QByteArray ba = data.toByteArray();
            c->kind = Constant::B;
            c->b = new ByteString();
            c->b->len = ba.size();
            c->b->b = (quint8*)malloc(ba.size());
            memcpy(c->b->b, ba.data(), ba.size());
        } break;
    case QVariant::String:
        {
            const QString str = data.toString();
            const QByteArray latin1 = str.toLatin1();
            c->kind = Constant::S;
            c->s = (char*)malloc(latin1.size() + 1);
            memcpy(c->s, latin1.data(), latin1.size() + 1);
        }
        break;
    case QVariant::LongLong:
    case QVariant::Int:
    case QVariant::Bool:
    case QVariant::ULongLong:
    case QVariant::UInt:
        c->kind = Constant::I;
        c->i = data.toLongLong();
        break;
    case QVariant::Double:
        c->kind = Constant::D;
        c->d = data.toDouble();
        break;
    default:
        Q_ASSERT(false);
    }
    return c;
}
