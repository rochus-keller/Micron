// This file was automatically generated by EbnfStudio; don't modify it!
#include "MilParser.h"
using namespace Mil;

static inline bool FIRST_Mil(int tt) {
	return tt == Tok_MODULE;
}

static inline bool FIRST_integer(int tt) {
	return tt == Tok_Plus || tt == Tok_unsigned || tt == Tok_Minus;
}

static inline bool FIRST_number(int tt) {
	return tt == Tok_Plus || tt == Tok_Minus || tt == Tok_unsigned || tt == Tok_float;
}

static inline bool FIRST_qualident(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_trident(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_identdef(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_Line(int tt) {
	return tt == Tok_LINE;
}

static inline bool FIRST_ConstDeclaration(int tt) {
	return tt == Tok_ident || tt == Tok_LINE;
}

static inline bool FIRST_TypeDeclaration(int tt) {
	return tt == Tok_ident || tt == Tok_LINE;
}

static inline bool FIRST_type(int tt) {
	switch(tt){
	case Tok_UNION:
	case Tok_POINTER:
	case Tok_STRUCT:
	case Tok_ident:
	case Tok_Lbrack:
	case Tok_PROCEDURE:
	case Tok_PROC:
	case Tok_Hat:
	case Tok_ARRAY:
	case Tok_OBJECT:
		return true;
	default: return false;
	}
}

static inline bool FIRST_NamedType(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_ArrayType(int tt) {
	return tt == Tok_Lbrack || tt == Tok_ARRAY;
}

static inline bool FIRST_length(int tt) {
	return tt == Tok_unsigned;
}

static inline bool FIRST_StructUnionType(int tt) {
	return tt == Tok_UNION || tt == Tok_STRUCT;
}

static inline bool FIRST_FieldList(int tt) {
	return tt == Tok_ident || tt == Tok_2Dot || tt == Tok_LINE;
}

static inline bool FIRST_IdentList(int tt) {
	return tt == Tok_ident || tt == Tok_LINE;
}

static inline bool FIRST_ObjectType(int tt) {
	return tt == Tok_OBJECT;
}

static inline bool FIRST_MemberList(int tt) {
	return tt == Tok_ident || tt == Tok_LINE;
}

static inline bool FIRST_PointerType(int tt) {
	return tt == Tok_POINTER || tt == Tok_Hat;
}

static inline bool FIRST_ProcedureType(int tt) {
	return tt == Tok_PROCEDURE || tt == Tok_PROC;
}

static inline bool FIRST_VariableDeclaration(int tt) {
	return tt == Tok_ident || tt == Tok_LINE;
}

static inline bool FIRST_ProcedureDeclaration(int tt) {
	return tt == Tok_PROCEDURE || tt == Tok_PROC;
}

static inline bool FIRST_Binding(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_ProcedureBody(int tt) {
	return tt == Tok_VAR || tt == Tok_BEGIN;
}

static inline bool FIRST_LocalDeclaration(int tt) {
	return tt == Tok_ident || tt == Tok_LINE;
}

static inline bool FIRST_FormalParameters(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_ReturnType(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_FPSection(int tt) {
	return tt == Tok_ident || tt == Tok_LINE;
}

static inline bool FIRST_module(int tt) {
	return tt == Tok_MODULE;
}

static inline bool FIRST_ImportList(int tt) {
	return tt == Tok_IMPORT;
}

static inline bool FIRST_import(int tt) {
	return tt == Tok_ident || tt == Tok_LINE;
}

static inline bool FIRST_instantiation(int tt) {
	return tt == Tok_ColonEq;
}

static inline bool FIRST_DeclarationSequence(int tt) {
	return tt == Tok_VAR || tt == Tok_CONST || tt == Tok_PROCEDURE || tt == Tok_TYPE || tt == Tok_PROC;
}

static inline bool FIRST_Expression(int tt) {
	switch(tt){
	case Tok_LDSTR:
	case Tok_CONV_U4:
	case Tok_CASTPTR:
	case Tok_LDC_I4_1:
	case Tok_LDELEM_R4:
	case Tok_LDLOCA_S:
	case Tok_LDLOC_0:
	case Tok_CONV_R4:
	case Tok_DIV_UN:
	case Tok_CONV_U8:
	case Tok_CGT_UN:
	case Tok_LDIND_U2:
	case Tok_INITOBJ:
	case Tok_CGT:
	case Tok_IIF:
	case Tok_CALLVIRT:
	case Tok_LDELEM_I1:
	case Tok_REM:
	case Tok_LDLOCA:
	case Tok_NOT:
	case Tok_LDELEM:
	case Tok_ISINST:
	case Tok_CONV_I4:
	case Tok_CALL:
	case Tok_LDC_I4_0:
	case Tok_LDC_I4_7:
	case Tok_MUL:
	case Tok_LDARG_S:
	case Tok_CONV_I8:
	case Tok_LDARG_3:
	case Tok_NEG:
	case Tok_LDELEM_R8:
	case Tok_LDC_R4:
	case Tok_CLT_UN:
	case Tok_LDC_I4_8:
	case Tok_LDVAR:
	case Tok_LINE:
	case Tok_REM_UN:
	case Tok_LDARG_0:
	case Tok_LDARGA_S:
	case Tok_LDIND:
	case Tok_LDC_I4_M1:
	case Tok_LDELEM_I8:
	case Tok_NEWOBJ:
	case Tok_SHR:
	case Tok_SUB:
	case Tok_NEWVLA:
	case Tok_LDC_R8:
	case Tok_SHR_UN:
	case Tok_LDELEM_I4:
	case Tok_LDIND_U1:
	case Tok_LDELEM_U4:
	case Tok_OR:
	case Tok_LDC_I4_S:
	case Tok_LDNULL:
	case Tok_NOP:
	case Tok_CALLVI:
	case Tok_LDELEM_I2:
	case Tok_LDELEM_IPP:
	case Tok_LDIND_I2:
	case Tok_LDELEM_U2:
	case Tok_CONV_U1:
	case Tok_LDLOC_3:
	case Tok_LDIND_R8:
	case Tok_LDIND_I8:
	case Tok_DIV:
	case Tok_LDC_OBJ:
	case Tok_LDELEMA:
	case Tok_CONV_U2:
	case Tok_LDMETH:
	case Tok_ABS:
	case Tok_LDARG_1:
	case Tok_ADD:
	case Tok_LDFLDA:
	case Tok_LDLOC_2:
	case Tok_LDIND_IP:
	case Tok_LDARG_2:
	case Tok_LDC_IP:
	case Tok_LDIND_R4:
	case Tok_LDC_I4_6:
	case Tok_XOR:
	case Tok_CONV_I1:
	case Tok_LDC_I4_2:
	case Tok_LDIND_I1:
	case Tok_LDC_I4:
	case Tok_CLT:
	case Tok_LDC_I4_3:
	case Tok_AND:
	case Tok_CONV_R8:
	case Tok_LDC_I8:
	case Tok_SIZEOF:
	case Tok_CEQ:
	case Tok_NEWARR:
	case Tok_LDLOC_1:
	case Tok_LDIND_IPP:
	case Tok_LDC_I4_4:
	case Tok_LDELEM_U1:
	case Tok_LDELEM_IP:
	case Tok_LDIND_I4:
	case Tok_LDIND_U8:
	case Tok_LDVARA:
	case Tok_DUP:
	case Tok_LDARGA:
	case Tok_LDLOC_S:
	case Tok_LDARG:
	case Tok_SHL:
	case Tok_LDC_I4_5:
	case Tok_LDFLD:
	case Tok_LDELEM_U8:
	case Tok_CALLI:
	case Tok_CONV_I2:
	case Tok_LDLOC:
	case Tok_LDPROC:
	case Tok_PTROFF:
	case Tok_LDIND_U4:
		return true;
	default: return false;
	}
}

static inline bool FIRST_ExpInstr(int tt) {
	switch(tt){
	case Tok_LDSTR:
	case Tok_CONV_U4:
	case Tok_CASTPTR:
	case Tok_LDC_I4_1:
	case Tok_LDELEM_R4:
	case Tok_LDLOCA_S:
	case Tok_LDLOC_0:
	case Tok_CONV_R4:
	case Tok_DIV_UN:
	case Tok_CONV_U8:
	case Tok_CGT_UN:
	case Tok_LDIND_U2:
	case Tok_INITOBJ:
	case Tok_CGT:
	case Tok_IIF:
	case Tok_CALLVIRT:
	case Tok_LDELEM_I1:
	case Tok_REM:
	case Tok_LDLOCA:
	case Tok_NOT:
	case Tok_LDELEM:
	case Tok_ISINST:
	case Tok_CONV_I4:
	case Tok_CALL:
	case Tok_LDC_I4_0:
	case Tok_LDC_I4_7:
	case Tok_MUL:
	case Tok_LDARG_S:
	case Tok_CONV_I8:
	case Tok_LDARG_3:
	case Tok_NEG:
	case Tok_LDELEM_R8:
	case Tok_LDC_R4:
	case Tok_CLT_UN:
	case Tok_LDC_I4_8:
	case Tok_LDVAR:
	case Tok_REM_UN:
	case Tok_LDARG_0:
	case Tok_LDARGA_S:
	case Tok_LDIND:
	case Tok_LDC_I4_M1:
	case Tok_LDELEM_I8:
	case Tok_NEWOBJ:
	case Tok_SHR:
	case Tok_SUB:
	case Tok_NEWVLA:
	case Tok_LDC_R8:
	case Tok_SHR_UN:
	case Tok_LDELEM_I4:
	case Tok_LDIND_U1:
	case Tok_LDELEM_U4:
	case Tok_OR:
	case Tok_LDC_I4_S:
	case Tok_LDNULL:
	case Tok_NOP:
	case Tok_CALLVI:
	case Tok_LDELEM_I2:
	case Tok_LDELEM_IPP:
	case Tok_LDIND_I2:
	case Tok_LDELEM_U2:
	case Tok_CONV_U1:
	case Tok_LDLOC_3:
	case Tok_LDIND_R8:
	case Tok_LDIND_I8:
	case Tok_DIV:
	case Tok_LDC_OBJ:
	case Tok_LDELEMA:
	case Tok_CONV_U2:
	case Tok_LDMETH:
	case Tok_ABS:
	case Tok_LDARG_1:
	case Tok_ADD:
	case Tok_LDFLDA:
	case Tok_LDLOC_2:
	case Tok_LDIND_IP:
	case Tok_LDARG_2:
	case Tok_LDC_IP:
	case Tok_LDIND_R4:
	case Tok_LDC_I4_6:
	case Tok_XOR:
	case Tok_CONV_I1:
	case Tok_LDC_I4_2:
	case Tok_LDIND_I1:
	case Tok_LDC_I4:
	case Tok_CLT:
	case Tok_LDC_I4_3:
	case Tok_AND:
	case Tok_CONV_R8:
	case Tok_LDC_I8:
	case Tok_SIZEOF:
	case Tok_CEQ:
	case Tok_NEWARR:
	case Tok_LDLOC_1:
	case Tok_LDIND_IPP:
	case Tok_LDC_I4_4:
	case Tok_LDELEM_U1:
	case Tok_LDELEM_IP:
	case Tok_LDIND_I4:
	case Tok_LDIND_U8:
	case Tok_LDVARA:
	case Tok_DUP:
	case Tok_LDARGA:
	case Tok_LDLOC_S:
	case Tok_LDARG:
	case Tok_SHL:
	case Tok_LDC_I4_5:
	case Tok_LDFLD:
	case Tok_LDELEM_U8:
	case Tok_CALLI:
	case Tok_CONV_I2:
	case Tok_LDLOC:
	case Tok_LDPROC:
	case Tok_PTROFF:
	case Tok_LDIND_U4:
		return true;
	default: return false;
	}
}

static inline bool FIRST_CondOp(int tt) {
	return tt == Tok_IIF;
}

static inline bool FIRST_StatementSequence(int tt) {
	switch(tt){
	case Tok_LDFLDA:
	case Tok_LDIND_I8:
	case Tok_PTROFF:
	case Tok_LDIND_I4:
	case Tok_STIND_I4:
	case Tok_STELEM_I8:
	case Tok_STVAR:
	case Tok_LDELEM_R8:
	case Tok_LDLOCA_S:
	case Tok_STARG:
	case Tok_CONV_I2:
	case Tok_LDMETH:
	case Tok_CASTPTR:
	case Tok_LDC_R4:
	case Tok_LDC_I4_0:
	case Tok_LDLOCA:
	case Tok_SIZEOF:
	case Tok_LDNULL:
	case Tok_NOP:
	case Tok_LDIND_I2:
	case Tok_CALLVIRT:
	case Tok_FREE:
	case Tok_CALL:
	case Tok_DIV_UN:
	case Tok_STLOC:
	case Tok_LDELEM_U4:
	case Tok_LDLOC_S:
	case Tok_NEWOBJ:
	case Tok_LDC_I4_6:
	case Tok_STELEM:
	case Tok_NEWARR:
	case Tok_SUB:
	case Tok_ISINST:
	case Tok_CONV_R8:
	case Tok_LDELEM_I8:
	case Tok_LDC_I4_2:
	case Tok_LDC_I4_3:
	case Tok_LDELEM_I1:
	case Tok_NEG:
	case Tok_STLOC_2:
	case Tok_XOR:
	case Tok_STIND_R4:
	case Tok_SWITCH:
	case Tok_LDC_I4_S:
	case Tok_REPEAT:
	case Tok_LDC_I4_5:
	case Tok_LDSTR:
	case Tok_DIV:
	case Tok_LDIND_R4:
	case Tok_IF:
	case Tok_LDLOC_3:
	case Tok_STELEM_R8:
	case Tok_REM_UN:
	case Tok_CONV_I1:
	case Tok_LDELEM_IP:
	case Tok_LOOP:
	case Tok_LDARG_S:
	case Tok_STLOC_3:
	case Tok_NOT:
	case Tok_MUL:
	case Tok_LDIND_IP:
	case Tok_LDELEM_I2:
	case Tok_LDLOC:
	case Tok_LDIND_U1:
	case Tok_LDLOC_1:
	case Tok_STFLD:
	case Tok_STLOC_0:
	case Tok_AND:
	case Tok_LDARGA:
	case Tok_CONV_I4:
	case Tok_CONV_I8:
	case Tok_OR:
	case Tok_LDARG_2:
	case Tok_SHL:
	case Tok_LDELEMA:
	case Tok_ABS:
	case Tok_STIND_I2:
	case Tok_LDELEM_R4:
	case Tok_STIND_IPP:
	case Tok_IIF:
	case Tok_LDC_I4_8:
	case Tok_LDC_I4_M1:
	case Tok_CALLI:
	case Tok_LDFLD:
	case Tok_LDIND:
	case Tok_STRCPY:
	case Tok_CONV_U4:
	case Tok_CONV_U8:
	case Tok_STIND_I1:
	case Tok_LDLOC_0:
	case Tok_STIND_R8:
	case Tok_REM:
	case Tok_LDIND_U4:
	case Tok_LDC_OBJ:
	case Tok_STIND:
	case Tok_RET:
	case Tok_CGT:
	case Tok_LDARGA_S:
	case Tok_LDARG:
	case Tok_LDVARA:
	case Tok_LDARG_0:
	case Tok_LDELEM_IPP:
	case Tok_STLOC_S:
	case Tok_LDC_R8:
	case Tok_STLOC_1:
	case Tok_EXIT:
	case Tok_STELEM_I2:
	case Tok_INITOBJ:
	case Tok_LABEL:
	case Tok_CALLVI:
	case Tok_LDLOC_2:
	case Tok_LDARG_3:
	case Tok_STELEM_I4:
	case Tok_CGT_UN:
	case Tok_CLT:
	case Tok_LDIND_U2:
	case Tok_LDELEM_I4:
	case Tok_CONV_U1:
	case Tok_WHILE:
	case Tok_CLT_UN:
	case Tok_LDC_I4_4:
	case Tok_LDIND_I1:
	case Tok_CEQ:
	case Tok_CONV_U2:
	case Tok_LINE:
	case Tok_SHR:
	case Tok_LDC_I4:
	case Tok_LDIND_R8:
	case Tok_SHR_UN:
	case Tok_LDPROC:
	case Tok_LDC_I4_1:
	case Tok_ADD:
	case Tok_LDIND_U8:
	case Tok_STARG_S:
	case Tok_STELEM_R4:
	case Tok_STELEM_I1:
	case Tok_STELEM_IP:
	case Tok_STIND_IP:
	case Tok_LDC_IP:
	case Tok_STELEM_IPP:
	case Tok_LDELEM:
	case Tok_GOTO:
	case Tok_LDC_I8:
	case Tok_CONV_R4:
	case Tok_NEWVLA:
	case Tok_LDELEM_U8:
	case Tok_POP:
	case Tok_DUP:
	case Tok_STIND_I8:
	case Tok_LDELEM_U2:
	case Tok_LDC_I4_7:
	case Tok_LDVAR:
	case Tok_LDARG_1:
	case Tok_LDELEM_U1:
	case Tok_LDIND_IPP:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Statement(int tt) {
	switch(tt){
	case Tok_STIND_I2:
	case Tok_STELEM_IP:
	case Tok_FREE:
	case Tok_STIND:
	case Tok_STELEM_I2:
	case Tok_WHILE:
	case Tok_REPEAT:
	case Tok_STIND_I4:
	case Tok_STIND_I8:
	case Tok_EXIT:
	case Tok_STELEM_IPP:
	case Tok_STLOC_S:
	case Tok_STLOC:
	case Tok_STIND_IP:
	case Tok_STARG:
	case Tok_STRCPY:
	case Tok_STVAR:
	case Tok_STARG_S:
	case Tok_STIND_I1:
	case Tok_STIND_IPP:
	case Tok_STELEM_I4:
	case Tok_STFLD:
	case Tok_POP:
	case Tok_STELEM_I1:
	case Tok_LABEL:
	case Tok_STLOC_2:
	case Tok_STLOC_3:
	case Tok_IF:
	case Tok_STELEM_I8:
	case Tok_STIND_R4:
	case Tok_STLOC_0:
	case Tok_SWITCH:
	case Tok_STLOC_1:
	case Tok_LOOP:
	case Tok_STELEM_R4:
	case Tok_RET:
	case Tok_STELEM:
	case Tok_STELEM_R8:
	case Tok_GOTO:
	case Tok_STIND_R8:
		return true;
	default: return false;
	}
}

static inline bool FIRST_IfThenElse(int tt) {
	return tt == Tok_IF;
}

static inline bool FIRST_Loop(int tt) {
	return tt == Tok_LOOP;
}

static inline bool FIRST_Switch(int tt) {
	return tt == Tok_SWITCH;
}

static inline bool FIRST_RepeatUntil(int tt) {
	return tt == Tok_REPEAT;
}

static inline bool FIRST_WhileDo(int tt) {
	return tt == Tok_WHILE;
}

static inline bool FIRST_MetaActuals(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_MetaParams(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_ConstExpression(int tt) {
	switch(tt){
	case Tok_hexstring:
	case Tok_Plus:
	case Tok_ident:
	case Tok_string:
	case Tok_Minus:
	case Tok_unsigned:
	case Tok_float:
		return true;
	default: return false;
	}
}

static inline bool FIRST_ConstExpression2(int tt) {
	switch(tt){
	case Tok_hexstring:
	case Tok_Plus:
	case Tok_ident:
	case Tok_Minus:
	case Tok_string:
	case Tok_unsigned:
	case Tok_float:
		return true;
	default: return false;
	}
}

static inline bool FIRST_constructor(int tt) {
	return tt == Tok_hexstring || tt == Tok_ident;
}

static inline bool FIRST_component_list(int tt) {
	return tt == Tok_Lbrace;
}

static inline bool FIRST_component(int tt) {
	switch(tt){
	case Tok_hexstring:
	case Tok_Plus:
	case Tok_Lbrace:
	case Tok_ident:
	case Tok_string:
	case Tok_Minus:
	case Tok_unsigned:
	case Tok_float:
		return true;
	default: return false;
	}
}

void Parser::RunParser() {
	root = SynTree();
	errors.clear();
	next();
	Mil(&root);
}

void Parser::next() {
	cur = la;
	la = scanner->next();
	while( la.d_type == Tok_Invalid ) {
		errors << Error(la.d_val, la.d_lineNr, la.d_colNr, la.d_sourcePath);
		la = scanner->next();
	}
}

Token Parser::peek(int off) {
	if( off == 1 )
		return la;
	else if( off == 0 )
		return cur;
	else
		return scanner->peek(off-1);
}

void Parser::invalid(const char* what) {
	errors << Error(QString("invalid %1").arg(what),la.d_lineNr, la.d_colNr, la.d_sourcePath);
}

bool Parser::expect(int tt, bool pkw, const char* where) {
	if( la.d_type == tt || la.d_code == tt) { next(); return true; }
	else { errors << Error(QString("'%1' expected in %2").arg(tokenTypeString(tt)).arg(where),la.d_lineNr, la.d_colNr, la.d_sourcePath); return false; }
}

static inline void dummy() {}

	void Parser::addTerminal(SynTree* st) {
		if( cur.d_type != Tok_Semi && cur.d_type != Tok_Comma && cur.d_type != Tok_Dot && cur.d_type != Tok_Colon ){
			SynTree* tmp = new SynTree( cur ); st->d_children.append(tmp);
		}
	}
void Parser::Mil(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Mil, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_module(la.d_type) || FIRST_module(la.d_code) ) {
		module(st);
	}
}

void Parser::integer(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_integer, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Plus ) {
			if( expect(Tok_Plus, false, "integer") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "integer") ) addTerminal(st);
		} else
			invalid("integer");
	}
	if( expect(Tok_unsigned, false, "integer") ) addTerminal(st);
}

void Parser::number(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_number, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Plus ) {
			if( expect(Tok_Plus, false, "number") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "number") ) addTerminal(st);
		} else
			invalid("number");
	}
	if( la.d_type == Tok_float ) {
		if( expect(Tok_float, false, "number") ) addTerminal(st);
	} else if( la.d_type == Tok_unsigned ) {
		if( expect(Tok_unsigned, false, "number") ) addTerminal(st);
	} else
		invalid("number");
}

void Parser::qualident(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_qualident, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_Bang )  ) {
		if( expect(Tok_ident, false, "qualident") ) addTerminal(st);
		if( expect(Tok_Bang, false, "qualident") ) addTerminal(st);
	}
	if( expect(Tok_ident, false, "qualident") ) addTerminal(st);
}

void Parser::trident(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_trident, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_Bang )  ) {
		if( expect(Tok_ident, false, "trident") ) addTerminal(st);
		if( expect(Tok_Bang, false, "trident") ) addTerminal(st);
	}
	if( expect(Tok_ident, false, "trident") ) addTerminal(st);
	if( expect(Tok_Dot, false, "trident") ) addTerminal(st);
	if( expect(Tok_ident, false, "trident") ) addTerminal(st);
}

void Parser::identdef(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_identdef, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ident, false, "identdef") ) addTerminal(st);
	if( la.d_type == Tok_Star ) {
		if( expect(Tok_Star, false, "identdef") ) addTerminal(st);
	}
}

void Parser::Line(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Line, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_LINE, true, "Line") ) addTerminal(st);
	if( expect(Tok_unsigned, false, "Line") ) addTerminal(st);
}

void Parser::ConstDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ConstDeclaration, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	if( expect(Tok_ident, false, "ConstDeclaration") ) addTerminal(st);
	if( la.d_type == Tok_Eq ) {
		if( expect(Tok_Eq, false, "ConstDeclaration") ) addTerminal(st);
		ConstExpression2(st);
	} else if( la.d_type == Tok_Colon ) {
		if( expect(Tok_Colon, false, "ConstDeclaration") ) addTerminal(st);
		qualident(st);
	} else
		invalid("ConstDeclaration");
}

void Parser::TypeDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_TypeDeclaration, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	identdef(st);
	if( la.d_type == Tok_Eq ) {
		if( expect(Tok_Eq, false, "TypeDeclaration") ) addTerminal(st);
		type(st);
	}
}

void Parser::type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_ArrayType(la.d_type) || FIRST_ArrayType(la.d_code) ) {
		ArrayType(st);
	} else if( FIRST_StructUnionType(la.d_type) || FIRST_StructUnionType(la.d_code) ) {
		StructUnionType(st);
	} else if( FIRST_ObjectType(la.d_type) || FIRST_ObjectType(la.d_code) ) {
		ObjectType(st);
	} else if( FIRST_PointerType(la.d_type) || FIRST_PointerType(la.d_code) ) {
		PointerType(st);
	} else if( FIRST_ProcedureType(la.d_type) || FIRST_ProcedureType(la.d_code) ) {
		ProcedureType(st);
	} else if( FIRST_NamedType(la.d_type) ) {
		NamedType(st);
	} else
		invalid("type");
}

void Parser::NamedType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_NamedType, la); st->d_children.append(tmp); st = tmp; }
	qualident(st);
}

void Parser::ArrayType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ArrayType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_ARRAY ) {
		if( expect(Tok_ARRAY, true, "ArrayType") ) addTerminal(st);
		if( FIRST_length(la.d_type) ) {
			length(st);
		}
		if( expect(Tok_OF, true, "ArrayType") ) addTerminal(st);
		NamedType(st);
	} else if( la.d_type == Tok_Lbrack ) {
		if( expect(Tok_Lbrack, false, "ArrayType") ) addTerminal(st);
		if( FIRST_length(la.d_type) ) {
			length(st);
		}
		if( expect(Tok_Rbrack, false, "ArrayType") ) addTerminal(st);
		NamedType(st);
	} else
		invalid("ArrayType");
}

void Parser::length(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_length, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_unsigned, false, "length") ) addTerminal(st);
}

void Parser::StructUnionType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_StructUnionType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_STRUCT ) {
		if( expect(Tok_STRUCT, true, "StructUnionType") ) addTerminal(st);
	} else if( la.d_code == Tok_UNION ) {
		if( expect(Tok_UNION, true, "StructUnionType") ) addTerminal(st);
	} else
		invalid("StructUnionType");
	while( ( !( peek(1).d_code == Tok_END ) )  ) {
		FieldList(st);
		if( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "StructUnionType") ) addTerminal(st);
		}
	}
	if( expect(Tok_END, true, "StructUnionType") ) addTerminal(st);
}

void Parser::FieldList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FieldList, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_IdentList(la.d_type) || FIRST_IdentList(la.d_code) ) {
		IdentList(st);
		if( expect(Tok_Colon, false, "FieldList") ) addTerminal(st);
		NamedType(st);
		if( la.d_type == Tok_Colon ) {
			if( expect(Tok_Colon, false, "FieldList") ) addTerminal(st);
			if( expect(Tok_unsigned, false, "FieldList") ) addTerminal(st);
		}
	} else if( la.d_type == Tok_2Dot ) {
		if( expect(Tok_2Dot, false, "FieldList") ) addTerminal(st);
		if( expect(Tok_unsigned, false, "FieldList") ) addTerminal(st);
	} else
		invalid("FieldList");
}

void Parser::IdentList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_IdentList, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	identdef(st);
	while( la.d_type == Tok_Comma || FIRST_Line(la.d_type) || FIRST_Line(la.d_code) || FIRST_identdef(la.d_type) ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "IdentList") ) addTerminal(st);
		}
		if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
			Line(st);
		}
		identdef(st);
	}
}

void Parser::ObjectType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ObjectType, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_OBJECT, true, "ObjectType") ) addTerminal(st);
	if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "ObjectType") ) addTerminal(st);
		NamedType(st);
		if( expect(Tok_Rpar, false, "ObjectType") ) addTerminal(st);
	}
	while( FIRST_MemberList(la.d_type) || FIRST_MemberList(la.d_code) ) {
		MemberList(st);
		if( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "ObjectType") ) addTerminal(st);
		}
	}
	if( expect(Tok_END, true, "ObjectType") ) addTerminal(st);
}

void Parser::MemberList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_MemberList, la); st->d_children.append(tmp); st = tmp; }
	IdentList(st);
	if( expect(Tok_Colon, false, "MemberList") ) addTerminal(st);
	NamedType(st);
}

void Parser::PointerType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_PointerType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_POINTER ) {
		if( expect(Tok_POINTER, true, "PointerType") ) addTerminal(st);
		if( expect(Tok_TO, true, "PointerType") ) addTerminal(st);
	} else if( la.d_type == Tok_Hat ) {
		if( expect(Tok_Hat, false, "PointerType") ) addTerminal(st);
	} else
		invalid("PointerType");
	NamedType(st);
}

void Parser::ProcedureType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_PROCEDURE ) {
		if( expect(Tok_PROCEDURE, true, "ProcedureType") ) addTerminal(st);
	} else if( la.d_code == Tok_PROC ) {
		if( expect(Tok_PROC, true, "ProcedureType") ) addTerminal(st);
	} else
		invalid("ProcedureType");
	if( la.d_type == Tok_Hat ) {
		if( expect(Tok_Hat, false, "ProcedureType") ) addTerminal(st);
	}
	if( FIRST_FormalParameters(la.d_type) ) {
		FormalParameters(st);
	}
}

void Parser::VariableDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_VariableDeclaration, la); st->d_children.append(tmp); st = tmp; }
	IdentList(st);
	if( expect(Tok_Colon, false, "VariableDeclaration") ) addTerminal(st);
	NamedType(st);
}

void Parser::ProcedureDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureDeclaration, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_PROCEDURE ) {
		if( expect(Tok_PROCEDURE, true, "ProcedureDeclaration") ) addTerminal(st);
	} else if( la.d_code == Tok_PROC ) {
		if( expect(Tok_PROC, true, "ProcedureDeclaration") ) addTerminal(st);
	} else
		invalid("ProcedureDeclaration");
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	if( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_Dot )  ) {
		Binding(st);
		identdef(st);
		if( FIRST_FormalParameters(la.d_type) ) {
			FormalParameters(st);
		}
		if( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "ProcedureDeclaration") ) addTerminal(st);
		}
		ProcedureBody(st);
	} else if( FIRST_identdef(la.d_type) ) {
		identdef(st);
		if( FIRST_FormalParameters(la.d_type) ) {
			FormalParameters(st);
		}
		if( la.d_code == Tok_INLINE || la.d_code == Tok_INVAR || la.d_code == Tok_INIT || la.d_type == Tok_Semi || FIRST_ProcedureBody(la.d_type) || FIRST_ProcedureBody(la.d_code) ) {
			if( la.d_code == Tok_INLINE || la.d_code == Tok_INVAR || la.d_code == Tok_INIT ) {
				if( la.d_code == Tok_INLINE ) {
					if( expect(Tok_INLINE, true, "ProcedureDeclaration") ) addTerminal(st);
				} else if( la.d_code == Tok_INVAR ) {
					if( expect(Tok_INVAR, true, "ProcedureDeclaration") ) addTerminal(st);
				} else if( la.d_code == Tok_INIT ) {
					if( expect(Tok_INIT, true, "ProcedureDeclaration") ) addTerminal(st);
				} else
					invalid("ProcedureDeclaration");
			}
			if( la.d_type == Tok_Semi ) {
				if( expect(Tok_Semi, false, "ProcedureDeclaration") ) addTerminal(st);
			}
			ProcedureBody(st);
		} else if( ( ( ( peek(1).d_code == Tok_EXTERN || peek(1).d_code == Tok_FOREIGN ) || peek(1).d_type == Tok_Semi && ( peek(2).d_code == Tok_EXTERN || peek(2).d_code == Tok_FOREIGN ) ) )  ) {
			if( la.d_type == Tok_Semi ) {
				if( expect(Tok_Semi, false, "ProcedureDeclaration") ) addTerminal(st);
			}
			if( la.d_code == Tok_EXTERN ) {
				if( expect(Tok_EXTERN, true, "ProcedureDeclaration") ) addTerminal(st);
			} else if( la.d_code == Tok_FOREIGN ) {
				if( expect(Tok_FOREIGN, true, "ProcedureDeclaration") ) addTerminal(st);
				if( la.d_type == Tok_string ) {
					if( expect(Tok_string, false, "ProcedureDeclaration") ) addTerminal(st);
				}
			} else
				invalid("ProcedureDeclaration");
		} else if( ( ( peek(1).d_code == Tok_FORWARD || peek(1).d_type == Tok_Semi && peek(2).d_code == Tok_FORWARD ) )  ) {
			if( la.d_type == Tok_Semi ) {
				if( expect(Tok_Semi, false, "ProcedureDeclaration") ) addTerminal(st);
			}
			if( expect(Tok_FORWARD, true, "ProcedureDeclaration") ) addTerminal(st);
		} else
			invalid("ProcedureDeclaration");
	} else
		invalid("ProcedureDeclaration");
}

void Parser::Binding(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Binding, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ident, false, "Binding") ) addTerminal(st);
	if( expect(Tok_Dot, false, "Binding") ) addTerminal(st);
}

void Parser::ProcedureBody(SynTree* st) {
	if( la.d_code == Tok_VAR ) {
		if( expect(Tok_VAR, true, "ProcedureBody") ) addTerminal(st);
		while( FIRST_LocalDeclaration(la.d_type) || FIRST_LocalDeclaration(la.d_code) ) {
			LocalDeclaration(st);
			if( la.d_type == Tok_Semi ) {
				if( expect(Tok_Semi, false, "ProcedureBody") ) addTerminal(st);
			}
		}
	}
	if( expect(Tok_BEGIN, true, "ProcedureBody") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_END, true, "ProcedureBody") ) addTerminal(st);
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	if( expect(Tok_ident, false, "ProcedureBody") ) addTerminal(st);
}

void Parser::LocalDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_LocalDeclaration, la); st->d_children.append(tmp); st = tmp; }
	IdentList(st);
	if( expect(Tok_Colon, false, "LocalDeclaration") ) addTerminal(st);
	NamedType(st);
}

void Parser::FormalParameters(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FormalParameters, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "FormalParameters") ) addTerminal(st);
	if( FIRST_FPSection(la.d_type) || FIRST_FPSection(la.d_code) ) {
		FPSection(st);
		while( ( peek(1).d_type == Tok_Semi && ( peek(2).d_code == Tok_LINE || peek(2).d_type == Tok_ident ) )  ) {
			if( expect(Tok_Semi, false, "FormalParameters") ) addTerminal(st);
			FPSection(st);
		}
	}
	if( expect(Tok_Rpar, false, "FormalParameters") ) addTerminal(st);
	if( la.d_type == Tok_Colon ) {
		if( expect(Tok_Colon, false, "FormalParameters") ) addTerminal(st);
		ReturnType(st);
	}
}

void Parser::ReturnType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ReturnType, la); st->d_children.append(tmp); st = tmp; }
	NamedType(st);
}

void Parser::FPSection(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FPSection, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	if( expect(Tok_ident, false, "FPSection") ) addTerminal(st);
	while( la.d_type == Tok_Comma || FIRST_Line(la.d_type) || FIRST_Line(la.d_code) || la.d_type == Tok_ident ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "FPSection") ) addTerminal(st);
		}
		if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
			Line(st);
		}
		if( expect(Tok_ident, false, "FPSection") ) addTerminal(st);
	}
	if( expect(Tok_Colon, false, "FPSection") ) addTerminal(st);
	NamedType(st);
}

void Parser::module(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_module, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_MODULE, true, "module") ) addTerminal(st);
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	if( expect(Tok_ident, false, "module") ) addTerminal(st);
	if( FIRST_MetaParams(la.d_type) ) {
		MetaParams(st);
	}
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "module") ) addTerminal(st);
	}
	if( la.d_code == Tok_SOURCE ) {
		if( expect(Tok_SOURCE, true, "module") ) addTerminal(st);
		if( expect(Tok_string, false, "module") ) addTerminal(st);
		if( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "module") ) addTerminal(st);
		}
	}
	while( FIRST_ImportList(la.d_type) || FIRST_ImportList(la.d_code) || FIRST_DeclarationSequence(la.d_type) || FIRST_DeclarationSequence(la.d_code) ) {
		if( FIRST_ImportList(la.d_type) || FIRST_ImportList(la.d_code) ) {
			ImportList(st);
		} else if( FIRST_DeclarationSequence(la.d_type) || FIRST_DeclarationSequence(la.d_code) || la.d_code == Tok_PROCEDURE || la.d_code == Tok_CONST || la.d_code == Tok_END || la.d_code == Tok_PROC || la.d_code == Tok_IMPORT || la.d_code == Tok_VAR || la.d_code == Tok_TYPE ) {
			DeclarationSequence(st);
		} else
			invalid("module");
	}
	if( expect(Tok_END, true, "module") ) addTerminal(st);
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	if( expect(Tok_ident, false, "module") ) addTerminal(st);
	if( la.d_type == Tok_Dot ) {
		if( expect(Tok_Dot, false, "module") ) addTerminal(st);
	}
}

void Parser::ImportList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ImportList, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IMPORT, true, "ImportList") ) addTerminal(st);
	import(st);
	while( la.d_type == Tok_Comma || FIRST_import(la.d_type) || FIRST_import(la.d_code) ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "ImportList") ) addTerminal(st);
		}
		import(st);
	}
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "ImportList") ) addTerminal(st);
	}
}

void Parser::import(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_import, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	if( expect(Tok_ident, false, "import") ) addTerminal(st);
	if( FIRST_instantiation(la.d_type) ) {
		instantiation(st);
	}
}

void Parser::instantiation(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_instantiation, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ColonEq, false, "instantiation") ) addTerminal(st);
	if( expect(Tok_ident, false, "instantiation") ) addTerminal(st);
	MetaActuals(st);
}

void Parser::DeclarationSequence(SynTree* st) {
	while( la.d_code == Tok_CONST || la.d_code == Tok_TYPE || la.d_code == Tok_VAR || FIRST_ProcedureDeclaration(la.d_type) || FIRST_ProcedureDeclaration(la.d_code) ) {
		if( la.d_code == Tok_CONST ) {
			if( expect(Tok_CONST, true, "DeclarationSequence") ) addTerminal(st);
			while( FIRST_ConstDeclaration(la.d_type) || FIRST_ConstDeclaration(la.d_code) ) {
				ConstDeclaration(st);
				if( la.d_type == Tok_Semi ) {
					if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
				}
			}
		} else if( la.d_code == Tok_TYPE ) {
			if( expect(Tok_TYPE, true, "DeclarationSequence") ) addTerminal(st);
			while( FIRST_TypeDeclaration(la.d_type) || FIRST_TypeDeclaration(la.d_code) ) {
				TypeDeclaration(st);
				if( la.d_type == Tok_Semi ) {
					if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
				}
			}
		} else if( la.d_code == Tok_VAR ) {
			if( expect(Tok_VAR, true, "DeclarationSequence") ) addTerminal(st);
			while( FIRST_VariableDeclaration(la.d_type) || FIRST_VariableDeclaration(la.d_code) ) {
				VariableDeclaration(st);
				if( la.d_type == Tok_Semi ) {
					if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
				}
			}
		} else if( FIRST_ProcedureDeclaration(la.d_type) || FIRST_ProcedureDeclaration(la.d_code) ) {
			ProcedureDeclaration(st);
			if( la.d_type == Tok_Semi ) {
				if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
			}
		} else
			invalid("DeclarationSequence");
	}
}

void Parser::Expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Expression, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_ExpInstr(la.d_type) || FIRST_ExpInstr(la.d_code) || FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		if( FIRST_ExpInstr(la.d_type) || FIRST_ExpInstr(la.d_code) ) {
			ExpInstr(st);
		} else if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
			Line(st);
		} else
			invalid("Expression");
	}
}

void Parser::ExpInstr(SynTree* st) {
	if( la.d_code == Tok_ADD ) {
		if( expect(Tok_ADD, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ABS ) {
		if( expect(Tok_ABS, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_AND ) {
		if( expect(Tok_AND, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CALL || la.d_code == Tok_CALLI || la.d_code == Tok_CALLVI ) {
		if( la.d_code == Tok_CALL ) {
			if( expect(Tok_CALL, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_CALLI ) {
			if( expect(Tok_CALLI, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_CALLVI ) {
			if( expect(Tok_CALLVI, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		qualident(st);
	} else if( la.d_code == Tok_CALLVIRT ) {
		if( expect(Tok_CALLVIRT, true, "ExpInstr") ) addTerminal(st);
		trident(st);
	} else if( la.d_code == Tok_CASTPTR ) {
		if( expect(Tok_CASTPTR, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_CEQ ) {
		if( expect(Tok_CEQ, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CGT ) {
		if( expect(Tok_CGT, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CGT_UN ) {
		if( expect(Tok_CGT_UN, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CLT ) {
		if( expect(Tok_CLT, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CLT_UN ) {
		if( expect(Tok_CLT_UN, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_I1 ) {
		if( expect(Tok_CONV_I1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_I2 ) {
		if( expect(Tok_CONV_I2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_I4 ) {
		if( expect(Tok_CONV_I4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_I8 ) {
		if( expect(Tok_CONV_I8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_R4 ) {
		if( expect(Tok_CONV_R4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_R8 ) {
		if( expect(Tok_CONV_R8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_U1 ) {
		if( expect(Tok_CONV_U1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_U2 ) {
		if( expect(Tok_CONV_U2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_U4 ) {
		if( expect(Tok_CONV_U4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_CONV_U8 ) {
		if( expect(Tok_CONV_U8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_DIV ) {
		if( expect(Tok_DIV, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_DIV_UN ) {
		if( expect(Tok_DIV_UN, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_DUP ) {
		if( expect(Tok_DUP, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_INITOBJ ) {
		if( expect(Tok_INITOBJ, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_ISINST ) {
		if( expect(Tok_ISINST, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_LDARG || la.d_code == Tok_LDARG_S ) {
		if( la.d_code == Tok_LDARG ) {
			if( expect(Tok_LDARG, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDARG_S ) {
			if( expect(Tok_LDARG_S, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "ExpInstr") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
	} else if( la.d_code == Tok_LDARG_0 ) {
		if( expect(Tok_LDARG_0, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDARG_1 ) {
		if( expect(Tok_LDARG_1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDARG_2 ) {
		if( expect(Tok_LDARG_2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDARG_3 ) {
		if( expect(Tok_LDARG_3, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDARGA || la.d_code == Tok_LDARGA_S ) {
		if( la.d_code == Tok_LDARGA ) {
			if( expect(Tok_LDARGA, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDARGA_S ) {
			if( expect(Tok_LDARGA_S, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "ExpInstr") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
	} else if( la.d_code == Tok_LDC_I4 || la.d_code == Tok_LDC_I8 || la.d_code == Tok_LDC_I4_S ) {
		if( la.d_code == Tok_LDC_I4 ) {
			if( expect(Tok_LDC_I4, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDC_I8 ) {
			if( expect(Tok_LDC_I8, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDC_I4_S ) {
			if( expect(Tok_LDC_I4_S, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		integer(st);
	} else if( la.d_code == Tok_LDC_R4 || la.d_code == Tok_LDC_R8 ) {
		if( la.d_code == Tok_LDC_R4 ) {
			if( expect(Tok_LDC_R4, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDC_R8 ) {
			if( expect(Tok_LDC_R8, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		number(st);
	} else if( la.d_code == Tok_LDC_IP ) {
		if( expect(Tok_LDC_IP, true, "ExpInstr") ) addTerminal(st);
		if( expect(Tok_unsigned, false, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_0 ) {
		if( expect(Tok_LDC_I4_0, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_1 ) {
		if( expect(Tok_LDC_I4_1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_2 ) {
		if( expect(Tok_LDC_I4_2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_3 ) {
		if( expect(Tok_LDC_I4_3, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_4 ) {
		if( expect(Tok_LDC_I4_4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_5 ) {
		if( expect(Tok_LDC_I4_5, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_6 ) {
		if( expect(Tok_LDC_I4_6, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_7 ) {
		if( expect(Tok_LDC_I4_7, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_8 ) {
		if( expect(Tok_LDC_I4_8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_I4_M1 ) {
		if( expect(Tok_LDC_I4_M1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDC_OBJ ) {
		if( expect(Tok_LDC_OBJ, true, "ExpInstr") ) addTerminal(st);
		constructor(st);
	} else if( la.d_code == Tok_LDELEM || la.d_code == Tok_LDELEMA ) {
		if( la.d_code == Tok_LDELEM ) {
			if( expect(Tok_LDELEM, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDELEMA ) {
			if( expect(Tok_LDELEMA, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		qualident(st);
	} else if( la.d_code == Tok_LDELEM_I1 ) {
		if( expect(Tok_LDELEM_I1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_I2 ) {
		if( expect(Tok_LDELEM_I2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_I4 ) {
		if( expect(Tok_LDELEM_I4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_I8 ) {
		if( expect(Tok_LDELEM_I8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_U1 ) {
		if( expect(Tok_LDELEM_U1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_U2 ) {
		if( expect(Tok_LDELEM_U2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_U4 ) {
		if( expect(Tok_LDELEM_U4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_U8 ) {
		if( expect(Tok_LDELEM_U8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_R4 ) {
		if( expect(Tok_LDELEM_R4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_R8 ) {
		if( expect(Tok_LDELEM_R8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_IP ) {
		if( expect(Tok_LDELEM_IP, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDELEM_IPP ) {
		if( expect(Tok_LDELEM_IPP, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDFLD || la.d_code == Tok_LDFLDA ) {
		if( la.d_code == Tok_LDFLD ) {
			if( expect(Tok_LDFLD, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDFLDA ) {
			if( expect(Tok_LDFLDA, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		trident(st);
	} else if( la.d_code == Tok_LDIND_I1 ) {
		if( expect(Tok_LDIND_I1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_I2 ) {
		if( expect(Tok_LDIND_I2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_I4 ) {
		if( expect(Tok_LDIND_I4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_I8 ) {
		if( expect(Tok_LDIND_I8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_U1 ) {
		if( expect(Tok_LDIND_U1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_U2 ) {
		if( expect(Tok_LDIND_U2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_U4 ) {
		if( expect(Tok_LDIND_U4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_R4 ) {
		if( expect(Tok_LDIND_R4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_U8 ) {
		if( expect(Tok_LDIND_U8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_R8 ) {
		if( expect(Tok_LDIND_R8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_IP ) {
		if( expect(Tok_LDIND_IP, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND_IPP ) {
		if( expect(Tok_LDIND_IPP, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDLOC || la.d_code == Tok_LDLOC_S || la.d_code == Tok_LDLOCA || la.d_code == Tok_LDLOCA_S ) {
		if( la.d_code == Tok_LDLOC ) {
			if( expect(Tok_LDLOC, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDLOC_S ) {
			if( expect(Tok_LDLOC_S, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDLOCA ) {
			if( expect(Tok_LDLOCA, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDLOCA_S ) {
			if( expect(Tok_LDLOCA_S, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "ExpInstr") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
	} else if( la.d_code == Tok_LDLOC_0 ) {
		if( expect(Tok_LDLOC_0, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDLOC_1 ) {
		if( expect(Tok_LDLOC_1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDLOC_2 ) {
		if( expect(Tok_LDLOC_2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDLOC_3 ) {
		if( expect(Tok_LDLOC_3, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDNULL ) {
		if( expect(Tok_LDNULL, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_LDIND ) {
		if( expect(Tok_LDIND, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_LDPROC ) {
		if( expect(Tok_LDPROC, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_LDMETH ) {
		if( expect(Tok_LDMETH, true, "ExpInstr") ) addTerminal(st);
		trident(st);
	} else if( la.d_code == Tok_LDSTR ) {
		if( expect(Tok_LDSTR, true, "ExpInstr") ) addTerminal(st);
		if( la.d_type == Tok_string ) {
			if( expect(Tok_string, false, "ExpInstr") ) addTerminal(st);
		} else if( la.d_type == Tok_hexstring ) {
			if( expect(Tok_hexstring, false, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
	} else if( la.d_code == Tok_LDVAR || la.d_code == Tok_LDVARA ) {
		if( la.d_code == Tok_LDVAR ) {
			if( expect(Tok_LDVAR, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_LDVARA ) {
			if( expect(Tok_LDVARA, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		qualident(st);
	} else if( la.d_code == Tok_MUL ) {
		if( expect(Tok_MUL, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_NEG ) {
		if( expect(Tok_NEG, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_NEWARR || la.d_code == Tok_NEWVLA || la.d_code == Tok_NEWOBJ ) {
		if( la.d_code == Tok_NEWARR ) {
			if( expect(Tok_NEWARR, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_NEWVLA ) {
			if( expect(Tok_NEWVLA, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_NEWOBJ ) {
			if( expect(Tok_NEWOBJ, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		qualident(st);
	} else if( la.d_code == Tok_NOT ) {
		if( expect(Tok_NOT, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_OR ) {
		if( expect(Tok_OR, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_REM ) {
		if( expect(Tok_REM, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_REM_UN ) {
		if( expect(Tok_REM_UN, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_SHL ) {
		if( expect(Tok_SHL, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_SHR ) {
		if( expect(Tok_SHR, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_SHR_UN ) {
		if( expect(Tok_SHR_UN, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_SIZEOF ) {
		if( expect(Tok_SIZEOF, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_SUB ) {
		if( expect(Tok_SUB, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_XOR ) {
		if( expect(Tok_XOR, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_PTROFF ) {
		if( expect(Tok_PTROFF, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_NOP ) {
		if( expect(Tok_NOP, true, "ExpInstr") ) addTerminal(st);
	} else if( FIRST_CondOp(la.d_type) || FIRST_CondOp(la.d_code) ) {
		CondOp(st);
	} else
		invalid("ExpInstr");
}

void Parser::CondOp(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_CondOp, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IIF, true, "CondOp") ) addTerminal(st);
	Expression(st);
	if( expect(Tok_THEN, true, "CondOp") ) addTerminal(st);
	Expression(st);
	if( expect(Tok_ELSE, true, "CondOp") ) addTerminal(st);
	Expression(st);
	if( expect(Tok_END, true, "CondOp") ) addTerminal(st);
}

void Parser::StatementSequence(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_StatementSequence, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_Statement(la.d_type) || FIRST_Statement(la.d_code) || FIRST_ExpInstr(la.d_type) || FIRST_ExpInstr(la.d_code) || FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		if( FIRST_Statement(la.d_type) || FIRST_Statement(la.d_code) ) {
			Statement(st);
		} else if( FIRST_ExpInstr(la.d_type) || FIRST_ExpInstr(la.d_code) ) {
			ExpInstr(st);
		} else if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
			Line(st);
		} else
			invalid("StatementSequence");
	}
}

void Parser::Statement(SynTree* st) {
	if( la.d_code == Tok_FREE ) {
		if( expect(Tok_FREE, true, "Statement") ) addTerminal(st);
	} else if( FIRST_RepeatUntil(la.d_type) || FIRST_RepeatUntil(la.d_code) ) {
		RepeatUntil(st);
	} else if( la.d_code == Tok_EXIT ) {
		if( expect(Tok_EXIT, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_GOTO ) {
		if( expect(Tok_GOTO, true, "Statement") ) addTerminal(st);
		if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
	} else if( FIRST_IfThenElse(la.d_type) || FIRST_IfThenElse(la.d_code) ) {
		IfThenElse(st);
	} else if( la.d_code == Tok_LABEL ) {
		if( expect(Tok_LABEL, true, "Statement") ) addTerminal(st);
		if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
	} else if( FIRST_Loop(la.d_type) || FIRST_Loop(la.d_code) ) {
		Loop(st);
	} else if( la.d_code == Tok_POP ) {
		if( expect(Tok_POP, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_RET ) {
		if( expect(Tok_RET, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STARG || la.d_code == Tok_STARG_S ) {
		if( la.d_code == Tok_STARG ) {
			if( expect(Tok_STARG, true, "Statement") ) addTerminal(st);
		} else if( la.d_code == Tok_STARG_S ) {
			if( expect(Tok_STARG_S, true, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "Statement") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
	} else if( la.d_code == Tok_STELEM ) {
		if( expect(Tok_STELEM, true, "Statement") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_STELEM_I1 ) {
		if( expect(Tok_STELEM_I1, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STELEM_I2 ) {
		if( expect(Tok_STELEM_I2, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STELEM_I4 ) {
		if( expect(Tok_STELEM_I4, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STELEM_I8 ) {
		if( expect(Tok_STELEM_I8, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STELEM_R4 ) {
		if( expect(Tok_STELEM_R4, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STELEM_R8 ) {
		if( expect(Tok_STELEM_R8, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STELEM_IP ) {
		if( expect(Tok_STELEM_IP, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STELEM_IPP ) {
		if( expect(Tok_STELEM_IPP, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STFLD ) {
		if( expect(Tok_STFLD, true, "Statement") ) addTerminal(st);
		trident(st);
	} else if( la.d_code == Tok_STIND_I1 ) {
		if( expect(Tok_STIND_I1, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STIND_I2 ) {
		if( expect(Tok_STIND_I2, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STIND_I4 ) {
		if( expect(Tok_STIND_I4, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STIND_I8 ) {
		if( expect(Tok_STIND_I8, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STIND_R4 ) {
		if( expect(Tok_STIND_R4, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STIND_R8 ) {
		if( expect(Tok_STIND_R8, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STIND_IP ) {
		if( expect(Tok_STIND_IP, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STIND_IPP ) {
		if( expect(Tok_STIND_IPP, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STLOC || la.d_code == Tok_STLOC_S ) {
		if( la.d_code == Tok_STLOC ) {
			if( expect(Tok_STLOC, true, "Statement") ) addTerminal(st);
		} else if( la.d_code == Tok_STLOC_S ) {
			if( expect(Tok_STLOC_S, true, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "Statement") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
	} else if( la.d_code == Tok_STLOC_0 ) {
		if( expect(Tok_STLOC_0, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STLOC_1 ) {
		if( expect(Tok_STLOC_1, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STLOC_2 ) {
		if( expect(Tok_STLOC_2, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STLOC_3 ) {
		if( expect(Tok_STLOC_3, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_STIND ) {
		if( expect(Tok_STIND, true, "Statement") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_STVAR ) {
		if( expect(Tok_STVAR, true, "Statement") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_STRCPY ) {
		if( expect(Tok_STRCPY, true, "Statement") ) addTerminal(st);
	} else if( FIRST_Switch(la.d_type) || FIRST_Switch(la.d_code) ) {
		Switch(st);
	} else if( FIRST_WhileDo(la.d_type) || FIRST_WhileDo(la.d_code) ) {
		WhileDo(st);
	} else
		invalid("Statement");
}

void Parser::IfThenElse(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_IfThenElse, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IF, true, "IfThenElse") ) addTerminal(st);
	Expression(st);
	if( expect(Tok_THEN, true, "IfThenElse") ) addTerminal(st);
	StatementSequence(st);
	if( la.d_code == Tok_ELSE ) {
		if( expect(Tok_ELSE, true, "IfThenElse") ) addTerminal(st);
		StatementSequence(st);
	}
	if( expect(Tok_END, true, "IfThenElse") ) addTerminal(st);
}

void Parser::Loop(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Loop, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_LOOP, true, "Loop") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_END, true, "Loop") ) addTerminal(st);
}

void Parser::Switch(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Switch, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_SWITCH, true, "Switch") ) addTerminal(st);
	Expression(st);
	while( la.d_code == Tok_CASE ) {
		if( expect(Tok_CASE, true, "Switch") ) addTerminal(st);
		integer(st);
		while( la.d_type == Tok_Comma || FIRST_integer(la.d_type) ) {
			if( la.d_type == Tok_Comma ) {
				if( expect(Tok_Comma, false, "Switch") ) addTerminal(st);
			}
			integer(st);
		}
		if( expect(Tok_THEN, true, "Switch") ) addTerminal(st);
		StatementSequence(st);
	}
	if( la.d_code == Tok_ELSE ) {
		if( expect(Tok_ELSE, true, "Switch") ) addTerminal(st);
		StatementSequence(st);
	}
	if( expect(Tok_END, true, "Switch") ) addTerminal(st);
}

void Parser::RepeatUntil(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_RepeatUntil, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_REPEAT, true, "RepeatUntil") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_UNTIL, true, "RepeatUntil") ) addTerminal(st);
	Expression(st);
	if( expect(Tok_END, true, "RepeatUntil") ) addTerminal(st);
}

void Parser::WhileDo(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_WhileDo, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_WHILE, true, "WhileDo") ) addTerminal(st);
	Expression(st);
	if( expect(Tok_DO, true, "WhileDo") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_END, true, "WhileDo") ) addTerminal(st);
}

void Parser::MetaActuals(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_MetaActuals, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "MetaActuals") ) addTerminal(st);
	ConstExpression(st);
	while( la.d_type == Tok_Comma || FIRST_ConstExpression(la.d_type) ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "MetaActuals") ) addTerminal(st);
		}
		ConstExpression(st);
	}
	if( expect(Tok_Rpar, false, "MetaActuals") ) addTerminal(st);
}

void Parser::MetaParams(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_MetaParams, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "MetaParams") ) addTerminal(st);
	if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
		Line(st);
	}
	if( expect(Tok_ident, false, "MetaParams") ) addTerminal(st);
	while( ( ( peek(1).d_type == Tok_Comma || peek(1).d_code == Tok_LINE || peek(1).d_type == Tok_ident ) && ( peek(2).d_code == Tok_LINE || peek(2).d_type == Tok_ident || peek(2).d_type == Tok_unsigned ) )  ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "MetaParams") ) addTerminal(st);
		}
		if( FIRST_Line(la.d_type) || FIRST_Line(la.d_code) ) {
			Line(st);
		}
		if( expect(Tok_ident, false, "MetaParams") ) addTerminal(st);
	}
	if( expect(Tok_Rpar, false, "MetaParams") ) addTerminal(st);
}

void Parser::ConstExpression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ConstExpression, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_qualident(la.d_type) ) {
		qualident(st);
	} else if( FIRST_number(la.d_type) ) {
		number(st);
	} else if( la.d_type == Tok_string ) {
		if( expect(Tok_string, false, "ConstExpression") ) addTerminal(st);
	} else if( la.d_type == Tok_hexstring ) {
		if( expect(Tok_hexstring, false, "ConstExpression") ) addTerminal(st);
	} else
		invalid("ConstExpression");
}

void Parser::ConstExpression2(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ConstExpression2, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_qualident(la.d_type) ) {
		qualident(st);
		if( FIRST_component_list(la.d_type) ) {
			component_list(st);
		}
	} else if( FIRST_number(la.d_type) ) {
		number(st);
	} else if( la.d_type == Tok_string ) {
		if( expect(Tok_string, false, "ConstExpression2") ) addTerminal(st);
	} else if( la.d_type == Tok_hexstring ) {
		if( expect(Tok_hexstring, false, "ConstExpression2") ) addTerminal(st);
	} else
		invalid("ConstExpression2");
}

void Parser::constructor(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_constructor, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_NamedType(la.d_type) ) {
		NamedType(st);
		component_list(st);
	} else if( la.d_type == Tok_hexstring ) {
		if( expect(Tok_hexstring, false, "constructor") ) addTerminal(st);
	} else
		invalid("constructor");
}

void Parser::component_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_component_list, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lbrace, false, "component_list") ) addTerminal(st);
	if( FIRST_component(la.d_type) ) {
		component(st);
		while( la.d_type == Tok_Comma || FIRST_component(la.d_type) ) {
			if( la.d_type == Tok_Comma ) {
				if( expect(Tok_Comma, false, "component_list") ) addTerminal(st);
			}
			component(st);
		}
	}
	if( expect(Tok_Rbrace, false, "component_list") ) addTerminal(st);
}

void Parser::component(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_component, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_Eq )  ) {
		if( expect(Tok_ident, false, "component") ) addTerminal(st);
		if( expect(Tok_Eq, false, "component") ) addTerminal(st);
	}
	if( FIRST_ConstExpression(la.d_type) ) {
		ConstExpression(st);
	} else if( FIRST_component_list(la.d_type) ) {
		component_list(st);
	} else
		invalid("component");
}

