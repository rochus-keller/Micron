// This file was automatically generated by EbnfStudio; don't modify it!
#include "MilParser.h"
using namespace Mil;

static inline bool FIRST_Mil(int tt) {
	return tt == Tok_MODULE;
}

static inline bool FIRST_integer(int tt) {
	return tt == Tok_Minus || tt == Tok_Plus || tt == Tok_unsigned;
}

static inline bool FIRST_qualident(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_identdef(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_TypeDeclaration(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_type(int tt) {
	switch(tt){
	case Tok_POINTER:
	case Tok_ARRAY:
	case Tok_STRUCT:
	case Tok_PROCEDURE:
	case Tok_PROC:
	case Tok_Lbrack:
	case Tok_ident:
	case Tok_UNION:
	case Tok_Hat:
		return true;
	default: return false;
	}
}

static inline bool FIRST_NamedType(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_ArrayType(int tt) {
	return tt == Tok_ARRAY || tt == Tok_Lbrack;
}

static inline bool FIRST_length(int tt) {
	return tt == Tok_unsigned;
}

static inline bool FIRST_StructUnionType(int tt) {
	return tt == Tok_STRUCT || tt == Tok_UNION;
}

static inline bool FIRST_FieldList(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_IdentList(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_PointerType(int tt) {
	return tt == Tok_POINTER || tt == Tok_Hat;
}

static inline bool FIRST_ProcedureType(int tt) {
	return tt == Tok_PROCEDURE || tt == Tok_PROC;
}

static inline bool FIRST_VariableDeclaration(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_VariableType(int tt) {
	return tt == Tok_POINTER || tt == Tok_ident || tt == Tok_Hat;
}

static inline bool FIRST_ProcedureDeclaration(int tt) {
	return tt == Tok_PROCEDURE || tt == Tok_PROC;
}

static inline bool FIRST_ProcedureHeading(int tt) {
	return tt == Tok_PROCEDURE || tt == Tok_PROC;
}

static inline bool FIRST_ProcedureBody(int tt) {
	return tt == Tok_BEGIN || tt == Tok_VAR;
}

static inline bool FIRST_LocalDeclaration(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_FormalParameters(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_ReturnType(int tt) {
	return tt == Tok_POINTER || tt == Tok_ident || tt == Tok_Hat;
}

static inline bool FIRST_FPSection(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_FormalType(int tt) {
	return tt == Tok_POINTER || tt == Tok_ident || tt == Tok_Hat;
}

static inline bool FIRST_module(int tt) {
	return tt == Tok_MODULE;
}

static inline bool FIRST_ImportList(int tt) {
	return tt == Tok_IMPORT;
}

static inline bool FIRST_import(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_ImportPath(int tt) {
	return tt == Tok_ident;
}

static inline bool FIRST_DeclarationSequence(int tt) {
	return tt == Tok_PROCEDURE || tt == Tok_PROC || tt == Tok_TYPE || tt == Tok_VAR;
}

static inline bool FIRST_Expression(int tt) {
	switch(tt){
	case Tok_ldloc_1:
	case Tok_rem:
	case Tok_ldloc_s:
	case Tok_conv_u1:
	case Tok_ldind_u8:
	case Tok_call:
	case Tok_add:
	case Tok_ldelem_u2:
	case Tok_ldelem:
	case Tok_ldarg_0:
	case Tok_ldarg_2:
	case Tok_ldelema:
	case Tok_ldelem_ip:
	case Tok_ldind_r8:
	case Tok_shr:
	case Tok_ldelem_r4:
	case Tok_ldc_i4_2:
	case Tok_ldelem_i4:
	case Tok_conv_r8:
	case Tok_ldelem_u1:
	case Tok_ldarg:
	case Tok_ldc_i4_6:
	case Tok_ldc_i4_5:
	case Tok_ldc_i4_7:
	case Tok_ldind_r4:
	case Tok_clt:
	case Tok_ldarg_s:
	case Tok_conv_i1:
	case Tok_newobj:
	case Tok_ldelem_i2:
	case Tok_cgt_un:
	case Tok_ldind_i4:
	case Tok_ldc_r4:
	case Tok_ceq:
	case Tok_newvla:
	case Tok_ldind_u4:
	case Tok_ldc_i4_3:
	case Tok_ldloc:
	case Tok_ldarga:
	case Tok_dup:
	case Tok_mul:
	case Tok_calli:
	case Tok_ldind_u1:
	case Tok_ldelem_r8:
	case Tok_ldvara:
	case Tok_cgt:
	case Tok_ldarg_1:
	case Tok_ldind_i8:
	case Tok_ldc_i4_m1:
	case Tok_ldloca:
	case Tok_conv_i4:
	case Tok_ldnull:
	case Tok_ldloc_0:
	case Tok_conv_u4:
	case Tok_ldobj:
	case Tok_xor:
	case Tok_ldarg_3:
	case Tok_ldvar:
	case Tok_ldelem_i8:
	case Tok_ldproc:
	case Tok_ldc_i4_8:
	case Tok_ldind_ip:
	case Tok_or:
	case Tok_conv_u2:
	case Tok_ldelem_u4:
	case Tok_ldc_i4_4:
	case Tok_ldstr:
	case Tok_ldelem_u8:
	case Tok_not:
	case Tok_conv_i2:
	case Tok_clt_un:
	case Tok_ldarga_s:
	case Tok_ldftn:
	case Tok_castptr:
	case Tok_ldflda:
	case Tok_ldelem_i1:
	case Tok_ldc_i4_0:
	case Tok_ldc_i8:
	case Tok_shr_un:
	case Tok_ldind_i2:
	case Tok_ldloc_2:
	case Tok_ldc_i4_s:
	case Tok_neg:
	case Tok_conv_i8:
	case Tok_ldloca_s:
	case Tok_ldind_i1:
	case Tok_ldc_i4:
	case Tok_newarr:
	case Tok_and:
	case Tok_ldfld:
	case Tok_conv_r4:
	case Tok_shl:
	case Tok_ldloc_3:
	case Tok_ldc_i4_1:
	case Tok_ldc_r8:
	case Tok_ldind_u2:
	case Tok_sub:
	case Tok_conv_ip:
	case Tok_div:
	case Tok_conv_u8:
		return true;
	default: return false;
	}
}

static inline bool FIRST_ExpInstr(int tt) {
	switch(tt){
	case Tok_ldloc_1:
	case Tok_rem:
	case Tok_ldloc_s:
	case Tok_conv_u1:
	case Tok_ldind_u8:
	case Tok_call:
	case Tok_add:
	case Tok_ldelem_u2:
	case Tok_ldelem:
	case Tok_ldarg_0:
	case Tok_ldarg_2:
	case Tok_ldelema:
	case Tok_ldelem_ip:
	case Tok_ldind_r8:
	case Tok_shr:
	case Tok_ldelem_r4:
	case Tok_ldc_i4_2:
	case Tok_ldelem_i4:
	case Tok_conv_r8:
	case Tok_ldelem_u1:
	case Tok_ldarg:
	case Tok_ldc_i4_6:
	case Tok_ldc_i4_5:
	case Tok_ldc_i4_7:
	case Tok_ldind_r4:
	case Tok_clt:
	case Tok_ldarg_s:
	case Tok_conv_i1:
	case Tok_newobj:
	case Tok_ldelem_i2:
	case Tok_cgt_un:
	case Tok_ldind_i4:
	case Tok_ldc_r4:
	case Tok_ceq:
	case Tok_newvla:
	case Tok_ldind_u4:
	case Tok_ldc_i4_3:
	case Tok_ldloc:
	case Tok_ldarga:
	case Tok_dup:
	case Tok_mul:
	case Tok_calli:
	case Tok_ldind_u1:
	case Tok_ldelem_r8:
	case Tok_ldvara:
	case Tok_cgt:
	case Tok_ldarg_1:
	case Tok_ldind_i8:
	case Tok_ldc_i4_m1:
	case Tok_ldloca:
	case Tok_conv_i4:
	case Tok_ldnull:
	case Tok_ldloc_0:
	case Tok_conv_u4:
	case Tok_ldobj:
	case Tok_xor:
	case Tok_ldarg_3:
	case Tok_ldvar:
	case Tok_ldelem_i8:
	case Tok_ldproc:
	case Tok_ldc_i4_8:
	case Tok_ldind_ip:
	case Tok_or:
	case Tok_conv_u2:
	case Tok_ldelem_u4:
	case Tok_ldc_i4_4:
	case Tok_ldstr:
	case Tok_ldelem_u8:
	case Tok_not:
	case Tok_conv_i2:
	case Tok_clt_un:
	case Tok_ldarga_s:
	case Tok_ldftn:
	case Tok_castptr:
	case Tok_ldflda:
	case Tok_ldelem_i1:
	case Tok_ldc_i4_0:
	case Tok_ldc_i8:
	case Tok_shr_un:
	case Tok_ldind_i2:
	case Tok_ldloc_2:
	case Tok_ldc_i4_s:
	case Tok_neg:
	case Tok_conv_i8:
	case Tok_ldloca_s:
	case Tok_ldind_i1:
	case Tok_ldc_i4:
	case Tok_newarr:
	case Tok_and:
	case Tok_ldfld:
	case Tok_conv_r4:
	case Tok_shl:
	case Tok_ldloc_3:
	case Tok_ldc_i4_1:
	case Tok_ldc_r8:
	case Tok_ldind_u2:
	case Tok_sub:
	case Tok_conv_ip:
	case Tok_div:
	case Tok_conv_u8:
		return true;
	default: return false;
	}
}

static inline bool FIRST_StatementSequence(int tt) {
	switch(tt){
	case Tok_stloc_2:
	case Tok_stfld:
	case Tok_stind_i4:
	case Tok_stind_ip:
	case Tok_SWITCH:
	case Tok_IF:
	case Tok_stind_r4:
	case Tok_starg_s:
	case Tok_stloc_s:
	case Tok_REPEAT:
	case Tok_line:
	case Tok_calli:
	case Tok_pop:
	case Tok_call:
	case Tok_stloc_1:
	case Tok_stloc:
	case Tok_stelem_i8:
	case Tok_starg:
	case Tok_disp:
	case Tok_stelem_i2:
	case Tok_stind_i1:
	case Tok_label:
	case Tok_goto:
	case Tok_stind_i2:
	case Tok_stelem_i4:
	case Tok_WHILE:
	case Tok_stloc_3:
	case Tok_exit:
	case Tok_ret:
	case Tok_stind_r8:
	case Tok_stloc_0:
	case Tok_stelem_r4:
	case Tok_stind_i8:
	case Tok_stelem:
	case Tok_stelem_r8:
	case Tok_stvar:
	case Tok_stelem_i1:
	case Tok_stelem_ip:
	case Tok_stobj:
	case Tok_LOOP:
		return true;
	default: return false;
	}
}

static inline bool FIRST_Statement(int tt) {
	switch(tt){
	case Tok_stloc_2:
	case Tok_stfld:
	case Tok_stind_i4:
	case Tok_stind_ip:
	case Tok_SWITCH:
	case Tok_IF:
	case Tok_stind_r4:
	case Tok_starg_s:
	case Tok_stloc_s:
	case Tok_REPEAT:
	case Tok_line:
	case Tok_calli:
	case Tok_pop:
	case Tok_call:
	case Tok_stloc_1:
	case Tok_stloc:
	case Tok_stelem_i8:
	case Tok_starg:
	case Tok_disp:
	case Tok_stelem_i2:
	case Tok_stind_i1:
	case Tok_label:
	case Tok_goto:
	case Tok_stind_i2:
	case Tok_stelem_i4:
	case Tok_WHILE:
	case Tok_stloc_3:
	case Tok_exit:
	case Tok_ret:
	case Tok_stind_r8:
	case Tok_stloc_0:
	case Tok_stelem_r4:
	case Tok_stind_i8:
	case Tok_stelem:
	case Tok_stelem_r8:
	case Tok_stvar:
	case Tok_stelem_i1:
	case Tok_stelem_ip:
	case Tok_stobj:
	case Tok_LOOP:
		return true;
	default: return false;
	}
}

static inline bool FIRST_IfThenElse(int tt) {
	return tt == Tok_IF;
}

static inline bool FIRST_Loop(int tt) {
	return tt == Tok_LOOP;
}

static inline bool FIRST_Switch(int tt) {
	return tt == Tok_SWITCH;
}

static inline bool FIRST_RepeatUntil(int tt) {
	return tt == Tok_REPEAT;
}

static inline bool FIRST_WhileDo(int tt) {
	return tt == Tok_WHILE;
}

void Parser::RunParser() {
	root = SynTree();
	errors.clear();
	next();
	Mil(&root);
}

void Parser::next() {
	cur = la;
	la = scanner->next();
	while( la.d_type == Tok_Invalid ) {
		errors << Error(la.d_val, la.d_lineNr, la.d_colNr, la.d_sourcePath);
		la = scanner->next();
	}
}

Token Parser::peek(int off) {
	if( off == 1 )
		return la;
	else if( off == 0 )
		return cur;
	else
		return scanner->peek(off-1);
}

void Parser::invalid(const char* what) {
	errors << Error(QString("invalid %1").arg(what),la.d_lineNr, la.d_colNr, la.d_sourcePath);
}

bool Parser::expect(int tt, bool pkw, const char* where) {
	if( la.d_type == tt || la.d_code == tt) { next(); return true; }
	else { errors << Error(QString("'%1' expected in %2").arg(tokenTypeString(tt)).arg(where),la.d_lineNr, la.d_colNr, la.d_sourcePath); return false; }
}

static inline void dummy() {}

	void Parser::addTerminal(SynTree* st) {
		if( cur.d_type != Tok_Semi && cur.d_type != Tok_Comma && cur.d_type != Tok_Dot && cur.d_type != Tok_Colon ){
			SynTree* tmp = new SynTree( cur ); st->d_children.append(tmp);
		}
	}
void Parser::Mil(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Mil, la); st->d_children.append(tmp); st = tmp; }
	module(st);
}

void Parser::integer(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_integer, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus || la.d_type == Tok_Minus ) {
		if( la.d_type == Tok_Plus ) {
			if( expect(Tok_Plus, false, "integer") ) addTerminal(st);
		} else if( la.d_type == Tok_Minus ) {
			if( expect(Tok_Minus, false, "integer") ) addTerminal(st);
		} else
			invalid("integer");
	}
	if( expect(Tok_unsigned, false, "integer") ) addTerminal(st);
}

void Parser::qualident(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_qualident, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_Dot )  ) {
		if( expect(Tok_ident, false, "qualident") ) addTerminal(st);
		if( expect(Tok_Dot, false, "qualident") ) addTerminal(st);
	}
	if( expect(Tok_ident, false, "qualident") ) addTerminal(st);
}

void Parser::identdef(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_identdef, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ident, false, "identdef") ) addTerminal(st);
	if( la.d_type == Tok_Star ) {
		if( expect(Tok_Star, false, "identdef") ) addTerminal(st);
	}
}

void Parser::TypeDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_TypeDeclaration, la); st->d_children.append(tmp); st = tmp; }
	identdef(st);
	if( expect(Tok_Eq, false, "TypeDeclaration") ) addTerminal(st);
	type(st);
}

void Parser::type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_NamedType(la.d_type) ) {
		NamedType(st);
	} else if( FIRST_ArrayType(la.d_type) || FIRST_ArrayType(la.d_code) ) {
		ArrayType(st);
	} else if( FIRST_StructUnionType(la.d_type) || FIRST_StructUnionType(la.d_code) ) {
		StructUnionType(st);
	} else if( FIRST_PointerType(la.d_type) || FIRST_PointerType(la.d_code) ) {
		PointerType(st);
	} else if( FIRST_ProcedureType(la.d_type) || FIRST_ProcedureType(la.d_code) ) {
		ProcedureType(st);
	} else
		invalid("type");
}

void Parser::NamedType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_NamedType, la); st->d_children.append(tmp); st = tmp; }
	qualident(st);
}

void Parser::ArrayType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ArrayType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_ARRAY ) {
		if( expect(Tok_ARRAY, true, "ArrayType") ) addTerminal(st);
		if( FIRST_length(la.d_type) ) {
			length(st);
		}
		if( expect(Tok_OF, true, "ArrayType") ) addTerminal(st);
		type(st);
	} else if( la.d_type == Tok_Lbrack ) {
		if( expect(Tok_Lbrack, false, "ArrayType") ) addTerminal(st);
		if( FIRST_length(la.d_type) ) {
			length(st);
		}
		if( expect(Tok_Rbrack, false, "ArrayType") ) addTerminal(st);
		type(st);
	} else
		invalid("ArrayType");
}

void Parser::length(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_length, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_unsigned, false, "length") ) addTerminal(st);
}

void Parser::StructUnionType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_StructUnionType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_STRUCT ) {
		if( expect(Tok_STRUCT, true, "StructUnionType") ) addTerminal(st);
	} else if( la.d_code == Tok_UNION ) {
		if( expect(Tok_UNION, true, "StructUnionType") ) addTerminal(st);
	} else
		invalid("StructUnionType");
	while( FIRST_FieldList(la.d_type) ) {
		FieldList(st);
		if( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "StructUnionType") ) addTerminal(st);
		}
	}
	if( expect(Tok_END, true, "StructUnionType") ) addTerminal(st);
}

void Parser::FieldList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FieldList, la); st->d_children.append(tmp); st = tmp; }
	IdentList(st);
	if( expect(Tok_Colon, false, "FieldList") ) addTerminal(st);
	type(st);
}

void Parser::IdentList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_IdentList, la); st->d_children.append(tmp); st = tmp; }
	identdef(st);
	while( la.d_type == Tok_Comma || FIRST_identdef(la.d_type) ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "IdentList") ) addTerminal(st);
		}
		identdef(st);
	}
}

void Parser::PointerType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_PointerType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_POINTER ) {
		if( expect(Tok_POINTER, true, "PointerType") ) addTerminal(st);
		if( expect(Tok_TO, true, "PointerType") ) addTerminal(st);
	} else if( la.d_type == Tok_Hat ) {
		if( expect(Tok_Hat, false, "PointerType") ) addTerminal(st);
	} else
		invalid("PointerType");
	type(st);
}

void Parser::ProcedureType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_PROCEDURE ) {
		if( expect(Tok_PROCEDURE, true, "ProcedureType") ) addTerminal(st);
	} else if( la.d_code == Tok_PROC ) {
		if( expect(Tok_PROC, true, "ProcedureType") ) addTerminal(st);
	} else
		invalid("ProcedureType");
	if( FIRST_FormalParameters(la.d_type) ) {
		FormalParameters(st);
	}
}

void Parser::VariableDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_VariableDeclaration, la); st->d_children.append(tmp); st = tmp; }
	IdentList(st);
	if( expect(Tok_Colon, false, "VariableDeclaration") ) addTerminal(st);
	VariableType(st);
}

void Parser::VariableType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_VariableType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_POINTER || la.d_type == Tok_Hat ) {
		if( la.d_code == Tok_POINTER ) {
			if( expect(Tok_POINTER, true, "VariableType") ) addTerminal(st);
			if( expect(Tok_TO, true, "VariableType") ) addTerminal(st);
		} else if( la.d_type == Tok_Hat ) {
			if( expect(Tok_Hat, false, "VariableType") ) addTerminal(st);
		} else
			invalid("VariableType");
	}
	NamedType(st);
}

void Parser::ProcedureDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureDeclaration, la); st->d_children.append(tmp); st = tmp; }
	ProcedureHeading(st);
	if( FIRST_FormalParameters(la.d_type) || la.d_type == Tok_Semi || FIRST_ProcedureBody(la.d_type) || FIRST_ProcedureBody(la.d_code) ) {
		if( FIRST_FormalParameters(la.d_type) ) {
			FormalParameters(st);
		}
		if( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "ProcedureDeclaration") ) addTerminal(st);
		}
		ProcedureBody(st);
		if( expect(Tok_END, true, "ProcedureDeclaration") ) addTerminal(st);
		if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "ProcedureDeclaration") ) addTerminal(st);
		}
	} else if( la.d_type == Tok_Eq ) {
		if( expect(Tok_Eq, false, "ProcedureDeclaration") ) addTerminal(st);
		qualident(st);
	} else
		invalid("ProcedureDeclaration");
}

void Parser::ProcedureHeading(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureHeading, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_PROCEDURE ) {
		if( expect(Tok_PROCEDURE, true, "ProcedureHeading") ) addTerminal(st);
	} else if( la.d_code == Tok_PROC ) {
		if( expect(Tok_PROC, true, "ProcedureHeading") ) addTerminal(st);
	} else
		invalid("ProcedureHeading");
	if( la.d_code == Tok_INLINE ) {
		if( expect(Tok_INLINE, true, "ProcedureHeading") ) addTerminal(st);
	}
	identdef(st);
}

void Parser::ProcedureBody(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ProcedureBody, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_VAR ) {
		if( expect(Tok_VAR, true, "ProcedureBody") ) addTerminal(st);
		while( FIRST_LocalDeclaration(la.d_type) ) {
			LocalDeclaration(st);
			if( la.d_type == Tok_Semi ) {
				if( expect(Tok_Semi, false, "ProcedureBody") ) addTerminal(st);
			}
		}
	}
	if( expect(Tok_BEGIN, true, "ProcedureBody") ) addTerminal(st);
	StatementSequence(st);
}

void Parser::LocalDeclaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_LocalDeclaration, la); st->d_children.append(tmp); st = tmp; }
	IdentList(st);
	if( expect(Tok_Colon, false, "LocalDeclaration") ) addTerminal(st);
	VariableType(st);
}

void Parser::FormalParameters(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FormalParameters, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "FormalParameters") ) addTerminal(st);
	if( FIRST_FPSection(la.d_type) ) {
		FPSection(st);
		while( ( peek(1).d_type == Tok_Semi && peek(2).d_type == Tok_ident )  ) {
			if( expect(Tok_Semi, false, "FormalParameters") ) addTerminal(st);
			FPSection(st);
		}
		if( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "FormalParameters") ) addTerminal(st);
			if( expect(Tok_2Dot, false, "FormalParameters") ) addTerminal(st);
		}
	}
	if( expect(Tok_Rpar, false, "FormalParameters") ) addTerminal(st);
	if( la.d_type == Tok_Colon ) {
		if( expect(Tok_Colon, false, "FormalParameters") ) addTerminal(st);
		ReturnType(st);
	}
}

void Parser::ReturnType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ReturnType, la); st->d_children.append(tmp); st = tmp; }
	FormalType(st);
}

void Parser::FPSection(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FPSection, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_ident, false, "FPSection") ) addTerminal(st);
	while( la.d_type == Tok_Comma || la.d_type == Tok_ident ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "FPSection") ) addTerminal(st);
		}
		if( expect(Tok_ident, false, "FPSection") ) addTerminal(st);
	}
	if( expect(Tok_Colon, false, "FPSection") ) addTerminal(st);
	FormalType(st);
}

void Parser::FormalType(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_FormalType, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_POINTER || la.d_type == Tok_Hat ) {
		if( la.d_code == Tok_POINTER ) {
			if( expect(Tok_POINTER, true, "FormalType") ) addTerminal(st);
			if( expect(Tok_TO, true, "FormalType") ) addTerminal(st);
		} else if( la.d_type == Tok_Hat ) {
			if( expect(Tok_Hat, false, "FormalType") ) addTerminal(st);
		} else
			invalid("FormalType");
	}
	NamedType(st);
}

void Parser::module(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_module, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_MODULE, true, "module") ) addTerminal(st);
	if( expect(Tok_ident, false, "module") ) addTerminal(st);
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "module") ) addTerminal(st);
	}
	if( FIRST_ImportList(la.d_type) || FIRST_ImportList(la.d_code) ) {
		ImportList(st);
	}
	while( FIRST_DeclarationSequence(la.d_type) || FIRST_DeclarationSequence(la.d_code) ) {
		DeclarationSequence(st);
	}
	if( la.d_code == Tok_BEGIN ) {
		if( expect(Tok_BEGIN, true, "module") ) addTerminal(st);
		StatementSequence(st);
	}
	if( expect(Tok_END, true, "module") ) addTerminal(st);
	if( expect(Tok_ident, false, "module") ) addTerminal(st);
	if( la.d_type == Tok_Dot ) {
		if( expect(Tok_Dot, false, "module") ) addTerminal(st);
	}
}

void Parser::ImportList(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ImportList, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IMPORT, true, "ImportList") ) addTerminal(st);
	import(st);
	while( la.d_type == Tok_Comma || FIRST_import(la.d_type) ) {
		if( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "ImportList") ) addTerminal(st);
		}
		import(st);
	}
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "ImportList") ) addTerminal(st);
	}
}

void Parser::import(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_import, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_ColonEq )  ) {
		if( expect(Tok_ident, false, "import") ) addTerminal(st);
		if( expect(Tok_ColonEq, false, "import") ) addTerminal(st);
	}
	ImportPath(st);
	if( expect(Tok_ident, false, "import") ) addTerminal(st);
}

void Parser::ImportPath(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ImportPath, la); st->d_children.append(tmp); st = tmp; }
	while( ( peek(1).d_type == Tok_ident && peek(2).d_type == Tok_Dot )  ) {
		if( expect(Tok_ident, false, "ImportPath") ) addTerminal(st);
		if( expect(Tok_Dot, false, "ImportPath") ) addTerminal(st);
	}
}

void Parser::DeclarationSequence(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_DeclarationSequence, la); st->d_children.append(tmp); st = tmp; }
	while( la.d_code == Tok_TYPE || la.d_code == Tok_VAR || FIRST_ProcedureDeclaration(la.d_type) || FIRST_ProcedureDeclaration(la.d_code) ) {
		if( la.d_code == Tok_TYPE ) {
			if( expect(Tok_TYPE, true, "DeclarationSequence") ) addTerminal(st);
			while( FIRST_TypeDeclaration(la.d_type) ) {
				TypeDeclaration(st);
				if( la.d_type == Tok_Semi ) {
					if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
				}
			}
		} else if( la.d_code == Tok_VAR ) {
			if( expect(Tok_VAR, true, "DeclarationSequence") ) addTerminal(st);
			while( FIRST_VariableDeclaration(la.d_type) ) {
				VariableDeclaration(st);
				if( la.d_type == Tok_Semi ) {
					if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
				}
			}
		} else if( FIRST_ProcedureDeclaration(la.d_type) || FIRST_ProcedureDeclaration(la.d_code) ) {
			ProcedureDeclaration(st);
			if( la.d_type == Tok_Semi ) {
				if( expect(Tok_Semi, false, "DeclarationSequence") ) addTerminal(st);
			}
		} else
			invalid("DeclarationSequence");
	}
}

void Parser::Expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Expression, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_ExpInstr(la.d_type) || FIRST_ExpInstr(la.d_code) ) {
		ExpInstr(st);
	}
}

void Parser::ExpInstr(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ExpInstr, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_add ) {
		if( expect(Tok_add, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_and ) {
		if( expect(Tok_and, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_call || la.d_code == Tok_calli ) {
		if( la.d_code == Tok_call ) {
			if( expect(Tok_call, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_calli ) {
			if( expect(Tok_calli, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		qualident(st);
	} else if( la.d_code == Tok_castptr ) {
		if( expect(Tok_castptr, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_ceq ) {
		if( expect(Tok_ceq, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_cgt ) {
		if( expect(Tok_cgt, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_cgt_un ) {
		if( expect(Tok_cgt_un, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_clt ) {
		if( expect(Tok_clt, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_clt_un ) {
		if( expect(Tok_clt_un, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_i1 ) {
		if( expect(Tok_conv_i1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_i2 ) {
		if( expect(Tok_conv_i2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_i4 ) {
		if( expect(Tok_conv_i4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_i8 ) {
		if( expect(Tok_conv_i8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_r4 ) {
		if( expect(Tok_conv_r4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_r8 ) {
		if( expect(Tok_conv_r8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_u1 ) {
		if( expect(Tok_conv_u1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_u2 ) {
		if( expect(Tok_conv_u2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_u4 ) {
		if( expect(Tok_conv_u4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_u8 ) {
		if( expect(Tok_conv_u8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_conv_ip ) {
		if( expect(Tok_conv_ip, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_div ) {
		if( expect(Tok_div, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_dup ) {
		if( expect(Tok_dup, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldarg || la.d_code == Tok_ldarg_s ) {
		if( la.d_code == Tok_ldarg ) {
			if( expect(Tok_ldarg, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldarg_s ) {
			if( expect(Tok_ldarg_s, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "ExpInstr") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
	} else if( la.d_code == Tok_ldarg_0 ) {
		if( expect(Tok_ldarg_0, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldarg_1 ) {
		if( expect(Tok_ldarg_1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldarg_2 ) {
		if( expect(Tok_ldarg_2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldarg_3 ) {
		if( expect(Tok_ldarg_3, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldarga || la.d_code == Tok_ldarga_s ) {
		if( la.d_code == Tok_ldarga ) {
			if( expect(Tok_ldarga, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldarga_s ) {
			if( expect(Tok_ldarga_s, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "ExpInstr") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
	} else if( la.d_code == Tok_ldc_i4 || la.d_code == Tok_ldc_i8 || la.d_code == Tok_ldc_i4_s ) {
		if( la.d_code == Tok_ldc_i4 ) {
			if( expect(Tok_ldc_i4, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldc_i8 ) {
			if( expect(Tok_ldc_i8, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldc_i4_s ) {
			if( expect(Tok_ldc_i4_s, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		integer(st);
	} else if( la.d_code == Tok_ldc_r4 || la.d_code == Tok_ldc_r8 ) {
		if( la.d_code == Tok_ldc_r4 ) {
			if( expect(Tok_ldc_r4, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldc_r8 ) {
			if( expect(Tok_ldc_r8, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		if( expect(Tok_real, false, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_0 ) {
		if( expect(Tok_ldc_i4_0, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_1 ) {
		if( expect(Tok_ldc_i4_1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_2 ) {
		if( expect(Tok_ldc_i4_2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_3 ) {
		if( expect(Tok_ldc_i4_3, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_4 ) {
		if( expect(Tok_ldc_i4_4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_5 ) {
		if( expect(Tok_ldc_i4_5, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_6 ) {
		if( expect(Tok_ldc_i4_6, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_7 ) {
		if( expect(Tok_ldc_i4_7, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_8 ) {
		if( expect(Tok_ldc_i4_8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldc_i4_m1 ) {
		if( expect(Tok_ldc_i4_m1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem || la.d_code == Tok_ldelema ) {
		if( la.d_code == Tok_ldelem ) {
			if( expect(Tok_ldelem, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldelema ) {
			if( expect(Tok_ldelema, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		qualident(st);
	} else if( la.d_code == Tok_ldelem_i1 ) {
		if( expect(Tok_ldelem_i1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_i2 ) {
		if( expect(Tok_ldelem_i2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_i4 ) {
		if( expect(Tok_ldelem_i4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_i8 ) {
		if( expect(Tok_ldelem_i8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_u1 ) {
		if( expect(Tok_ldelem_u1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_u2 ) {
		if( expect(Tok_ldelem_u2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_u4 ) {
		if( expect(Tok_ldelem_u4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_u8 ) {
		if( expect(Tok_ldelem_u8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_r4 ) {
		if( expect(Tok_ldelem_r4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_r8 ) {
		if( expect(Tok_ldelem_r8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldelem_ip ) {
		if( expect(Tok_ldelem_ip, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldfld || la.d_code == Tok_ldflda ) {
		if( la.d_code == Tok_ldfld ) {
			if( expect(Tok_ldfld, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldflda ) {
			if( expect(Tok_ldflda, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		qualident(st);
		if( expect(Tok_Dot, false, "ExpInstr") ) addTerminal(st);
		if( expect(Tok_ident, false, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldftn ) {
		if( expect(Tok_ldftn, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_ldind_i1 ) {
		if( expect(Tok_ldind_i1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_i2 ) {
		if( expect(Tok_ldind_i2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_i4 ) {
		if( expect(Tok_ldind_i4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_i8 ) {
		if( expect(Tok_ldind_i8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_u1 ) {
		if( expect(Tok_ldind_u1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_u2 ) {
		if( expect(Tok_ldind_u2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_u4 ) {
		if( expect(Tok_ldind_u4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_r4 ) {
		if( expect(Tok_ldind_r4, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_u8 ) {
		if( expect(Tok_ldind_u8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_r8 ) {
		if( expect(Tok_ldind_r8, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldind_ip ) {
		if( expect(Tok_ldind_ip, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldloc || la.d_code == Tok_ldloc_s || la.d_code == Tok_ldloca || la.d_code == Tok_ldloca_s ) {
		if( la.d_code == Tok_ldloc ) {
			if( expect(Tok_ldloc, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldloc_s ) {
			if( expect(Tok_ldloc_s, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldloca ) {
			if( expect(Tok_ldloca, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldloca_s ) {
			if( expect(Tok_ldloca_s, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "ExpInstr") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
	} else if( la.d_code == Tok_ldloc_0 ) {
		if( expect(Tok_ldloc_0, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldloc_1 ) {
		if( expect(Tok_ldloc_1, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldloc_2 ) {
		if( expect(Tok_ldloc_2, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldloc_3 ) {
		if( expect(Tok_ldloc_3, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldnull ) {
		if( expect(Tok_ldnull, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldobj ) {
		if( expect(Tok_ldobj, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_ldproc ) {
		if( expect(Tok_ldproc, true, "ExpInstr") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_ldstr ) {
		if( expect(Tok_ldstr, true, "ExpInstr") ) addTerminal(st);
		if( expect(Tok_string, false, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_ldvar || la.d_code == Tok_ldvara ) {
		if( la.d_code == Tok_ldvar ) {
			if( expect(Tok_ldvar, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_ldvara ) {
			if( expect(Tok_ldvara, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		qualident(st);
	} else if( la.d_code == Tok_mul ) {
		if( expect(Tok_mul, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_neg ) {
		if( expect(Tok_neg, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_newarr || la.d_code == Tok_newvla || la.d_code == Tok_newobj ) {
		if( la.d_code == Tok_newarr ) {
			if( expect(Tok_newarr, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_newvla ) {
			if( expect(Tok_newvla, true, "ExpInstr") ) addTerminal(st);
		} else if( la.d_code == Tok_newobj ) {
			if( expect(Tok_newobj, true, "ExpInstr") ) addTerminal(st);
		} else
			invalid("ExpInstr");
		qualident(st);
	} else if( la.d_code == Tok_not ) {
		if( expect(Tok_not, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_or ) {
		if( expect(Tok_or, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_rem ) {
		if( expect(Tok_rem, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_shl ) {
		if( expect(Tok_shl, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_shr ) {
		if( expect(Tok_shr, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_shr_un ) {
		if( expect(Tok_shr_un, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_sub ) {
		if( expect(Tok_sub, true, "ExpInstr") ) addTerminal(st);
	} else if( la.d_code == Tok_xor ) {
		if( expect(Tok_xor, true, "ExpInstr") ) addTerminal(st);
	} else
		invalid("ExpInstr");
}

void Parser::StatementSequence(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_StatementSequence, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_Statement(la.d_type) || FIRST_Statement(la.d_code) ) {
		Statement(st);
	}
}

void Parser::Statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Statement, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_code == Tok_call || la.d_code == Tok_calli ) {
		if( la.d_code == Tok_call ) {
			if( expect(Tok_call, true, "Statement") ) addTerminal(st);
		} else if( la.d_code == Tok_calli ) {
			if( expect(Tok_calli, true, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
		qualident(st);
	} else if( la.d_code == Tok_disp ) {
		if( expect(Tok_disp, true, "Statement") ) addTerminal(st);
	} else if( FIRST_RepeatUntil(la.d_type) || FIRST_RepeatUntil(la.d_code) ) {
		RepeatUntil(st);
	} else if( la.d_code == Tok_exit ) {
		if( expect(Tok_exit, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_goto ) {
		if( expect(Tok_goto, true, "Statement") ) addTerminal(st);
		if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
	} else if( FIRST_IfThenElse(la.d_type) || FIRST_IfThenElse(la.d_code) ) {
		IfThenElse(st);
	} else if( la.d_code == Tok_label ) {
		if( expect(Tok_label, true, "Statement") ) addTerminal(st);
		if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_line ) {
		if( expect(Tok_line, true, "Statement") ) addTerminal(st);
		if( expect(Tok_unsigned, false, "Statement") ) addTerminal(st);
	} else if( FIRST_Loop(la.d_type) || FIRST_Loop(la.d_code) ) {
		Loop(st);
	} else if( la.d_code == Tok_pop ) {
		if( expect(Tok_pop, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_ret ) {
		if( expect(Tok_ret, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_starg || la.d_code == Tok_starg_s ) {
		if( la.d_code == Tok_starg ) {
			if( expect(Tok_starg, true, "Statement") ) addTerminal(st);
		} else if( la.d_code == Tok_starg_s ) {
			if( expect(Tok_starg_s, true, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "Statement") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
	} else if( la.d_code == Tok_stelem ) {
		if( expect(Tok_stelem, true, "Statement") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_stelem_i1 ) {
		if( expect(Tok_stelem_i1, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stelem_i2 ) {
		if( expect(Tok_stelem_i2, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stelem_i4 ) {
		if( expect(Tok_stelem_i4, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stelem_i8 ) {
		if( expect(Tok_stelem_i8, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stelem_r4 ) {
		if( expect(Tok_stelem_r4, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stelem_r8 ) {
		if( expect(Tok_stelem_r8, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stelem_ip ) {
		if( expect(Tok_stelem_ip, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stfld ) {
		if( expect(Tok_stfld, true, "Statement") ) addTerminal(st);
		qualident(st);
		if( expect(Tok_Dot, false, "Statement") ) addTerminal(st);
		if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stind_i1 ) {
		if( expect(Tok_stind_i1, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stind_i2 ) {
		if( expect(Tok_stind_i2, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stind_i4 ) {
		if( expect(Tok_stind_i4, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stind_i8 ) {
		if( expect(Tok_stind_i8, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stind_r4 ) {
		if( expect(Tok_stind_r4, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stind_r8 ) {
		if( expect(Tok_stind_r8, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stind_ip ) {
		if( expect(Tok_stind_ip, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stloc || la.d_code == Tok_stloc_s ) {
		if( la.d_code == Tok_stloc ) {
			if( expect(Tok_stloc, true, "Statement") ) addTerminal(st);
		} else if( la.d_code == Tok_stloc_s ) {
			if( expect(Tok_stloc_s, true, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
		if( la.d_type == Tok_unsigned ) {
			if( expect(Tok_unsigned, false, "Statement") ) addTerminal(st);
		} else if( la.d_type == Tok_ident ) {
			if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
		} else
			invalid("Statement");
	} else if( la.d_code == Tok_stloc_0 ) {
		if( expect(Tok_stloc_0, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stloc_1 ) {
		if( expect(Tok_stloc_1, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stloc_2 ) {
		if( expect(Tok_stloc_2, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stloc_3 ) {
		if( expect(Tok_stloc_3, true, "Statement") ) addTerminal(st);
	} else if( la.d_code == Tok_stobj ) {
		if( expect(Tok_stobj, true, "Statement") ) addTerminal(st);
		qualident(st);
	} else if( la.d_code == Tok_stvar ) {
		if( expect(Tok_stvar, true, "Statement") ) addTerminal(st);
		qualident(st);
		if( expect(Tok_Dot, false, "Statement") ) addTerminal(st);
		if( expect(Tok_ident, false, "Statement") ) addTerminal(st);
	} else if( FIRST_Switch(la.d_type) || FIRST_Switch(la.d_code) ) {
		Switch(st);
	} else if( FIRST_WhileDo(la.d_type) || FIRST_WhileDo(la.d_code) ) {
		WhileDo(st);
	} else
		invalid("Statement");
}

void Parser::IfThenElse(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_IfThenElse, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_IF, true, "IfThenElse") ) addTerminal(st);
	Expression(st);
	if( expect(Tok_THEN, true, "IfThenElse") ) addTerminal(st);
	StatementSequence(st);
	if( la.d_code == Tok_ELSE ) {
		if( expect(Tok_ELSE, true, "IfThenElse") ) addTerminal(st);
		StatementSequence(st);
	}
	if( expect(Tok_END, true, "IfThenElse") ) addTerminal(st);
}

void Parser::Loop(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Loop, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_LOOP, true, "Loop") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_END, true, "Loop") ) addTerminal(st);
}

void Parser::Switch(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_Switch, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_SWITCH, true, "Switch") ) addTerminal(st);
	Expression(st);
	while( la.d_code == Tok_CASE ) {
		if( expect(Tok_CASE, true, "Switch") ) addTerminal(st);
		Expression(st);
		if( expect(Tok_THEN, true, "Switch") ) addTerminal(st);
		StatementSequence(st);
	}
	if( la.d_code == Tok_ELSE ) {
		if( expect(Tok_ELSE, true, "Switch") ) addTerminal(st);
		StatementSequence(st);
	}
	if( expect(Tok_END, true, "Switch") ) addTerminal(st);
}

void Parser::RepeatUntil(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_RepeatUntil, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_REPEAT, true, "RepeatUntil") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_UNTIL, true, "RepeatUntil") ) addTerminal(st);
	Expression(st);
	if( expect(Tok_END, true, "RepeatUntil") ) addTerminal(st);
}

void Parser::WhileDo(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_WhileDo, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_WHILE, true, "WhileDo") ) addTerminal(st);
	Expression(st);
	if( expect(Tok_DO, true, "WhileDo") ) addTerminal(st);
	StatementSequence(st);
	if( expect(Tok_END, true, "WhileDo") ) addTerminal(st);
}

