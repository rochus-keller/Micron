#include "MilCeeGen.h"
#include <QDateTime>
#include <QCoreApplication>
using namespace Mil;

CeeGen::CeeGen(AstModel* mdl):mdl(mdl)
{
    Q_ASSERT(mdl);
}

static QByteArray qualident(Declaration* d)
{
    if( d->outer )
        return qualident(d->outer) + "$" + d->name;
    else
        return d->name;
}

bool CeeGen::generate(Declaration* module, QIODevice* header, QIODevice* body)
{
    Q_ASSERT( module && header && body );
    curMod = module;
    hout.setDevice(header);
    bout.setDevice(body);

    const QByteArray guard = "__" + module->name.toUpper() + "_INCLUDED__";
    const QString dedication = "// this file was generated by " + QCoreApplication::applicationName() + " "
                                + QCoreApplication::applicationVersion() + " on " + QDateTime::currentDateTime().toString();

    hout << "#ifndef " << guard << endl;
    hout << "#define " << guard << endl << endl;
    hout << "// " << module->name << ".h" << endl;
    hout << dedication << endl << endl;

    bout << "// " << module->name << ".c" << endl;
    bout << dedication << endl << endl;
    bout << "#include \"" << module->name << ".h\"" << endl << endl;

    visitModule();

    hout << endl << "#endif // " << guard << endl << endl;

}

void CeeGen::visitModule()
{
   Declaration* sub = curMod->subs;
   while( sub )
   {
       if( sub->kind == Declaration::Import )
       {
            hout << "#include \"" << sub->name << ".h\"" << endl;
       }
       sub = sub->next;
   }
   hout << endl;

   sub = curMod->subs;
   while( sub )
   {
       switch( sub->kind )
       {
       case Declaration::TypeDecl:
           typeDecl(hout, sub);
           hout << ";" << endl;
           break;
       case Declaration::ConstDecl:
           // TODO
           break;
       case Declaration::VarDecl:
           variable(bout, sub);
           bout << ";" << endl << endl;
           hout << "extern ";
           variable(hout, sub);
           hout << ";" << endl;
           break;
       case Declaration::Procedure:
           visitProcedure(sub);
           break;
       }

       sub = sub->next;
   }
}

void CeeGen::visitProcedure(Declaration* proc)
{
    procHeader(hout, proc);
    hout << ";" << endl;
    if( proc->forward )
        return;
    procHeader(bout, proc);
    bout << " {" << endl;
    // TODO
    bout << "}" << endl << endl;
}

QByteArray CeeGen::typeRef(Type* t) const
{
    if( t == 0 )
        return "void ";
    t = t->deref();
    switch(t->kind)
    {
    case Type::Any:
        return "void";
    case Type::StringLit:
        return "const char*";
    case Type::ByteArrayLit:
        return "const unsigned char*";
    case Type::NIL:
        return "NULL";
    case Type::BOOL:
        return "unsigned char";
    case Type::CHAR:
        return "char";
    case Type::INT8:
        return "char";
    case Type::INT16:
        return "short";
    case Type::INT32:
        return "int";
    case Type::INT64:
        return "long long";
    case Type::UINT8:
        return "unsigned char";
    case Type::UINT16:
        return "unsigned short";
    case Type::UINT32:
        return "unsigned int";
    case Type::UINT64:
        return "unsigned long long";
    case Type::FLOAT32:
        return "float";
    case Type::FLOAT64:
        return "double";
    case Type::INTPTR:
        return "void*";
    case Type::DBLINTPTR:
        return "DBLINTPTR"; // TODO
    }

    if( t->decl )
        return qualident(t->decl);
    else
        return "?TYPE";
}

void CeeGen::procHeader(QTextStream& out, Declaration* proc)
{
    out << typeRef(proc->getType()) << " ";
    out << qualident(proc->getForwardToProc());
    out << "(";
    DeclList params = proc->getParams();
    for( int i = 0; i < params.size(); i++ )
    {
        if( i != 0 )
            out << ", ";
        parameter(out, params[i]);
    }
    out << ")";
}

void CeeGen::parameter(QTextStream& out, Declaration* param)
{
    out << typeRef(param->getType()) << " " << param->name;
}

void CeeGen::variable(QTextStream& out, Declaration* var)
{
    out << typeRef(var->getType()) << " " << qualident(var);
}

void CeeGen::typeDecl(QTextStream& out, Declaration* d)
{
    Type* t = d->getType();
    if( t == 0 )
    {
        out << "// undeclared type " << d->name;
        return;
    }

    out << "typedef ";
    if( t->kind < Type::MaxBasicType )
        out << typeRef(t);
    else
        switch( t->kind )
        {
        case Type::Pointer:
            pointerTo(out, t);
            break;
        case Type::Proc:
            {
                out << typeRef(t->getType()) << " (*";
                out << qualident(d);
                out << ")(";
                DeclList params = t->subs;
                for( int i = 0; i < params.size(); i++ )
                {
                    if( i != 0 )
                        out << ", ";
                    parameter(out, params[i]);
                }
                out << ")";
                return;
            }
            break;
        case Type::Array:
            if( t->len == 0 )
                pointerTo(out, t); // TODO: this is wrong; pointer to array of x leads to x**
            else
            {
                out << typeRef(t->getType()) << " " << qualident(d) << "[" << t->len << "]";
                return;
            }
            break;
        case Type::Union:
        case Type::Struct:
            out << (t->kind == Type::Struct ? "struct " : "union ") << qualident(d) << " {" << endl;
            foreach( Declaration* field, t->subs )
            {
                if( field->kind == Declaration::Field )
                    out << "   " << typeRef(field->getType()) << " " << field->name << ";" << endl;
            }
            out << "}";
            break;
        case Type::Object:
            out << "Object TODO";
            break;
        case Type::NameRef:
            out << typeRef(t->getType());
            break;
        }
    out << " " << qualident(d);
}

void CeeGen::pointerTo(QTextStream& out, Type* t)
{
    Type* tt = t->getType();
    if( tt && (tt->deref()->isSUO() ) )
    {
        if( tt->deref()->kind == Type::Union )
            out << "union ";
        else
            out << "struct ";
    }
    out << typeRef(t->getType()) << "*";
}

