/*
** Copyright (C) 2024 Rochus Keller (me@rochus-keller.ch)
**
** This file is part of the Micron language project.
**
**
** GNU Lesser General Public License Usage
** This file may be used under the terms of the GNU Lesser
** General Public License version 2.1 or version 3 as published by the Free
** Software Foundation and appearing in the file LICENSE.LGPLv21 and
** LICENSE.LGPLv3 included in the packaging of this file. Please review the
** following information to ensure the GNU Lesser General Public License
** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
*/

#include "MicEiGen.h"
#include <QTextStream>
#include <QCoreApplication>
#include <QDateTime>
#include <QtDebug>
using namespace Mic;

class EiGen::Imp
{
public:
    Imp(QIODevice* out):out(out){}
    ~Imp()
    {
        QHash<QByteArray,Type*>::const_iterator i;
        for(i = types.begin(); i != types.end(); ++i )
            delete i.value();
    }

    QTextStream out;
    QByteArray modName;
    QString sourceFile;

    struct Type
    {
        QByteArray name;
        bool public_;
        quint8 kind;
        quint32 len;
        Type* base;
    };

    QHash<QByteArray,Type*> types;
};

EiGen::EiGen(QIODevice* out)
{
    Q_ASSERT(out && out->isOpen());
    imp = new Imp(out);
}

EiGen::~EiGen()
{
    delete imp;
}

void EiGen::beginModule(const QByteArray& moduleName, const QString& sourceFile, const MilMetaParams& mp)
{
    imp->out << "; this is Eigen IR, see https://github.com/EigenCompilerSuite/" << endl;
    imp->out << "; generated by " << qApp->applicationName();
    if( !qApp->applicationVersion().isEmpty() )
     imp->out << " " << qApp->applicationVersion();
    imp->out << " on " << QDateTime::currentDateTime().toString(Qt::ISODate) << endl << endl;

    if( !mp.isEmpty() )
        qWarning() << "generic modules not yet supported";

    imp->modName = moduleName;
    imp->sourceFile = sourceFile;

    imp->out << ".type bool" << endl << "    type u1" << endl;
    imp->out << ".type char" << endl << "    type u1" << endl;
    imp->out << ".type float32" << endl << "    type f4" << endl;
    imp->out << ".type float64" << endl << "    type f8" << endl;
    imp->out << ".type int8" << endl << "    type s1" << endl;
    imp->out << ".type int16" << endl << "    type s2" << endl;
    imp->out << ".type int32" << endl << "    type s4" << endl;
    imp->out << ".type int64" << endl << "    type s8" << endl;
    //imp->out << ".type intptr" << endl << "    type ptr" << endl; // TODO fun
    imp->out << ".type uint8" << endl << "    type u1" << endl;
    imp->out << ".type uint16" << endl << "    type u2" << endl;
    imp->out << ".type uint32" << endl << "    type u4" << endl;
    imp->out << ".type uint64" << endl << "    type u8" << endl;

}

void EiGen::endModule()
{

}

void EiGen::addImport(const QByteArray& path, const QByteArray& name)
{
    qWarning() << "imports not yet supported: " << path << name;
}

void EiGen::addVariable(const QByteArray& typeRef, QByteArray name)
{

}

void EiGen::addProcedure(const MilProcedure& method)
{

}

void EiGen::beginType(const QByteArray& name, bool isPublic, quint8 typeKind)
{
    Q_ASSERT( typeKind == MilEmitter::Struct || typeKind == MilEmitter::Union || typeKind == MilEmitter::ProcType);

}

void EiGen::endType()
{

}

void EiGen::addType(const QByteArray& name, bool isPublic, const QByteArray& baseType, quint8 typeKind, quint32 len)
{
    Q_ASSERT( typeKind == MilEmitter::Alias || typeKind == MilEmitter::Pointer || typeKind == MilEmitter::Array);

}

void EiGen::addField(const QByteArray& fieldName, const QByteArray& typeRef, bool isPublic)
{

}

